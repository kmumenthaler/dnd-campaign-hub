import { App, AbstractInputSuggest, Editor, ItemView, MarkdownView, Modal, Notice, Plugin, PluginSettingTab, Setting, TextComponent, TFile, TFolder, WorkspaceLeaf, requestUrl } from "obsidian";
import {
  WORLD_TEMPLATE,
  SESSION_GM_TEMPLATE,
  SESSION_PLAYER_TEMPLATE,
  NPC_TEMPLATE,
  PC_TEMPLATE,
  ADVENTURE_TEMPLATE,
  SCENE_TEMPLATE,
  SCENE_SOCIAL_TEMPLATE,
  SCENE_COMBAT_TEMPLATE,
  SCENE_EXPLORATION_TEMPLATE,
  SCENE_PUZZLE_TEMPLATE,
  SCENE_MONTAGE_TEMPLATE,
  TRAP_TEMPLATE,
  FACTION_TEMPLATE,
  ITEM_TEMPLATE,
  SPELL_TEMPLATE,
  CAMPAIGN_TEMPLATE,
  SESSION_DEFAULT_TEMPLATE
} from "./templates";
import { MapManager } from "./map/MapManager";
import { MapCreationModal } from "./map/MapCreationModal";
import { MarkerLibrary } from "./marker/MarkerLibrary";
import { MarkerReference, MarkerDefinition, CREATURE_SIZE_SQUARES, CreatureSize, Layer } from "./marker/MarkerTypes";
import { MigrationManager, MigrationModal, TEMPLATE_VERSIONS } from "./migration";
import { MusicPlayer } from "./music/MusicPlayer";
import { MusicSettingsModal } from "./music/MusicSettingsModal";
import type { MusicSettings, SceneMusicConfig } from "./music/types";
import { DEFAULT_MUSIC_SETTINGS, AUDIO_EXTENSIONS } from "./music/types";
import { renderMusicPlayer, renderSoundboard } from "./music/MusicPlayerView";
import { SceneMusicModal, renderSceneMusicBlock, buildSceneMusicCodeblock } from "./music/SceneMusicBlock";
import { RandomEncounterTableModal } from "./encounter/RandomEncounterTableModal";
import {
  HexcrawlTracker,
  HexProcedureModal,
  openHexProcedureModal,
  buildTerrainPicker,
  setHexTerrain,
  getHexTerrainAt,
  drawTerrainHex,
  getTerrainDefinition,
  HexcrawlSettingsModal,
  HexDescriptionSettingsModal,
  HexDescriptionEditModal,
  TERRAIN_DEFINITIONS,
  HEXCRAWL_PACES,
  WEATHER_TABLE,
  createDefaultHexcrawlState,
  HexcrawlView,
  HEXCRAWL_VIEW_TYPE,
  CLIMATE_DEFINITIONS,
  getClimateDefinition,
  drawClimateHexBorder,
  getHexClimateAt,
  hLoc,
  EncounterBattlemapModal,
} from './hexcrawl';
import type {
  TerrainType,
  HexTerrain,
  HexcrawlState,
  TerrainPickerState,
  HexcrawlBridge,
  ClimateType,
  HexClimate,
} from './hexcrawl';

interface TabletopCalibration {
  monitorDiagonalInch: number;  // e.g. 27
  pixelsPerMm: number;          // computed from monitor size + screen resolution
  miniBaseMm: number;           // target grid cell physical size, default 25mm
}

interface DndCampaignHubSettings {
  currentCampaign: string;
  pluginVersion: string;
  tabletopCalibration: TabletopCalibration | null;
  musicSettings: MusicSettings;
}

const DEFAULT_SETTINGS: DndCampaignHubSettings = {
  currentCampaign: "ttrpgs/Frozen Sick (SOLINA)",
  pluginVersion: "0.0.0",
  tabletopCalibration: null,
  musicSettings: { ...DEFAULT_MUSIC_SETTINGS },
};

class CalibrationModal extends Modal {
  pixelDistance: number;
  onSelect: (miles: number) => void;

  constructor(app: App, pixelDistance: number, onSelect: (miles: number) => void) {
    super(app);
    this.pixelDistance = pixelDistance;
    this.onSelect = onSelect;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "Calibrate Grid" });

    contentEl.createEl("p", { 
      text: `Measured distance: ${Math.round(this.pixelDistance)} pixels`,
      cls: "dnd-map-calibration-info"
    });

    contentEl.createEl("p", { 
      text: "Select the travel pace this hex represents (D&D 5e daily travel distance):",
      cls: "dnd-map-calibration-label"
    });

    // Travel pace options
    const optionsContainer = contentEl.createDiv({ cls: "dnd-calibration-options" });

    const paceOptions = [
      { miles: 30, label: "30 Miles/Day (Fast Pace)", desc: "Forced march" },
      { miles: 24, label: "24 Miles/Day (Normal Pace)", desc: "Standard travel" },
      { miles: 18, label: "18 Miles/Day (Slow Pace)", desc: "Stealthy or difficult terrain" }
    ];

    paceOptions.forEach(option => {
      const optionBtn = optionsContainer.createEl("button", {
        cls: "dnd-calibration-option-btn"
      });

      optionBtn.createEl("div", { 
        text: option.label,
        cls: "dnd-calibration-option-label"
      });

      optionBtn.createEl("div", { 
        text: option.desc,
        cls: "dnd-calibration-option-desc"
      });

      optionBtn.addEventListener("click", () => {
        this.onSelect(option.miles);
        this.close();
      });
    });

    // Cancel button
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class CreatureSelectorModal extends Modal {
  creatures: any[];
  onSelect: (creature: any) => void;
  searchInput!: HTMLInputElement;
  resultsContainer!: HTMLElement;

  constructor(app: App, creatures: any[], onSelect: (creature: any) => void) {
    super(app);
    this.creatures = creatures;
    this.onSelect = onSelect;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("encounter-creature-selector");

    contentEl.createEl("h2", { text: "Select Creature" });

    // Search input
    const searchContainer = contentEl.createDiv({ cls: "search-input-container" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search creatures by name...",
      cls: "search-input"
    });

    this.searchInput.addEventListener("input", () => this.updateResults());
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        const firstResult = this.resultsContainer.querySelector(".creature-item");
        if (firstResult) {
          (firstResult as HTMLElement).click();
        }
      }
    });

    // Results container
    this.resultsContainer = contentEl.createDiv({ cls: "creature-results" });
    
    // Initial results
    this.updateResults();

    // Focus search input
    setTimeout(() => this.searchInput.focus(), 100);
  }

  updateResults() {
    this.resultsContainer.empty();
    
    const searchTerm = this.searchInput.value.toLowerCase();
    const filtered = this.creatures.filter(c => 
      (c.name || "").toLowerCase().includes(searchTerm)
    );

    if (filtered.length === 0) {
      this.resultsContainer.createDiv({ 
        text: "No creatures found", 
        cls: "no-results" 
      });
      return;
    }

    // Show up to 50 results
    const displayList = filtered.slice(0, 50);
    
    displayList.forEach(creature => {
      const item = this.resultsContainer.createDiv({ cls: "creature-item" });
      
      const nameEl = item.createDiv({ cls: "creature-name" });
      nameEl.setText(creature.name || "Unknown");
      
      const detailsEl = item.createDiv({ cls: "creature-details" });
      const cr = creature.cr?.toString() || "?";
      const source = creature.source || "Unknown";
      detailsEl.setText(`CR ${cr} ‚Ä¢ ${source}`);
      
      item.addEventListener("click", () => {
        this.onSelect(creature);
        this.close();
      });
    });

    if (filtered.length > 50) {
      this.resultsContainer.createDiv({ 
        text: `Showing 50 of ${filtered.length} results. Refine your search.`,
        cls: "results-note"
      });
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class MultiCreatureSelectorModal extends Modal {
  creatures: any[];
  onSelect: (creatures: any[]) => void;
  searchInput!: HTMLInputElement;
  resultsContainer!: HTMLElement;
  footerContainer!: HTMLElement;
  selectedKeys = new Set<string>();
  creatureByKey = new Map<string, any>();

  constructor(app: App, creatures: any[], onSelect: (creatures: any[]) => void) {
    super(app);
    this.creatures = creatures;
    this.onSelect = onSelect;
    for (const c of creatures) {
      this.creatureByKey.set(this.getKey(c), c);
    }
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("encounter-creature-selector");

    contentEl.createEl("h2", { text: "Select Creatures" });

    const searchContainer = contentEl.createDiv({ cls: "search-input-container" });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search creatures by name...",
      cls: "search-input"
    });

    this.searchInput.addEventListener("input", () => this.updateResults());

    this.resultsContainer = contentEl.createDiv({ cls: "creature-results" });
    this.footerContainer = contentEl.createDiv({ cls: "creature-selector-footer" });
    this.footerContainer.style.display = "flex";
    this.footerContainer.style.justifyContent = "space-between";
    this.footerContainer.style.alignItems = "center";
    this.footerContainer.style.marginTop = "10px";

    const leftControls = this.footerContainer.createDiv();
    leftControls.style.display = "flex";
    leftControls.style.gap = "10px";

    const selectVisibleBtn = leftControls.createEl("button", { text: "Select Visible" });
    selectVisibleBtn.onclick = () => {
      const visibleItems = this.resultsContainer.querySelectorAll(".creature-item[data-key]");
      visibleItems.forEach((el) => {
        const key = (el as HTMLElement).dataset.key;
        if (key) this.selectedKeys.add(key);
      });
      this.updateResults();
    };

    const clearBtn = leftControls.createEl("button", { text: "Clear" });
    clearBtn.onclick = () => {
      this.selectedKeys.clear();
      this.updateResults();
    };

    const actionControls = this.footerContainer.createDiv();
    actionControls.style.display = "flex";
    actionControls.style.gap = "10px";

    const addSelectedBtn = actionControls.createEl("button", { text: "Add Selected" });
    addSelectedBtn.onclick = () => {
      const selectedCreatures = Array.from(this.selectedKeys)
        .map((key) => this.creatureByKey.get(key))
        .filter(Boolean);
      if (selectedCreatures.length > 0) {
        this.onSelect(selectedCreatures);
        this.close();
      }
    };

    const cancelBtn = actionControls.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();

    this.updateResults();

    setTimeout(() => this.searchInput.focus(), 100);
  }

  getKey(creature: any): string {
    return creature?.path ? `${creature.path}::${creature.name}` : (creature?.name || "Unknown");
  }

  updateResults() {
    this.resultsContainer.empty();

    const searchTerm = this.searchInput.value.toLowerCase();
    const filtered = this.creatures.filter(c =>
      (c.name || "").toLowerCase().includes(searchTerm)
    );

    if (filtered.length === 0) {
      this.resultsContainer.createDiv({
        text: "No creatures found",
        cls: "no-results"
      });
      return;
    }

    const displayList = filtered.slice(0, 50);

    displayList.forEach(creature => {
      const key = this.getKey(creature);
      const item = this.resultsContainer.createDiv({ cls: "creature-item" });
      item.dataset.key = key;
      item.style.display = "flex";
      item.style.alignItems = "center";
      item.style.gap = "10px";

      const checkbox = item.createEl("input", { type: "checkbox" });
      checkbox.checked = this.selectedKeys.has(key);
      checkbox.onchange = () => {
        if (checkbox.checked) {
          this.selectedKeys.add(key);
        } else {
          this.selectedKeys.delete(key);
        }
      };

      const infoDiv = item.createDiv();
      const nameEl = infoDiv.createDiv({ cls: "creature-name" });
      nameEl.setText(creature.name || "Unknown");

      const detailsEl = infoDiv.createDiv({ cls: "creature-details" });
      const cr = creature.cr?.toString() || "?";
      const source = creature.source || "Unknown";
      detailsEl.setText(`CR ${cr} ‚Ä¢ ${source}`);

      item.addEventListener("click", (evt) => {
        if ((evt.target as HTMLElement).tagName.toLowerCase() === "input") return;
        checkbox.checked = !checkbox.checked;
        checkbox.onchange?.(new Event("change"));
      });
    });

    if (filtered.length > 50) {
      this.resultsContainer.createDiv({
        text: `Showing 50 of ${filtered.length} results. Refine your search.`,
        cls: "results-note"
      });
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class EncounterBuilderModal extends Modal {
  plugin: DndCampaignHubPlugin;
  encounterBuilder: EncounterBuilder;
  encounterName = "";
  creatures: EncounterCreature[] = [];
  includeParty = true;
  selectedPartyMembers: string[] = [];  // Selected party member names
  selectedPartyId = "";
  selectedPartyName = "";
  useColorNames = false;
  adventurePath = "";
  scenePath = "";
  campaignPath = "";
  
  // For editing existing encounters
  isEdit = false;
  originalEncounterPath = "";
  
  // UI containers
  creatureListContainer: HTMLElement | null = null;
  difficultyContainer: HTMLElement | null = null;
  partySelectionContainer: HTMLElement | null = null;
  partyMemberListContainer: HTMLElement | null = null;

  constructor(app: App, plugin: DndCampaignHubPlugin, encounterPath?: string) {
    super(app);
    this.plugin = plugin;
    this.encounterBuilder = new EncounterBuilder(app, plugin);
    if (encounterPath) {
      this.isEdit = true;
      this.originalEncounterPath = encounterPath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    
    // If editing, load existing encounter data
    if (this.isEdit) {
      await this.loadEncounterData();
    }

    contentEl.createEl("h2", { text: this.isEdit ? "‚öîÔ∏è Edit Encounter" : "‚öîÔ∏è Create New Encounter" });

    // Encounter Name
    new Setting(contentEl)
      .setName("Encounter Name")
      .setDesc("Give this encounter a memorable name")
      .addText((text) =>
        text
          .setPlaceholder("Goblin Ambush")
          .setValue(this.encounterName)
          .onChange((value) => {
            this.encounterName = value;
          })
      );

    // Include Party
    new Setting(contentEl)
      .setName("Include Party Members")
      .setDesc("Select party members to include in the encounter")
      .addToggle((toggle) =>
        toggle
          .setValue(this.includeParty)
          .onChange(async (value) => {
            this.includeParty = value;
            await this.renderPartySelection();
            this.updateDifficultyDisplay();
          })
      );

    // Party Selection Container
    this.partySelectionContainer = contentEl.createDiv();
    this.partySelectionContainer.style.marginBottom = "15px";
    await this.renderPartySelection();

    // Party Member List Container
    this.partyMemberListContainer = contentEl.createDiv({ cls: "dnd-party-member-list" });
    this.partyMemberListContainer.style.marginBottom = "15px";
    await this.renderPartyMemberList();

    // Use Color Names
    new Setting(contentEl)
      .setName("Use Color Names")
      .setDesc("Add color suffixes to creatures (e.g., 'Goblin Red', 'Goblin Blue')")
      .addToggle((toggle) =>
        toggle
          .setValue(this.useColorNames)
          .onChange((value) => {
            this.useColorNames = value;
          })
      );

    // Creatures Section
    contentEl.createEl("h3", { text: "Creatures" });
    
    // Creature list container
    this.creatureListContainer = contentEl.createDiv({ cls: "dnd-creature-list" });
    this.renderCreatureList();
    
    // Show creature input fields
    await this.showCreatureInputFields(contentEl);

    // Difficulty Display Section
    contentEl.createEl("h3", { text: "Encounter Difficulty" });
    this.difficultyContainer = contentEl.createDiv({ cls: "dnd-difficulty-container" });
    await this.updateDifficultyDisplay();

    // Action Buttons (placed at the end after all content)
    const buttonContainer = new Setting(contentEl);
    
    buttonContainer.addButton((button) =>
      button
        .setButtonText(this.isEdit ? "Update Encounter" : "Create Encounter")
        .setCta()
        .onClick(() => {
          this.saveEncounter();
        })
    );

    if (this.isEdit) {
      buttonContainer.addButton((button) =>
        button
          .setButtonText("Delete Encounter")
          .setWarning()
          .onClick(() => {
            this.deleteEncounter();
          })
      );
    }
  }

  async loadEncounterData() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.originalEncounterPath);
      if (!(file instanceof TFile)) return;

      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      
      if (cache?.frontmatter) {
        this.encounterName = cache.frontmatter.name || "";
        this.includeParty = cache.frontmatter.include_party !== false;
        this.useColorNames = cache.frontmatter.use_color_names || false;
        this.adventurePath = cache.frontmatter.adventure_path || "";
        this.scenePath = cache.frontmatter.scene_path || "";
        this.campaignPath = cache.frontmatter.campaign_path || "";
        this.selectedPartyId = cache.frontmatter.selected_party_id || "";
        this.selectedPartyName = cache.frontmatter.selected_party_name || "";
        if (!this.selectedPartyId && this.selectedPartyName) {
          this.selectedPartyId = this.selectedPartyName;
        }
        
        // Load creatures
        if (cache.frontmatter.creatures && Array.isArray(cache.frontmatter.creatures)) {
          this.creatures = cache.frontmatter.creatures.map((c: any) => ({
            name: c.name || "",
            count: c.count || 1,
            hp: c.hp,
            ac: c.ac,
            cr: c.cr,
            source: c.source,
            path: c.path,
            isFriendly: c.is_friendly === true || c.is_friendly === "true",
            isHidden: c.is_hidden === true || c.is_hidden === "true"
          }));
          console.log("[EncounterBuilder] Loaded creatures:", this.creatures);
        }
      }

      this.syncEncounterBuilder();
    } catch (error) {
      console.error("Error loading encounter data:", error);
      new Notice("Error loading encounter data");
    }
  }

  syncEncounterBuilder() {
    this.encounterBuilder.encounterName = this.encounterName;
    this.encounterBuilder.creatures = [...this.creatures];
    this.encounterBuilder.includeParty = this.includeParty;
    this.encounterBuilder.useColorNames = this.useColorNames;
    this.encounterBuilder.selectedPartyMembers = [...this.selectedPartyMembers];
    this.encounterBuilder.selectedPartyId = this.selectedPartyId || "";
    this.encounterBuilder.adventurePath = this.adventurePath;
    this.encounterBuilder.scenePath = this.scenePath;
    this.encounterBuilder.campaignPath = this.campaignPath;
  }

  async renderPartySelection() {
    if (!this.partySelectionContainer) return;
    this.partySelectionContainer.empty();

    if (!this.includeParty) return;

    try {
      this.syncEncounterBuilder();
      const parties = await this.encounterBuilder.getAvailableParties();

      if (parties.length === 0) {
        this.partySelectionContainer.createEl("p", {
          text: "‚ö†Ô∏è No parties found in Initiative Tracker",
          attr: { style: "color: var(--text-warning); font-style: italic; margin: 10px 0;" }
        });
        return;
      }

      if (!this.selectedPartyId) {
        const defaultParty = await this.encounterBuilder.getResolvedParty();
        if (defaultParty?.id) this.selectedPartyId = defaultParty.id;
        if (defaultParty?.name) this.selectedPartyName = defaultParty.name;
      }

      const partySetting = new Setting(this.partySelectionContainer)
        .setName("Party")
        .setDesc("Choose which party to use for difficulty calculations");

      partySetting.addDropdown((dropdown) => {
        parties.forEach(party => {
          dropdown.addOption(party.id, party.name);
        });
        dropdown.setValue(this.selectedPartyId || parties[0]!.id);
        dropdown.onChange((value) => {
          this.selectedPartyId = value;
          const selected = parties.find(p => p.id === value);
          this.selectedPartyName = selected?.name || "";
          this.selectedPartyMembers = [];
        });
      });

      partySetting.addButton((button) =>
        button
          .setButtonText("Apply Party")
          .onClick(async () => {
            await this.renderPartySelection();
            await this.renderPartyMemberList();
            this.updateDifficultyDisplay();
          })
      );

      const partyMembers = await this.encounterBuilder.getAvailablePartyMembers();
      
      if (partyMembers.length === 0) {
        this.partySelectionContainer.createEl("p", {
          text: "‚ö†Ô∏è No party members found in Initiative Tracker",
          attr: { style: "color: var(--text-warning); font-style: italic; margin: 10px 0;" }
        });
        return;
      }

      const selectionDiv = this.partySelectionContainer.createDiv();
      selectionDiv.style.border = "1px solid var(--background-modifier-border)";
      selectionDiv.style.padding = "10px";
      selectionDiv.style.borderRadius = "5px";
      selectionDiv.style.marginBottom = "10px";

      selectionDiv.createEl("h4", { text: "Select Party Members", attr: { style: "margin-top: 0;" } });

      for (const member of partyMembers) {
        const checkboxDiv = selectionDiv.createDiv();
        checkboxDiv.style.marginBottom = "5px";

        const checkbox = checkboxDiv.createEl("input", { type: "checkbox" });
        checkbox.checked = this.selectedPartyMembers.includes(member.name);
        checkbox.style.marginRight = "10px";
        checkbox.onchange = () => {
          if (checkbox.checked) {
            if (!this.selectedPartyMembers.includes(member.name)) {
              this.selectedPartyMembers.push(member.name);
            }
          } else {
            this.selectedPartyMembers = this.selectedPartyMembers.filter(n => n !== member.name);
          }
          this.renderPartyMemberList();
          this.updateDifficultyDisplay();
        };

        const label = checkboxDiv.createEl("span", { 
          text: `${member.name} (Level ${member.level}, HP: ${member.hp}, AC: ${member.ac})`
        });
        label.style.cursor = "pointer";
        label.onclick = () => {
          checkbox.checked = !checkbox.checked;
          checkbox.onchange?.(new Event('change'));
        };
      }

      // Select All / Deselect All / Refresh buttons
      const buttonsDiv = selectionDiv.createDiv();
      buttonsDiv.style.marginTop = "10px";
      buttonsDiv.style.display = "flex";
      buttonsDiv.style.gap = "10px";

      const selectAllBtn = buttonsDiv.createEl("button", { text: "Select All" });
      selectAllBtn.style.fontSize = "0.85em";
      selectAllBtn.onclick = () => {
        this.selectedPartyMembers = partyMembers.map(m => m.name);
        this.renderPartySelection();
        this.renderPartyMemberList();
        this.updateDifficultyDisplay();
      };

      const deselectAllBtn = buttonsDiv.createEl("button", { text: "Deselect All" });
      deselectAllBtn.style.fontSize = "0.85em";
      deselectAllBtn.onclick = () => {
        this.selectedPartyMembers = [];
        this.renderPartySelection();
        this.renderPartyMemberList();
        this.updateDifficultyDisplay();
      };

      const refreshBtn = buttonsDiv.createEl("button", { text: "üîÑ Refresh Stats" });
      refreshBtn.style.fontSize = "0.85em";
      refreshBtn.title = "Reload party stats from Initiative Tracker";
      refreshBtn.onclick = async () => {
        const success = await this.encounterBuilder.refreshPartyData();
        if (success) {
          this.renderPartySelection();
          this.renderPartyMemberList();
          this.updateDifficultyDisplay();
        }
      };
    } catch (error) {
      console.error("Error rendering party selection:", error);
    }
  }

  async renderPartyMemberList() {
    if (!this.partyMemberListContainer) return;
    this.partyMemberListContainer.empty();

    if (!this.includeParty || this.selectedPartyMembers.length === 0) {
      return;
    }

    try {
      const partyMembers = await this.encounterBuilder.getAvailablePartyMembers();
      const memberByName = new Map(partyMembers.map(m => [m.name, m]));

      const headerDiv = this.partyMemberListContainer.createDiv({ cls: "dnd-party-member-header" });
      headerDiv.style.marginBottom = "10px";
      headerDiv.style.fontWeight = "600";
      headerDiv.setText(`Selected Party Members (${this.selectedPartyMembers.length})`);

      for (const memberName of this.selectedPartyMembers) {
        const memberData = memberByName.get(memberName);
        if (!memberData) continue;

        const memberItem = this.partyMemberListContainer.createDiv({ cls: "dnd-creature-item" });
        
        const nameEl = memberItem.createSpan({ cls: "dnd-creature-name" });
        nameEl.setText(memberName);
        
        const statsEl = memberItem.createSpan({ cls: "dnd-creature-stats" });
        const stats: string[] = [];
        stats.push(`Level: ${memberData.level}`);
        stats.push(`HP: ${memberData.hp}`);
        stats.push(`AC: ${memberData.ac}`);
        statsEl.setText(` | ${stats.join(" | ")}`);
        
        const removeBtn = memberItem.createEl("button", {
          text: "Remove",
          cls: "dnd-creature-remove"
        });
        removeBtn.addEventListener("click", () => {
          this.removePartyMember(memberName);
        });
      }
    } catch (error) {
      console.error("Error rendering party member list:", error);
    }
  }

  removePartyMember(memberName: string) {
    this.selectedPartyMembers = this.selectedPartyMembers.filter(n => n !== memberName);
    this.renderPartySelection();
    this.renderPartyMemberList();
    this.updateDifficultyDisplay();
  }

  async getAvailablePartyMembers(): Promise<Array<{ name: string; level: number; hp: number; ac: number }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getAvailablePartyMembers();
  }

  async showCreatureInputFields(container: HTMLElement) {
    // === VAULT CREATURE SELECTION ===
    const vaultCreatureSection = container.createDiv({ cls: "dnd-add-creature-vault" });
    
    let selectedCreature: { name: string; path: string; hp: number; ac: number; cr?: string } | null = null;
    let vaultCreatureCount = "1";
    let vaultCreatureIsFriendly = false;
    let vaultCreatureIsHidden = false;
    let searchResults: HTMLElement | null = null;
    let friendlyCheckbox: HTMLInputElement;
    let hiddenCheckbox: HTMLInputElement;
    
    // Load creatures from vault
    this.syncEncounterBuilder();
    const vaultCreatures = await this.encounterBuilder.loadAllCreatures();
    
    console.log("Loaded creatures:", vaultCreatures.length, vaultCreatures.slice(0, 3).map(c => c.name));
    
    if (vaultCreatures.length > 0) {
      const vaultCreatureSetting = new Setting(vaultCreatureSection)
        .setName("Add from Vault")
        .setDesc(`Search and select creatures from your vault (${vaultCreatures.length} available)`);
      
      // Create search input container
      const searchContainer = vaultCreatureSetting.controlEl.createDiv({ cls: "dnd-creature-search-container" });
      
      const searchInput = searchContainer.createEl("input", {
        type: "text",
        placeholder: "Search creatures...",
        cls: "dnd-creature-search-input"
      });
      
      // Search results container
      searchResults = searchContainer.createDiv({ cls: "dnd-creature-search-results" });
      searchResults.style.display = "none";
      
      // Filter and display results
      const showSearchResults = (query: string) => {
        if (!searchResults) return;
        
        if (!query || query.length < 1) {
          searchResults.style.display = "none";
          return;
        }
        
        const queryLower = query.toLowerCase().trim();
        
        const filtered = vaultCreatures.filter(c => {
          return c.name.toLowerCase().includes(queryLower);
        }).slice(0, 10); // Limit to 10 results
        
        searchResults.empty();
        
        if (filtered.length === 0) {
          searchResults.createEl("div", {
            text: "No creatures found",
            cls: "dnd-creature-search-no-results"
          });
          searchResults.style.display = "block";
          return;
        }
        
        filtered.forEach(creature => {
          const resultEl = searchResults!.createDiv({ cls: "dnd-creature-search-result" });
          
          const nameEl = resultEl.createDiv({ cls: "dnd-creature-search-result-name" });
          nameEl.setText(creature.name);
          
          const statsEl = resultEl.createDiv({ cls: "dnd-creature-search-result-stats" });
          const statsParts: string[] = [];
          if (creature.cr) statsParts.push(`CR ${creature.cr}`);
          statsParts.push(`HP ${creature.hp}`);
          statsParts.push(`AC ${creature.ac}`);
          statsEl.setText(statsParts.join(" | "));
          
          resultEl.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            selectedCreature = creature;
            searchInput.value = creature.name;
            if (searchResults) {
              searchResults.style.display = "none";
            }
          });
        });
        
        searchResults.style.display = "block";
      };
      
      // Search input events
      searchInput.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        showSearchResults(target.value);
      });
      
      searchInput.addEventListener("focus", (e) => {
        const target = e.target as HTMLInputElement;
        if (target.value.length >= 1) {
          showSearchResults(target.value);
        }
      });
      
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && selectedCreature) {
          e.preventDefault();
          // Add creature
          this.creatures.push({
            name: selectedCreature.name,
            count: parseInt(vaultCreatureCount) || 1,
            hp: selectedCreature.hp,
            ac: selectedCreature.ac,
            cr: selectedCreature.cr,
            source: "vault",
            path: selectedCreature.path,
            isCustom: false,
            isFriendly: vaultCreatureIsFriendly,
            isHidden: vaultCreatureIsHidden
          });
          this.renderCreatureList();
          this.updateDifficultyDisplay();
          new Notice(`Added ${vaultCreatureCount}x ${selectedCreature.name}`);
          searchInput.value = "";
          selectedCreature = null;
          vaultCreatureIsFriendly = false;
          vaultCreatureIsHidden = false;
          // Reset checkboxes (they're created later but will exist when this callback runs)
          setTimeout(() => {
            const friendlyCheckbox = searchInput.closest('.setting-item')?.querySelector('.dnd-inline-checkbox input[type=\"checkbox\"]') as HTMLInputElement;
            const hiddenCheckbox = searchInput.closest('.setting-item')?.querySelectorAll('.dnd-inline-checkbox input[type=\"checkbox\"]')[1] as HTMLInputElement;
            if (friendlyCheckbox) friendlyCheckbox.checked = false;
            if (hiddenCheckbox) hiddenCheckbox.checked = false;
          }, 0);
        }
      });
      
      // Close search results when clicking outside
      searchInput.addEventListener("blur", () => {
        setTimeout(() => {
          if (searchResults) {
            searchResults.style.display = "none";
          }
        }, 250);
      });
      
      // Count input
      vaultCreatureSetting.addText(text => {
        text.setPlaceholder("Count")
          .setValue("1")
          .onChange(value => vaultCreatureCount = value);
        text.inputEl.type = "number";
        text.inputEl.style.width = "60px";
      });
      
      // Friendly checkbox container
      const friendlyContainer = vaultCreatureSetting.controlEl.createDiv({ cls: "dnd-inline-checkbox" });
      friendlyContainer.style.display = "inline-flex";
      friendlyContainer.style.alignItems = "center";
      friendlyContainer.style.marginLeft = "8px";
      
      friendlyCheckbox = friendlyContainer.createEl("input", { type: "checkbox" });
      friendlyCheckbox.style.marginRight = "4px";
      friendlyCheckbox.addEventListener("change", (e) => {
        vaultCreatureIsFriendly = (e.target as HTMLInputElement).checked;
      });
      
      const friendlyLabel = friendlyContainer.createEl("label");
      friendlyLabel.setText("Friendly");
      friendlyLabel.style.fontSize = "13px";
      friendlyLabel.style.cursor = "pointer";
      friendlyLabel.addEventListener("click", () => {
        friendlyCheckbox.checked = !friendlyCheckbox.checked;
        vaultCreatureIsFriendly = friendlyCheckbox.checked;
      });
      
      // Hidden checkbox container
      const hiddenContainer = vaultCreatureSetting.controlEl.createDiv({ cls: "dnd-inline-checkbox" });
      hiddenContainer.style.display = "inline-flex";
      hiddenContainer.style.alignItems = "center";
      hiddenContainer.style.marginLeft = "8px";
      
      hiddenCheckbox = hiddenContainer.createEl("input", { type: "checkbox" });
      hiddenCheckbox.style.marginRight = "4px";
      hiddenCheckbox.addEventListener("change", (e) => {
        vaultCreatureIsHidden = (e.target as HTMLInputElement).checked;
      });
      
      const hiddenLabel = hiddenContainer.createEl("label");
      hiddenLabel.setText("Hidden");
      hiddenLabel.style.fontSize = "13px";
      hiddenLabel.style.cursor = "pointer";
      hiddenLabel.addEventListener("click", () => {
        hiddenCheckbox.checked = !hiddenCheckbox.checked;
        vaultCreatureIsHidden = hiddenCheckbox.checked;
      });
      
      // Add button
      vaultCreatureSetting.addButton(btn => btn
        .setButtonText("Add")
        .setCta()
        .onClick(() => {
          if (!selectedCreature) {
            new Notice("Please search and select a creature first!");
            return;
          }
          
          this.creatures.push({
            name: selectedCreature.name,
            count: parseInt(vaultCreatureCount) || 1,
            hp: selectedCreature.hp,
            ac: selectedCreature.ac,
            cr: selectedCreature.cr,
            source: "vault",
            path: selectedCreature.path,
            isCustom: false,
            isFriendly: vaultCreatureIsFriendly,
            isHidden: vaultCreatureIsHidden
          });
          
          this.renderCreatureList();
          this.updateDifficultyDisplay();
          new Notice(`Added ${vaultCreatureCount}x ${selectedCreature.name}`);
          
          // Clear search and reset checkboxes
          searchInput.value = "";
          selectedCreature = null;
          vaultCreatureIsFriendly = false;
          vaultCreatureIsHidden = false;
          friendlyCheckbox.checked = false;
          hiddenCheckbox.checked = false;
        }));
    } else {
      vaultCreatureSection.createEl("p", {
        text: "‚ö†Ô∏è No creatures found in z_Beastiarity folder. Use manual entry below.",
        cls: "setting-item-description mod-warning"
      });
    }
    
    // === MANUAL CREATURE ENTRY ===
    const addCreatureSection = container.createDiv({ cls: "dnd-add-creature-manual" });
    
    let newCreatureName = "";
    let newCreatureCount = "1";
    let newCreatureHP = "";
    let newCreatureAC = "";
    let newCreatureCR = "";
    let newCreatureIsFriendly = false;
    let newCreatureIsHidden = false;
    
    const addCreatureSetting = new Setting(addCreatureSection)
      .setName("Add Custom Creature")
      .setDesc("Enter creature details manually for custom or homebrew enemies");
    
    // Creature name input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("Name (e.g., Goblin)")
        .onChange(value => newCreatureName = value);
      text.inputEl.style.width = "120px";
    });
    
    // Count input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("Count")
        .setValue("1")
        .onChange(value => newCreatureCount = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // HP input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("HP")
        .onChange(value => newCreatureHP = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // AC input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("AC")
        .onChange(value => newCreatureAC = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // CR input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("CR")
        .onChange(value => newCreatureCR = value);
      text.inputEl.style.width = "60px";
    });
    
    // Friendly checkbox container
    const manualFriendlyContainer = addCreatureSetting.controlEl.createDiv({ cls: "dnd-inline-checkbox" });
    manualFriendlyContainer.style.display = "inline-flex";
    manualFriendlyContainer.style.alignItems = "center";
    manualFriendlyContainer.style.marginLeft = "8px";
    
    const manualFriendlyCheckbox = manualFriendlyContainer.createEl("input", { type: "checkbox" });
    manualFriendlyCheckbox.style.marginRight = "4px";
    manualFriendlyCheckbox.addEventListener("change", (e) => {
      newCreatureIsFriendly = (e.target as HTMLInputElement).checked;
    });
    
    const manualFriendlyLabel = manualFriendlyContainer.createEl("label");
    manualFriendlyLabel.setText("Friendly");
    manualFriendlyLabel.style.fontSize = "13px";
    manualFriendlyLabel.style.cursor = "pointer";
    manualFriendlyLabel.addEventListener("click", () => {
      manualFriendlyCheckbox.checked = !manualFriendlyCheckbox.checked;
      newCreatureIsFriendly = manualFriendlyCheckbox.checked;
    });
    
    // Hidden checkbox container
    const manualHiddenContainer = addCreatureSetting.controlEl.createDiv({ cls: "dnd-inline-checkbox" });
    manualHiddenContainer.style.display = "inline-flex";
    manualHiddenContainer.style.alignItems = "center";
    manualHiddenContainer.style.marginLeft = "8px";
    
    const manualHiddenCheckbox = manualHiddenContainer.createEl("input", { type: "checkbox" });
    manualHiddenCheckbox.style.marginRight = "4px";
    manualHiddenCheckbox.addEventListener("change", (e) => {
      newCreatureIsHidden = (e.target as HTMLInputElement).checked;
    });
    
    const manualHiddenLabel = manualHiddenContainer.createEl("label");
    manualHiddenLabel.setText("Hidden");
    manualHiddenLabel.style.fontSize = "13px";
    manualHiddenLabel.style.cursor = "pointer";
    manualHiddenLabel.addEventListener("click", () => {
      manualHiddenCheckbox.checked = !manualHiddenCheckbox.checked;
      newCreatureIsHidden = manualHiddenCheckbox.checked;
    });
    
    // Add button
    addCreatureSetting.addButton(btn => btn
      .setButtonText("Add")
      .setCta()
      .onClick(() => {
        if (!newCreatureName.trim()) {
          new Notice("Please enter a creature name!");
          return;
        }
        
        this.creatures.push({
          name: newCreatureName.trim(),
          count: parseInt(newCreatureCount) || 1,
          hp: newCreatureHP ? parseInt(newCreatureHP) : undefined,
          ac: newCreatureAC ? parseInt(newCreatureAC) : undefined,
          cr: newCreatureCR || undefined,
          source: "manual",
          path: undefined,
          isCustom: true,
          isFriendly: newCreatureIsFriendly,
          isHidden: newCreatureIsHidden
        });
        
        this.renderCreatureList();
        this.updateDifficultyDisplay();
        new Notice(`Added ${newCreatureCount}x ${newCreatureName}`);
        
        // Reset all input fields
        newCreatureName = "";
        newCreatureCount = "1";
        newCreatureHP = "";
        newCreatureAC = "";
        newCreatureCR = "";
        newCreatureIsFriendly = false;
        newCreatureIsHidden = false;
        manualFriendlyCheckbox.checked = false;
        manualHiddenCheckbox.checked = false;
      }));
    
    // Info text
    container.createEl("p", {
      text: "üí° Tip: Select creatures from your vault or add custom enemies on the fly. You can edit stats later in Initiative Tracker.",
      cls: "setting-item-description"
    });
  }

  removeCreature(index: number) {
    this.creatures.splice(index, 1);
    this.renderCreatureList();
    this.updateDifficultyDisplay();
  }

  renderCreatureList() {
    if (!this.creatureListContainer) return;
    this.creatureListContainer.empty();

    if (this.creatures.length === 0) {
      this.creatureListContainer.createEl("p", {
        text: "No creatures added yet. Add creatures below.",
        cls: "setting-item-description"
      });
      return;
    }

    this.creatures.forEach((creature, index) => {
      const creatureItem = this.creatureListContainer!.createDiv({ 
        cls: `dnd-creature-item${creature.isFriendly ? ' friendly' : ''}` 
      });
      
      const nameEl = creatureItem.createSpan({ cls: "dnd-creature-name" });
      const friendlyIndicator = creature.isFriendly ? "ü§ù " : "";
      const hiddenIndicator = creature.isHidden ? "üëÅÔ∏è‚Äçüó®Ô∏è " : "";
      nameEl.setText(`${friendlyIndicator}${hiddenIndicator}${creature.name} x${creature.count}`);
      
      const statsEl = creatureItem.createSpan({ cls: "dnd-creature-stats" });
      const stats: string[] = [];
      if (creature.hp) stats.push(`HP: ${creature.hp}`);
      if (creature.ac) stats.push(`AC: ${creature.ac}`);
      if (creature.cr) stats.push(`CR: ${creature.cr}`);
      if (creature.isFriendly) stats.push("ü§ù Friendly");
      if (creature.isHidden) stats.push("üëÅÔ∏è‚Äçüó®Ô∏è Hidden");
      statsEl.setText(stats.length > 0 ? ` | ${stats.join(" | ")}` : "");
      
      // Friendly toggle button
      const friendlyBtn = creatureItem.createEl("button", {
        text: "Friendly",
        cls: `dnd-creature-friendly-toggle${creature.isFriendly ? ' active' : ''}`
      });
      friendlyBtn.addEventListener("click", () => {
        creature.isFriendly = !creature.isFriendly;
        this.renderCreatureList();
        this.updateDifficultyDisplay();
      });
      
      // Hidden toggle button
      const hiddenBtn = creatureItem.createEl("button", {
        text: "Hidden",
        cls: `dnd-creature-hidden-toggle${creature.isHidden ? ' active' : ''}`
      });
      hiddenBtn.addEventListener("click", () => {
        creature.isHidden = !creature.isHidden;
        this.renderCreatureList();
        this.updateDifficultyDisplay();
      });
      
      const removeBtn = creatureItem.createEl("button", {
        text: "Remove",
        cls: "dnd-creature-remove"
      });
      removeBtn.addEventListener("click", () => {
        this.removeCreature(index);
      });
    });
  }

  async updateDifficultyDisplay() {
    if (!this.difficultyContainer) return;

    this.difficultyContainer.empty();

    if (this.creatures.length === 0) {
      this.difficultyContainer.createEl("p", {
        text: "Add creatures to see encounter difficulty analysis.",
        cls: "setting-item-description"
      });
      return;
    }

    const loadingEl = this.difficultyContainer.createEl("p", { text: "Calculating difficulty..." });

    this.syncEncounterBuilder();
    const result = await this.encounterBuilder.calculateEncounterDifficulty();

    loadingEl.remove();

    const difficultyCard = this.difficultyContainer.createDiv({ cls: "dnd-difficulty-card" });

    const header = difficultyCard.createDiv({ cls: "dnd-difficulty-header" });

    const difficultyBadge = header.createEl("span", {
      text: result.analysis.difficulty,
      cls: "dnd-difficulty-badge"
    });
    difficultyBadge.style.backgroundColor = result.analysis.difficultyColor;

    header.createEl("span", {
      text: ` ~${result.analysis.roundsToDefeatEnemies} round${result.analysis.roundsToDefeatEnemies !== 1 ? 's' : ''}`,
      cls: "dnd-rounds-estimate"
    });

    const statsGrid = difficultyCard.createDiv({ cls: "dnd-difficulty-stats-grid" });

    const partyCol = statsGrid.createDiv({ cls: "dnd-stats-column" });
    partyCol.createEl("h5", { text: `‚öîÔ∏è Party (${result.partyStats.memberCount})` });
    const partyStats = partyCol.createDiv();
    partyStats.innerHTML = `
      <div>HP Pool: <strong>${result.partyStats.totalHP}</strong></div>
      <div>Avg AC: <strong>${result.partyStats.avgAC.toFixed(0)}</strong></div>
      <div>Total DPR: <strong>${result.partyStats.totalDPR.toFixed(0)}</strong></div>
      <div>Hit Chance: <strong>${(result.analysis.partyHitChance * 100).toFixed(0)}%</strong></div>
      <div>Effective DPR: <strong>${result.analysis.partyEffectiveDPR.toFixed(0)}</strong></div>
    `;

    const enemyCol = statsGrid.createDiv({ cls: "dnd-stats-column" });
    enemyCol.createEl("h5", { text: `üëπ Enemies (${result.enemyStats.creatureCount})` });
    const enemyStats = enemyCol.createDiv();
    enemyStats.innerHTML = `
      <div>HP Pool: <strong>${result.enemyStats.totalHP}</strong></div>
      <div>Avg AC: <strong>${result.enemyStats.avgAC.toFixed(0)}</strong></div>
      <div>Total DPR: <strong>${result.enemyStats.totalDPR.toFixed(0)}</strong></div>
      <div>Hit Chance: <strong>${(result.analysis.enemyHitChance * 100).toFixed(0)}%</strong></div>
      <div>Effective DPR: <strong>${result.analysis.enemyEffectiveDPR.toFixed(0)}</strong></div>
    `;

    const analysisSummary = difficultyCard.createDiv({ cls: "dnd-difficulty-analysis" });

    const partyDamage3Rounds = result.analysis.partyEffectiveDPR * 3;
    const enemyDamage3Rounds = result.analysis.enemyEffectiveDPR * 3;
    const partyHPAfter3 = Math.max(0, result.partyStats.totalHP - enemyDamage3Rounds);
    const enemyHPAfter3 = Math.max(0, result.enemyStats.totalHP - partyDamage3Rounds);

    // Action economy display
    const partyAEMod = result.analysis.partyActionEconomyMod || 1.0;
    const enemyAEMod = result.analysis.enemyActionEconomyMod || 1.0;
    const actionEconomyInfo = partyAEMod !== 1.0 || enemyAEMod !== 1.0
      ? `<div style="margin-bottom: 8px; padding: 8px; background: var(--background-modifier-border); border-radius: 4px;">
          <strong>‚öñÔ∏è Action Economy:</strong> 
          Party ${partyAEMod > 1 ? '‚úì' : partyAEMod < 1 ? '‚úó' : '='} 
          ${(partyAEMod * 100).toFixed(0)}% efficiency | 
          Enemies ${enemyAEMod > 1 ? '‚úì' : enemyAEMod < 1 ? '‚úó' : '='} 
          ${(enemyAEMod * 100).toFixed(0)}% efficiency
        </div>`
      : '';

    analysisSummary.innerHTML = `
      ${actionEconomyInfo}
      <div style="margin-bottom: 8px;"><strong>üìä 3-Round Analysis:</strong></div>
      <div>Party deals: <strong>${partyDamage3Rounds.toFixed(0)}</strong> damage ‚Üí Enemies at <strong>${enemyHPAfter3.toFixed(0)}</strong> HP (${((enemyHPAfter3 / result.enemyStats.totalHP) * 100).toFixed(0)}%)</div>
      <div>Enemies deal: <strong>${enemyDamage3Rounds.toFixed(0)}</strong> damage ‚Üí Party at <strong>${partyHPAfter3.toFixed(0)}</strong> HP (${((partyHPAfter3 / result.partyStats.totalHP) * 100).toFixed(0)}%)</div>
      <div style="margin-top: 8px; opacity: 0.8;">
        Survival Ratio: ${result.analysis.survivalRatio.toFixed(2)}
        (Party can survive ${result.analysis.roundsToDefeatParty} rounds, enemies survive ${result.analysis.roundsToDefeatEnemies} rounds)
      </div>
    `;

    const partyMembers = await this.getPartyForDifficulty();
    if (result.partyStats.memberCount === 0 || partyMembers.length === 0) {
      const warningEl = difficultyCard.createDiv({ cls: "dnd-difficulty-warning" });
      warningEl.innerHTML = `‚ö†Ô∏è <strong>No party registered!</strong> Using default estimates for 4 Level-3 PCs.
        <br>Register PCs via "Create PC" to get accurate calculations.`;
    }
  }

  /**
   * Parse statblock YAML to extract real combat stats
   * Returns hp, ac, dpr (damage per round), and attackBonus
   */
  async parseStatblockStats(filePath: string): Promise<{ hp: number; ac: number; dpr: number; attackBonus: number } | null> {
    try {
      console.log(`[Parser] Reading file: ${filePath}`);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof TFile)) {
        console.log(`[Parser] File not found or not a TFile`);
        return null;
      }

      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache?.frontmatter) {
        console.log(`[Parser] No frontmatter found`);
        return null;
      }

      const fm = cache.frontmatter;
      console.log(`[Parser] Frontmatter keys:`, Object.keys(fm));
      
      // Extract basic stats
      const hp = this.parseHP(fm.hp);
      const ac = this.parseAC(fm.ac);
      console.log(`[Parser] Parsed HP: ${hp}, AC: ${ac}`);
      
      // Calculate DPR and attack bonus from actions
      let totalDPR = 0;
      let highestAttackBonus = 0;
      let attackCount = 0;
      
      // Check for actions array (where attacks are defined)
      if (fm.actions && Array.isArray(fm.actions)) {
        console.log(`[Parser] Found ${fm.actions.length} actions`);
        
        for (const action of fm.actions) {
          if (!action.name) continue;
          console.log(`[Parser] Action: "${action.name}"`);
          
          // === CHECK STRUCTURED FIELDS FIRST ===
          // Many statblocks (especially from Fantasy Statblocks plugin) have structured data
          let actionDPR = 0;
          let actionAttackBonus = 0;
          let usedStructuredData = false;
          
          // Check for attack_bonus field
          if (typeof action.attack_bonus === 'number') {
            actionAttackBonus = action.attack_bonus;
            if (actionAttackBonus > highestAttackBonus) {
              highestAttackBonus = actionAttackBonus;
            }
            console.log(`[Parser] Found structured attack_bonus: ${actionAttackBonus}`);
            usedStructuredData = true;
          }
          
          // Check for damage_dice and damage_bonus fields
          if (action.damage_dice || action.damage_bonus) {
            console.log(`[Parser] Found structured damage fields: dice="${action.damage_dice}", bonus="${action.damage_bonus}"`);
            
            // Parse damage_dice (e.g., "1d6" or "2d8")
            let diceDamage = 0;
            if (action.damage_dice && typeof action.damage_dice === 'string') {
              const diceMatch = action.damage_dice.match(/(\d+)d(\d+)/i);
              if (diceMatch) {
                const numDice = parseInt(diceMatch[1]);
                const dieSize = parseInt(diceMatch[2]);
                diceDamage = numDice * ((dieSize + 1) / 2); // Average of dice
                console.log(`[Parser] Calculated dice damage: ${numDice}d${dieSize} = ${diceDamage}`);
              }
            }
            
            // Add damage bonus
            let damageBonus = 0;
            if (typeof action.damage_bonus === 'number') {
              damageBonus = action.damage_bonus;
            } else if (typeof action.damage_bonus === 'string') {
              damageBonus = parseInt(action.damage_bonus) || 0;
            }
            
            actionDPR = diceDamage + damageBonus;
            console.log(`[Parser] Calculated structured damage: ${diceDamage} + ${damageBonus} = ${actionDPR}`);
            
            if (actionDPR > 0) {
              totalDPR += actionDPR;
              attackCount++;
              usedStructuredData = true;
            }
          }
          
          // If we successfully used structured data, skip text parsing for this action
          if (usedStructuredData) {
            console.log(`[Parser] Used structured data for ${action.name}, DPR=${actionDPR}, Attack=${actionAttackBonus}`);
            continue;
          }
          
          // === FALLBACK TO TEXT PARSING ===
          // Parse attack actions from description text
          if (action.desc && typeof action.desc === 'string') {
            const desc = action.desc;
            console.log(`[Parser] Description: ${desc.substring(0, 100)}...`);
            
            // Look for attack bonus: "+5 to hit" or "attack: +5"
            const attackMatch = desc.match(/[+\-]\d+\s+to\s+hit/i);
            if (attackMatch) {
              const bonusMatch = attackMatch[0].match(/[+\-]\d+/);
              if (bonusMatch) {
                attackCount++; // Increment attack count
                const bonus = parseInt(bonusMatch[0]);
                console.log(`[Parser] Found attack bonus: ${bonus}`);
                if (bonus > highestAttackBonus) highestAttackBonus = bonus;
              }
            }
            
            // Look for damage in various formats
            // Format 1: "4 (1d6 + 1)" - average shown first
            // Format 2: "(1d6+1)" - just dice
            // Format 3: "1d6+1" or "2d6 + 3"
            const damagePatterns = [
              /(\d+)\s*\((\d+)d(\d+)\s*([+\-]?\s*\d+)?\)/gi,  // "4 (1d6+1)"
              /\((\d+)d(\d+)\s*([+\-]?\s*\d+)?\)/gi,           // "(1d6+1)"
              /(\d+)d(\d+)\s*([+\-]?\s*\d+)?(?!\))/gi          // "1d6+1"
            ];
            
            let damageFound = false;
            
            // Try format 1 first (with pre-calculated average)
            const avgDamageMatch = desc.match(/(\d+)\s*\((\d+)d(\d+)\s*([+\-]?\s*\d+)?\)/i);
            if (avgDamageMatch) {
              const avgDamage = parseInt(avgDamageMatch[1]);
              console.log(`[Parser] Found pre-calculated damage: ${avgDamage}`);
              totalDPR += avgDamage;
              damageFound = true;
              if (!attackMatch) attackCount++; // Count this as an attack if we haven't already
            } else {
              // Try parsing dice notation
              const diceMatch = desc.match(/(\d+)d(\d+)\s*([+\-]?\s*\d+)?/i);
              if (diceMatch) {
                if (!attackMatch) attackCount++; // Count this as an attack if we haven't already
                const numDice = parseInt(diceMatch[1]);
                const dieSize = parseInt(diceMatch[2]);
                const modifier = diceMatch[3] ? parseInt(diceMatch[3].replace(/\s/g, '')) : 0;
                const avgDamage = Math.floor(numDice * (dieSize + 1) / 2) + modifier;
                console.log(`[Parser] Calculated damage from ${diceMatch[0]}: ${avgDamage}`);
                totalDPR += avgDamage;
                damageFound = true;
              }
            }
            
            if (!damageFound) {
              console.log(`[Parser] No damage found in action`);
            }
          }
        }
      } else {
        console.log(`[Parser] No actions array found`);
      }
      
      console.log(`[Parser] Total DPR before multiattack: ${totalDPR}`);
      
      // Check for multiattack
      let multiattackMultiplier = 1;
      if (fm.actions && Array.isArray(fm.actions)) {
        const multiattack = fm.actions.find((a: any) => 
          a.name && a.name.toLowerCase().includes('multiattack')
        );
        
        if (multiattack?.desc) {
          console.log(`[Parser] Multiattack found: ${multiattack.desc}`);
          // Look for "makes two attacks" or "makes three weapon attacks"
          const countMatch = multiattack.desc.match(/makes?\s+(two|three|four|five|\d+)\s+.*?attack/i);
          if (countMatch) {
            const countStr = countMatch[1].toLowerCase();
            const countMap: Record<string, number> = { 'two': 2, 'three': 3, 'four': 4, 'five': 5 };
            multiattackMultiplier = countMap[countStr] || parseInt(countStr) || 1;
            console.log(`[Parser] Multiattack multiplier: ${multiattackMultiplier}`);
          }
        }
      }
      
      // Apply multiattack multiplier if we found actual attack damage
      // Note: We don't strictly require attackCount > 0 because some statblocks 
      // might have damage without explicit "to hit" text
      if (totalDPR > 0 && multiattackMultiplier > 1) {
        console.log(`[Parser] Applying multiattack multiplier ${multiattackMultiplier} to DPR ${totalDPR}`);
        totalDPR *= multiattackMultiplier;
        console.log(`[Parser] Final DPR after multiattack: ${totalDPR}`);
      }
      
      // If we couldn't parse DPR, return null to fall back to CR estimates
      // We allow attack bonus to be 0 as it's less critical than DPR
      if (totalDPR === 0) {
        console.log(`[Parser] No DPR found, returning null to use CR estimates`);
        return null;
      }
      
      // Use a reasonable default attack bonus if we couldn't parse it
      if (highestAttackBonus === 0) {
        // Estimate based on DPR (higher DPR usually means higher attack bonus)
        highestAttackBonus = Math.max(2, Math.floor(totalDPR / 5));
        console.log(`[Parser] No attack bonus found, estimating ${highestAttackBonus} based on DPR`);
      }
      
      const result = {
        hp: hp || 1,
        ac: ac || 10,
        dpr: totalDPR,
        attackBonus: highestAttackBonus
      };
      console.log(`[Parser] SUCCESS: Returning`, result);
      return result;
    } catch (error) {
      console.error("[Parser] Error parsing statblock:", filePath, error);
      return null;
    }
  }

  /**
   * Parse HP from various formats: "45 (6d10+12)" or just "45"
   */
  parseHP(hpStr: any): number {
    if (typeof hpStr === 'number') return hpStr;
    if (typeof hpStr !== 'string') return 0;
    
    // Try to extract number before parentheses: "45 (6d10+12)"
    const match = hpStr.match(/^(\d+)/);
    return match && match[1] ? parseInt(match[1]) : 0;
  }

  /**
   * Parse AC from various formats: "13 (natural armor)" or just "13" or number
   */
  parseAC(acStr: any): number {
    if (typeof acStr === 'number') return acStr;
    if (typeof acStr !== 'string') return 10;
    
    // Try to extract number: "13 (natural armor)" or "13"
    const match = acStr.match(/^(\d+)/);
    return match && match[1] ? parseInt(match[1]) : 10;
  }

  /**
   * Consolidate trap elements (creatures with [SRD] path and initiative numbers)
   * into single trap entities with trapData loaded from trap files
   */
  async consolidateTrapElements(): Promise<void> {
    const trapGroups = new Map<string, any[]>();
    const nonTraps: any[] = [];
    
    // Group creatures by trap name (before the "Initiative" part)
    for (const creature of this.creatures) {
      // Check if this looks like a trap element: has [SRD] path and name with "Initiative"
      if (creature.path === "[SRD]" && creature.name.includes("(Initiative")) {
        const baseName = creature.name.replace(/\s*\(Initiative\s+\d+\)/, '').trim();
        if (!trapGroups.has(baseName)) {
          trapGroups.set(baseName, []);
        }
        trapGroups.get(baseName)!.push(creature);
      } else if (!creature.isTrap) {
        // Keep non-trap creatures as-is
        nonTraps.push(creature);
      } else {
        // Already a proper trap with trapData
        nonTraps.push(creature);
      }
    }
    
    // Find and load trap files for each trap group
    const consolidatedTraps: any[] = [];
    for (const [trapName, elements] of trapGroups.entries()) {
      console.log(`ü™§ Consolidating trap: ${trapName} (${elements.length} elements)`);
      
      // Search for the trap file
      let trapFile: TFile | null = null;
      for (const file of this.app.vault.getMarkdownFiles()) {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache?.frontmatter?.type === 'trap' && 
            (cache.frontmatter.trap_name === trapName || file.basename === trapName)) {
          trapFile = file;
          break;
        }
      }
      
      if (trapFile) {
        try {
          const trapCache = this.app.metadataCache.getFileCache(trapFile);
          if (trapCache?.frontmatter) {
            const fm = trapCache.frontmatter;
            const consolidatedTrap = {
              name: trapName,
              count: 1,
              isTrap: true,
              trapData: {
                trapType: fm.trap_type || "complex",
                threatLevel: fm.threat_level || "dangerous",
                elements: fm.elements || []
              },
              // Preserve manual overrides from first element if any
              hp: elements[0].hp,
              ac: elements[0].ac,
              cr: elements[0].cr,
              path: trapFile.path
            };
            consolidatedTraps.push(consolidatedTrap);
            console.log(`‚úÖ Consolidated ${trapName} from ${elements.length} elements`);
          }
        } catch (error) {
          console.error(`Error loading trap file for ${trapName}:`, error);
          // If we can't load the trap, keep the elements as regular creatures
          nonTraps.push(...elements);
        }
      } else {
        console.warn(`‚ö†Ô∏è No trap file found for ${trapName}, keeping as separate creatures`);
        nonTraps.push(...elements);
      }
    }
    
    // Replace creatures array with consolidated version
    this.creatures = [...nonTraps, ...consolidatedTraps];
    console.log(`üìä Consolidated ${trapGroups.size} traps, ${nonTraps.length} other creatures`);
  }

  async calculateEncounterDifficulty(): Promise<any> {
    // First, consolidate any trap elements
    await this.consolidateTrapElements();
    
    // Calculate enemy stats with real statblock data when available
    let enemyTotalHP = 0;
    let enemyTotalAC = 0;
    let enemyTotalDPR = 0;
    let enemyTotalAttackBonus = 0;
    let enemyCount = 0;
    
    // Track friendly creatures to add to party
    let friendlyTotalHP = 0;
    let friendlyTotalAC = 0;
    let friendlyTotalDPR = 0;
    let friendlyTotalAttackBonus = 0;
    let friendlyCount = 0;
    
    console.log("=== ENCOUNTER DIFFICULTY CALCULATION ===");
    
    for (const creature of this.creatures) {
      const count = creature.count || 1;
      
      console.log(`\n--- Creature: ${creature.name} (x${count}) ---`);
      console.log(`Path: ${creature.path || 'none'}`);
      console.log(`CR: ${creature.cr || 'unknown'}`);
      console.log(`Is Trap: ${creature.isTrap || false}`);
      console.log(`Is Friendly: ${creature.isFriendly || false}`);
      
      // Handle friendly creatures - add them to the party side
      if (creature.isFriendly) {
        console.log(`ü§ù FRIENDLY CREATURE - Adding to party stats`);
        
        // Get stats for friendly creature (same logic as enemies)
        let realStats = null;
        if (creature.path && typeof creature.path === 'string') {
          console.log(`Attempting to parse statblock: ${creature.path}`);
          realStats = await this.parseStatblockStats(creature.path);
          console.log(`Parsed stats:`, realStats);
        }
        
        const crStats = this.getCRStats(creature.cr);
        const hp = creature.hp || realStats?.hp || crStats.hp;
        const ac = creature.ac || realStats?.ac || crStats.ac;
        const dpr = realStats?.dpr || crStats.dpr;
        const attackBonus = realStats?.attackBonus || crStats.attackBonus;
        
        console.log(`Friendly stats: HP=${hp}, AC=${ac}, DPR=${dpr}, Attack=${attackBonus}`);
        console.log(`Total contribution (x${count}): HP=${hp * count}, DPR=${dpr * count}`);
        
        friendlyTotalHP += hp * count;
        friendlyTotalAC += ac * count;
        friendlyTotalDPR += dpr * count;
        friendlyTotalAttackBonus += attackBonus * count;
        friendlyCount += count;
        continue;
      }
      
      // Handle traps differently from creatures
      if (creature.isTrap && creature.trapData) {
        console.log(`ü™§ TRAP DETECTED - Using trap-specific calculation`);
        const trapStats = await this.plugin.encounterBuilder.calculateTrapStats(creature.trapData);
        console.log(`Trap stats:`, trapStats);
        
        const hp = trapStats.hp;
        const ac = trapStats.ac;
        const dpr = trapStats.dpr;
        const attackBonus = trapStats.attackBonus;
        
        console.log(`Final trap stats: HP=${hp}, AC=${ac}, DPR=${dpr}, Attack=${attackBonus}, Effective CR=${trapStats.cr}`);
        console.log(`Total contribution (x${count}): HP=0 (traps don't contribute to HP pool), DPR=${dpr * count}`);
        
        // Traps don't add to HP pool (they're hazards, not damage sponges)
        // But they DO contribute DPR, AC (for difficulty calculation), and count as threats
        enemyTotalAC += ac * count;
        enemyTotalDPR += dpr * count;
        enemyTotalAttackBonus += attackBonus * count;
        enemyCount += count;
        continue;
      }
      
      // Try to get real stats from statblock if available
      let realStats = null;
      if (creature.path && typeof creature.path === 'string') {
        console.log(`Attempting to parse statblock: ${creature.path}`);
        realStats = await this.parseStatblockStats(creature.path);
        console.log(`Parsed stats:`, realStats);
      } else {
        console.log(`No valid path, using CR estimates`);
      }
      
      // Fall back to CR-based estimates if no statblock or parsing failed
      const crStats = this.getCRStats(creature.cr);
      console.log(`CR-based fallback stats:`, crStats);
      
      const hp = creature.hp || realStats?.hp || crStats.hp;
      const ac = creature.ac || realStats?.ac || crStats.ac;
      const dpr = realStats?.dpr || crStats.dpr;
      const attackBonus = realStats?.attackBonus || crStats.attackBonus;
      
      const dprSource = realStats?.dpr ? 'üìä STATBLOCK' : 'üìñ CR_TABLE';
      const hpSource = realStats?.hp ? 'üìä STATBLOCK' : creature.hp ? '‚úèÔ∏è MANUAL' : 'üìñ CR_TABLE';
      const acSource = realStats?.ac ? 'üìä STATBLOCK' : creature.ac ? '‚úèÔ∏è MANUAL' : 'üìñ CR_TABLE';
      
      console.log(`Final stats used: HP=${hp} (${hpSource}), AC=${ac} (${acSource}), DPR=${dpr} (${dprSource}), Attack=${attackBonus}`);
      console.log(`Total contribution (x${count}): HP=${hp * count}, DPR=${dpr * count}`);
      
      enemyTotalHP += hp * count;
      enemyTotalAC += ac * count;
      enemyTotalDPR += dpr * count;
      enemyTotalAttackBonus += attackBonus * count;
      enemyCount += count;
    }
    
    console.log(`\n=== TOTALS ===`);
    console.log(`Total Enemies: ${enemyCount}`);
    console.log(`Total Enemy HP: ${enemyTotalHP}`);
    console.log(`Total Enemy DPR: ${enemyTotalDPR}`);
    console.log(`Average Enemy AC: ${enemyCount > 0 ? (enemyTotalAC / enemyCount).toFixed(1) : 0}`);
    console.log(`Average Enemy Attack Bonus: ${enemyCount > 0 ? (enemyTotalAttackBonus / enemyCount).toFixed(1) : 0}`);
    
    const avgEnemyAC = enemyCount > 0 ? enemyTotalAC / enemyCount : 13;
    const avgEnemyAttackBonus = enemyCount > 0 ? enemyTotalAttackBonus / enemyCount : 3;
    
    // Get party stats
    const partyMembers = await this.getPartyForDifficulty();
    
    let partyTotalHP = 0;
    let partyTotalAC = 0;
    let partyTotalDPR = 0;
    let partyTotalAttackBonus = 0;
    let totalLevel = 0;
    
    for (const member of partyMembers) {
      const levelStats = this.getLevelStats(member.level);
      
      const memberHP = Number(member.hp) || 0;
      const memberAC = Number(member.ac) || 0;
      
      partyTotalHP += memberHP > 0 ? memberHP : levelStats.hp;
      partyTotalAC += memberAC > 0 ? memberAC : levelStats.ac;
      partyTotalDPR += levelStats.dpr;
      partyTotalAttackBonus += levelStats.attackBonus;
      totalLevel += member.level;
    }
    
    // Add friendly creatures to party totals
    console.log(`\n=== ADDING FRIENDLY CREATURES TO PARTY ===`);
    console.log(`Friendly creatures: ${friendlyCount}`);
    console.log(`Friendly HP contribution: ${friendlyTotalHP}`);
    console.log(`Friendly DPR contribution: ${friendlyTotalDPR}`);
    
    partyTotalHP += friendlyTotalHP;
    partyTotalAC += friendlyTotalAC;
    partyTotalDPR += friendlyTotalDPR;
    partyTotalAttackBonus += friendlyTotalAttackBonus;
    
    const memberCount = partyMembers.length + friendlyCount;
    const pcMemberCount = partyMembers.length;
    
    let avgPartyAC: number;
    let avgPartyAttackBonus: number;
    let avgLevel: number;
    let effectivePartyCount: number; // Track effective count for action economy
    
    if (memberCount > 0) {
      avgPartyAC = partyTotalAC / memberCount;
      avgPartyAttackBonus = partyTotalAttackBonus / memberCount;
      avgLevel = pcMemberCount > 0 ? totalLevel / pcMemberCount : 3;
      effectivePartyCount = memberCount;
    } else {
      const defaultStats = this.getLevelStats(3);
      partyTotalHP = defaultStats.hp * 4;
      partyTotalDPR = defaultStats.dpr * 4;
      avgPartyAC = defaultStats.ac;
      avgPartyAttackBonus = defaultStats.attackBonus;
      avgLevel = 3;
      effectivePartyCount = 4; // Default to 4-person party
    }
    
    // Calculate hit chances
    const partyHitChance = this.calculateHitChance(avgPartyAttackBonus, avgEnemyAC);
    const enemyHitChance = this.calculateHitChance(avgEnemyAttackBonus, avgPartyAC);
    
    // === ACTION ECONOMY ADJUSTMENT ===
    // In D&D 5e, action economy affects combat through:
    // 1. Focus Fire: More creatures can eliminate threats faster
    // 2. Action Efficiency: Fewer creatures waste actions on downed targets
    // 3. Target Distribution: Very few creatures can't threaten all enemies
    
    const partyActionCount = effectivePartyCount;
    const enemyActionCount = enemyCount;
    
    // Calculate action economy modifiers based on creature count disparity
    let partyActionEconomyMod = 1.0;
    let enemyActionEconomyMod = 1.0;
    
    if (partyActionCount > 0 && enemyActionCount > 0) {
      const actionRatio = partyActionCount / enemyActionCount;
      
      if (actionRatio > 2.0) {
        // Extreme party advantage: 6+ PCs vs 1-2 enemies
        // Party can focus fire and chain eliminate threats
        partyActionEconomyMod = 1.0 + Math.min((actionRatio - 1) * 0.1, 0.25); // Up to +25%
        // Very few enemies spread damage thin, but still somewhat effective
        enemyActionEconomyMod = Math.max(0.85, 1.0 - (actionRatio - 2) * 0.05); // Down to 85%
      } else if (actionRatio < 0.5) {
        // Extreme enemy advantage: outnumbered 2:1 or worse
        // Party spread too thin, can't focus effectively
        const inverseRatio = enemyActionCount / partyActionCount;
        partyActionEconomyMod = Math.max(0.85, 1.0 - (inverseRatio - 2) * 0.05); // Down to 85%
        enemyActionEconomyMod = 1.0 + Math.min((inverseRatio - 1) * 0.1, 0.25); // Up to +25%
      }
      // Between 0.5-2.0 ratio: relatively balanced, minimal adjustment
    }
    
    // Calculate effective DPR with action economy adjustments
    const partyBaseDPR = this.calculateEffectiveDPR(partyTotalDPR, partyHitChance);
    const enemyBaseDPR = this.calculateEffectiveDPR(enemyTotalDPR, enemyHitChance);
    
    const partyEffectiveDPR = partyBaseDPR * partyActionEconomyMod;
    const enemyEffectiveDPR = enemyBaseDPR * enemyActionEconomyMod;
    
    // Calculate rounds to defeat
    const roundsToDefeatEnemies = this.calculateRoundsToDefeat(enemyTotalHP, partyEffectiveDPR);
    const roundsToDefeatParty = this.calculateRoundsToDefeat(partyTotalHP, enemyEffectiveDPR);
    
    // Survival ratio
    const survivalRatio = roundsToDefeatParty / roundsToDefeatEnemies;
    
    // Determine difficulty
    let difficulty: string;
    let difficultyColor: string;
    
    if (survivalRatio >= 4 || roundsToDefeatEnemies <= 1) {
      difficulty = "Trivial";
      difficultyColor = "#888888";
    } else if (survivalRatio >= 2.5) {
      difficulty = "Easy";
      difficultyColor = "#00aa00";
    } else if (survivalRatio >= 1.5) {
      difficulty = "Medium";
      difficultyColor = "#aaaa00";
    } else if (survivalRatio >= 1.0) {
      difficulty = "Hard";
      difficultyColor = "#ff8800";
    } else if (survivalRatio >= 0.6) {
      difficulty = "Deadly";
      difficultyColor = "#ff0000";
    } else {
      difficulty = "TPK Risk";
      difficultyColor = "#880000";
    }
    
    // Generate summary
    let summary = "";
    if (partyMembers.length === 0 && friendlyCount === 0) {
      summary = `‚ö†Ô∏è No party found. Using default 4-player party (Level 3).\\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}.`;
    } else {
      const partyText = pcMemberCount > 0 ? `${pcMemberCount} PC${pcMemberCount !== 1 ? 's' : ''}` : '';
      const friendlyText = friendlyCount > 0 ? `${friendlyCount} friendly creature${friendlyCount !== 1 ? 's' : ''}` : '';
      const combatants = [partyText, friendlyText].filter(t => t).join(' + ');
      
      summary = `Party: ${combatants}`;
      if (pcMemberCount > 0) {
        summary += ` (Avg Level ${avgLevel.toFixed(1)})`;
      }
      summary += `\\n`;
      summary += `Enemies: ${enemyCount} creatures\\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}`;
    }
    
    return {
      enemyStats: {
        totalHP: enemyTotalHP,
        avgAC: avgEnemyAC,
        totalDPR: enemyTotalDPR,
        avgAttackBonus: avgEnemyAttackBonus,
        creatureCount: enemyCount
      },
      partyStats: {
        totalHP: partyTotalHP,
        avgAC: avgPartyAC,
        totalDPR: partyTotalDPR,
        avgAttackBonus: avgPartyAttackBonus,
        memberCount: memberCount,
        avgLevel: avgLevel
      },
      analysis: {
        partyHitChance,
        enemyHitChance,
        partyEffectiveDPR,
        enemyEffectiveDPR,
        partyActionEconomyMod,
        enemyActionEconomyMod,
        roundsToDefeatEnemies,
        roundsToDefeatParty,
        survivalRatio,
        difficulty,
        difficultyColor,
        summary
      }
    };
  }

  generateUniqueId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // Helper methods (copied from SceneCreationModal)
  getCRStats(cr: string | undefined): { hp: number; ac: number; dpr: number; attackBonus: number; xp: number } {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getCRStats(cr);
  }

  getLevelStats(level: number): { hp: number; ac: number; dpr: number; attackBonus: number } {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getLevelStats(level);
  }

  async getPartyForDifficulty(): Promise<Array<{ level: number; hp?: number; ac?: number }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getPartyForDifficulty();
  }

  calculateHitChance(attackBonus: number, targetAC: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateHitChance(attackBonus, targetAC);
  }

  calculateEffectiveDPR(baseDPR: number, hitChance: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateEffectiveDPR(baseDPR, hitChance);
  }

  calculateRoundsToDefeat(totalHP: number, effectiveDPR: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateRoundsToDefeat(totalHP, effectiveDPR);
  }

  async saveEncounter() {
    if (!this.encounterName.trim()) {
      new Notice("Please enter an encounter name");
      return;
    }

    if (this.creatures.length === 0) {
      new Notice("Please add at least one creature");
      return;
    }

    try {
      // Determine encounter folder path
      let encounterFolder = "z_Encounters";
      
      // Check if we're in a campaign context
      const activeCampaignFile = this.app.workspace.getActiveFile();
      if (activeCampaignFile) {
        const campaignFolder = this.findCampaignFolder(activeCampaignFile.path);
        if (campaignFolder) {
          encounterFolder = `${campaignFolder}/z_Encounters`;
          this.campaignPath = campaignFolder;
        }
      }

      // Create folder if it doesn't exist
      const folderExists = this.app.vault.getAbstractFileByPath(encounterFolder);
      if (!folderExists) {
        await this.app.vault.createFolder(encounterFolder);
      }

      // Generate encounter file content
      this.syncEncounterBuilder();
      const diffResult = await this.encounterBuilder.calculateEncounterDifficulty();
      const encounterContent = await this.generateEncounterContent(diffResult);

      // Save or update encounter file
      const fileName = `${this.encounterName}.md`;
      const encounterPath = `${encounterFolder}/${fileName}`;

      if (this.isEdit && this.originalEncounterPath !== encounterPath) {
        // If name changed, delete old file and create new one
        const oldFile = this.app.vault.getAbstractFileByPath(this.originalEncounterPath);
        if (oldFile instanceof TFile) {
          await this.app.vault.delete(oldFile);
        }
      }

      const existingFile = this.app.vault.getAbstractFileByPath(encounterPath);
      let fileToOpen: TFile;
      if (existingFile instanceof TFile) {
        await this.app.vault.modify(existingFile, encounterContent);
        new Notice(`Encounter "${this.encounterName}" updated!`);
        fileToOpen = existingFile;
      } else {
        const newFile = await this.app.vault.create(encounterPath, encounterContent);
        new Notice(`Encounter "${this.encounterName}" created!`);
        fileToOpen = newFile;
      }

      // Save to Initiative Tracker
      await this.saveToInitiativeTracker(encounterPath);

      this.close();
      
      // Open the encounter note
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(fileToOpen);
    } catch (error) {
      console.error("Error saving encounter:", error);
      new Notice("Error saving encounter");
    }
  }

  findCampaignFolder(filePath: string): string | null {
    // Look for campaign folder in path (folders containing "ttrpgs" subdirectory)
    const parts = filePath.split('/');
    for (let i = parts.length - 1; i >= 0; i--) {
      const potentialCampaign = parts.slice(0, i + 1).join('/');
      const ttrpgPath = `${potentialCampaign}/ttrpgs`;
      if (this.app.vault.getAbstractFileByPath(ttrpgPath)) {
        return potentialCampaign;
      }
    }
    return null;
  }

  escapeYamlString(str: string): string {
    if (!str) return '""';
    // Use single quotes for YAML strings - only need to escape single quotes within
    // Single quotes are safer as they don't interpret escape sequences
    if (str.includes("'")) {
      // If string contains single quotes, double them (YAML escaping for single quotes)
      return "'" + str.replace(/'/g, "''") + "'";
    }
    // If no single quotes, just wrap in single quotes
    return "'" + str + "'";
  }

  async generateEncounterContent(diffResult: any): Promise<string> {
    const currentDate = window.moment().format("YYYY-MM-DD");

    let frontmatter = `---
type: encounter
name: ${this.escapeYamlString(this.encounterName)}
creatures:`;

    for (const creature of this.creatures) {
      frontmatter += `\n  - name: ${this.escapeYamlString(creature.name)}
    count: ${creature.count}`;
      if (creature.hp) frontmatter += `\n    hp: ${creature.hp}`;
      if (creature.ac) frontmatter += `\n    ac: ${creature.ac}`;
      if (creature.cr) frontmatter += `\n    cr: ${this.escapeYamlString(creature.cr)}`;
      if (creature.source) frontmatter += `\n    source: ${this.escapeYamlString(creature.source)}`;
      if (creature.path) frontmatter += `\n    path: ${this.escapeYamlString(creature.path)}`;
      if (creature.isFriendly) frontmatter += `\n    is_friendly: ${creature.isFriendly}`;
      if (creature.isHidden) frontmatter += `\n    is_hidden: ${creature.isHidden}`;
    }

    frontmatter += `
include_party: ${this.includeParty}
use_color_names: ${this.useColorNames}`;

  if (this.selectedPartyId) frontmatter += `\nselected_party_id: ${this.escapeYamlString(this.selectedPartyId)}`;
  if (this.selectedPartyName) frontmatter += `\nselected_party_name: ${this.escapeYamlString(this.selectedPartyName)}`;

    if (this.adventurePath) frontmatter += `\nadventure_path: ${this.escapeYamlString(this.adventurePath)}`;
    if (this.scenePath) frontmatter += `\nscene_path: ${this.escapeYamlString(this.scenePath)}`;
    if (this.campaignPath) frontmatter += `\ncampaign_path: ${this.escapeYamlString(this.campaignPath)}`;

    frontmatter += `
difficulty:
  rating: ${this.escapeYamlString(diffResult.analysis.difficulty)}
  color: ${this.escapeYamlString(diffResult.analysis.difficultyColor)}
  party_count: ${diffResult.partyStats.memberCount}
  party_avg_level: ${diffResult.partyStats.avgLevel.toFixed(1)}
  party_total_hp: ${diffResult.partyStats.totalHP}
  party_avg_ac: ${diffResult.partyStats.avgAC.toFixed(1)}
  party_total_dpr: ${diffResult.partyStats.totalDPR.toFixed(1)}
  party_hit_chance: ${(diffResult.analysis.partyHitChance * 100).toFixed(0)}
  party_effective_dpr: ${diffResult.analysis.partyEffectiveDPR.toFixed(0)}
  enemy_count: ${diffResult.enemyStats.creatureCount}
  enemy_total_hp: ${diffResult.enemyStats.totalHP}
  enemy_avg_ac: ${diffResult.enemyStats.avgAC.toFixed(1)}
  enemy_total_dpr: ${diffResult.enemyStats.totalDPR.toFixed(1)}
  enemy_hit_chance: ${(diffResult.analysis.enemyHitChance * 100).toFixed(0)}
  enemy_effective_dpr: ${diffResult.analysis.enemyEffectiveDPR.toFixed(0)}
  rounds_to_defeat: ${diffResult.analysis.roundsToDefeatEnemies}
  rounds_party_survives: ${diffResult.analysis.roundsToDefeatParty}
  survival_ratio: ${diffResult.analysis.survivalRatio.toFixed(2)}
date: ${currentDate}
---`;

    const content = `${frontmatter}

# ${this.encounterName}

\`\`\`dataviewjs
// Create action buttons
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Open Initiative Tracker and load encounter button
const openTrackerBtn = buttonContainer.createEl("button", { 
  text: "‚öîÔ∏è Open & Load in Tracker",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px; background-color: var(--interactive-accent); color: var(--text-on-accent);" }
});
openTrackerBtn.addEventListener("click", async () => {
  const encounterName = dv.current().name;
  const initiativeTracker = app.plugins?.plugins?.["initiative-tracker"];
  
  if (!initiativeTracker) {
    new Notice("Initiative Tracker plugin not found");
    return;
  }
  
  const encounter = initiativeTracker.data?.encounters?.[encounterName];
  if (!encounter) {
    new Notice("Encounter \\"" + encounterName + "\\" not found. Try recreating it.");
    return;
  }
  
  // Use Initiative Tracker's internal tracker API to load the encounter
  try {
    if (initiativeTracker.tracker?.new) {
      initiativeTracker.tracker.new(initiativeTracker, encounter);
      new Notice("‚úÖ Loaded encounter: " + encounterName);
    } else {
      new Notice("‚ö†Ô∏è Could not load encounter. Try using Load Encounter from Initiative Tracker menu.");
    }
  } catch (e) {
    console.error("Error loading encounter:", e);
    new Notice("‚ö†Ô∏è Could not load encounter: " + e.message);
  }
  
  // Open Initiative Tracker view
  app.commands.executeCommandById("initiative-tracker:open-tracker");
});

// Edit button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-encounter");
});

// Delete button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-encounter");
});
\`\`\`

---

## Difficulty Analysis

\`\`\`dataviewjs
const diff = dv.current().difficulty;
if (!diff) {
  dv.paragraph("*No difficulty data available.*");
} else {
  // Create difficulty card
  const card = dv.el("div", "", { cls: "dnd-difficulty-card" });
  
  // Header with difficulty badge and rounds
  const header = dv.el("div", "", { cls: "dnd-difficulty-header", container: card });
  const badge = dv.el("span", diff.rating, { cls: "dnd-difficulty-badge", container: header });
  badge.style.backgroundColor = diff.color;
  dv.el("span", \` ~\${diff.rounds_to_defeat} round\${diff.rounds_to_defeat !== 1 ? 's' : ''}\`, { cls: "dnd-rounds-estimate", container: header });
  
  // Stats grid
  const grid = dv.el("div", "", { cls: "dnd-difficulty-stats-grid", container: card });
  
  // Party column
  const partyCol = dv.el("div", "", { cls: "dnd-stats-column", container: grid });
  dv.el("h5", \`‚öîÔ∏è Party (\${diff.party_count})\`, { container: partyCol });
  const partyStats = dv.el("div", "", { container: partyCol });
  partyStats.innerHTML = \`
    <div>HP Pool: <strong>\${diff.party_total_hp}</strong></div>
    <div>Avg AC: <strong>\${Math.round(diff.party_avg_ac)}</strong></div>
    <div>Total DPR: <strong>\${Math.round(diff.party_total_dpr)}</strong></div>
    <div>Hit Chance: <strong>\${diff.party_hit_chance}%</strong></div>
    <div>Effective DPR: <strong>\${diff.party_effective_dpr}</strong></div>
  \`;
  
  // Enemy column
  const enemyCol = dv.el("div", "", { cls: "dnd-stats-column", container: grid });
  dv.el("h5", \`üëπ Enemies (\${diff.enemy_count})\`, { container: enemyCol });
  const enemyStats = dv.el("div", "", { container: enemyCol });
  enemyStats.innerHTML = \`
    <div>HP Pool: <strong>\${diff.enemy_total_hp}</strong></div>
    <div>Avg AC: <strong>\${Math.round(diff.enemy_avg_ac)}</strong></div>
    <div>Total DPR: <strong>\${Math.round(diff.enemy_total_dpr)}</strong></div>
    <div>Hit Chance: <strong>\${diff.enemy_hit_chance}%</strong></div>
    <div>Effective DPR: <strong>\${diff.enemy_effective_dpr}</strong></div>
  \`;
  
  // 3-round analysis
  const analysis = dv.el("div", "", { cls: "dnd-difficulty-analysis", container: card });
  const partyDamage3 = diff.party_effective_dpr * 3;
  const enemyDamage3 = diff.enemy_effective_dpr * 3;
  const partyHPAfter3 = Math.max(0, diff.party_total_hp - enemyDamage3);
  const enemyHPAfter3 = Math.max(0, diff.enemy_total_hp - partyDamage3);
  const partyHPPercent = Math.round((partyHPAfter3 / diff.party_total_hp) * 100);
  const enemyHPPercent = Math.round((enemyHPAfter3 / diff.enemy_total_hp) * 100);
  
  analysis.innerHTML = \`
    <div style="margin-bottom: 8px;"><strong>üìä 3-Round Analysis:</strong></div>
    <div>Party deals: <strong>\${Math.round(partyDamage3)}</strong> damage ‚Üí Enemies at <strong>\${Math.round(enemyHPAfter3)}</strong> HP (\${enemyHPPercent}%)</div>
    <div>Enemies deal: <strong>\${Math.round(enemyDamage3)}</strong> damage ‚Üí Party at <strong>\${Math.round(partyHPAfter3)}</strong> HP (\${partyHPPercent}%)</div>
    <div style="margin-top: 8px; opacity: 0.8;">
      Survival Ratio: \${diff.survival_ratio}
      (Party can survive \${diff.rounds_party_survives} rounds, enemies survive \${diff.rounds_to_defeat} rounds)
    </div>
  \`;
}
\`\`\`

---

## Creatures

\`\`\`dataviewjs
const creatures = dv.current().creatures || [];

if (creatures.length === 0) {
  dv.paragraph("*No creatures in this encounter.*");
} else {
  const table = creatures.map(c => {
    return [
      c.name,
      c.count || 1,
      c.cr || "?",
      c.hp || "?",
      c.ac || "?"
    ];
  });
  
  dv.table(["Creature", "Count", "CR", "HP", "AC"], table);
}
\`\`\`

---

## GM Notes

_Add notes about tactics, environment, or special conditions here._
`;

    return content;
  }

  async saveToInitiativeTracker(encounterPath: string) {
    try {
      const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativeTracker) {
        console.log("Initiative Tracker plugin not found - skipping encounter save to tracker");
        new Notice("‚ö†Ô∏è Initiative Tracker not found. Encounter saved to vault only.");
        return;
      }

      // Build creature list for initiative tracker
      const creatures: any[] = [];

      // Add party members if requested
      if (this.includeParty && this.selectedPartyMembers.length > 0) {
        try {
          this.syncEncounterBuilder();
          const selectedPlayers = await this.encounterBuilder.getSelectedPartyPlayers();
          console.log("Adding party members to encounter:", selectedPlayers.length);
          console.log("‚ö†Ô∏è Note: Party member stats are loaded from Initiative Tracker. If stats seem outdated, refresh Initiative Tracker from the Character Notes plugin.");
          for (const player of selectedPlayers) {
            const hp = player.hp || player.currentMaxHP || 20;
            const ac = player.ac || player.currentAC || 14;
            creatures.push({
              name: player.name || "Player",
              display: "",
              initiative: 0,
              static: false,
              modifier: Math.floor(((player.level || 1) - 1) / 4) + 2,
              hp: hp,
              currentMaxHP: hp,
              currentHP: hp,
              tempHP: player.thp || 0,
              ac: ac,
              currentAC: ac,
              id: this.generateUniqueId(),
              status: [],
              enabled: true,
              active: false,
              hidden: false,
              friendly: false,  // Party members should NOT be marked as friendly
              player: true,
              rollHP: false
            });
          }
        } catch (error) {
          console.error("Error getting party members for Initiative Tracker:", error);
        }
      }

      // Helper function to generate unique IDs like Initiative Tracker does
      const generateId = () => {
        const chars = '0123456789abcdef';
        let id = 'ID_';
        for (let i = 0; i < 12; i++) {
          id += chars[Math.floor(Math.random() * chars.length)];
        }
        return id;
      };

      // Color names for duplicate creatures
      const colors = [
        "Red", "Blue", "Green", "Yellow", "Purple", "Orange", 
        "Pink", "Brown", "Black", "White", "Gray", "Cyan", 
        "Magenta", "Lime", "Teal", "Indigo", "Violet", "Gold", 
        "Silver", "Bronze"
      ];

      // Build creature data in Initiative Tracker format using flatMap
      const enemyCreatures = this.creatures.flatMap(c => {
        console.log(`Building creature: ${c.name}, HP: ${c.hp}, AC: ${c.ac}`);
        const instances = [];
        for (let i = 0; i < c.count; i++) {
          const hp = c.hp || 1;
          const ac = c.ac || 10;

          // Determine name and display based on useColorNames setting
          // IMPORTANT: 'name' is used for bestiary lookup and must be the base creature name
          // 'display' is used for visual representation in the tracker
          // Initiative Tracker will auto-number duplicate display names (Zombie -> Zombie 1, Zombie 2)
          let displayName = c.name;  // Always show at least the creature name

          if (c.count > 1 && this.useColorNames) {
            const colorIndex = i % colors.length;
            // Use display for color names
            displayName = `${c.name} (${colors[colorIndex]})`;
          }
          // For single creatures or multiple without colors, display is just the creature name
          // Initiative Tracker will add numbers automatically for duplicates

          const creature = {
            name: c.name,  // Base creature name for bestiary lookup
            display: displayName,  // Display name (always has a value now)
            initiative: 0,
            static: false,
            modifier: 0,  // Initiative modifier
            hp: hp,
            currentMaxHP: hp,  // Initiative Tracker uses currentMaxHP, not max
            cr: c.cr || undefined,
            ac: ac,  // AC as number
            currentAC: ac,  // Initiative Tracker also tracks currentAC
            id: generateId(),  // CRITICAL: Unique ID for each creature instance
            currentHP: hp,  // Initiative Tracker uses currentHP, not hp
            tempHP: 0,  // Initiative Tracker uses tempHP, not temp
            status: [],  // Array of status effects
            enabled: true,
            active: false,  // Whether this creature is currently active in turn order
            hidden: c.isHidden || false,  // Hidden from players
            friendly: c.isFriendly || false,  // Friendly to players
            rollHP: false  // Whether to roll HP when adding to tracker
          };
          console.log(`Created creature instance:`, creature);
          instances.push(creature);
        }
        return instances;
      });

      // Add enemy creatures to the main creatures array
      creatures.push(...enemyCreatures);

      console.log(`Saving encounter "${this.encounterName}" with ${creatures.length} creatures to Initiative Tracker`);
      console.log("Initiative Tracker data structure available:", !!initiativeTracker.data);
      console.log("Initiative Tracker saveSettings available:", !!initiativeTracker.saveSettings);

      // Save encounter to Initiative Tracker's data structure
      if (initiativeTracker.data) {
        // Initialize encounters object if it doesn't exist
        if (!initiativeTracker.data.encounters) {
          console.log("Initializing encounters object in Initiative Tracker data");
          initiativeTracker.data.encounters = {};
        }

        console.log("Current encounters in Initiative Tracker:", Object.keys(initiativeTracker.data.encounters));

        // Save encounter in Initiative Tracker format
        initiativeTracker.data.encounters[this.encounterName] = {
          creatures: creatures,
          state: false,
          name: this.encounterName,
          round: 1,
          logFile: null,
          rollHP: false
        };

        console.log(`Encounter "${this.encounterName}" added to data.encounters`);

        // Persist the data
        if (initiativeTracker.saveSettings) {
          await initiativeTracker.saveSettings();
          console.log(`‚úì Successfully saved encounter "${this.encounterName}" to Initiative Tracker`);
          new Notice(`‚úì Encounter saved to Initiative Tracker with ${creatures.length} creatures`);
        } else {
          console.warn("Initiative Tracker doesn't have saveSettings method");
          new Notice("‚ö†Ô∏è Could not persist encounter to Initiative Tracker");
        }
      } else {
        console.warn("Initiative Tracker data not accessible");
        new Notice("‚ö†Ô∏è Initiative Tracker data not accessible - encounter saved to vault only");
      }
    } catch (error) {
      console.error("Error saving to Initiative Tracker:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new Notice(`‚ö†Ô∏è Error saving to Initiative Tracker: ${errorMessage}`);
    }
  }

  async deleteEncounter() {
    if (!this.isEdit) return;

    const confirmed = await new Promise<boolean>((resolve) => {
      const modal = new Modal(this.app);
      modal.contentEl.createEl("h3", { text: "Delete Encounter?" });
      modal.contentEl.createEl("p", { text: `Are you sure you want to delete "${this.encounterName}"?` });
      modal.contentEl.createEl("p", { 
        text: "This will remove the encounter file and remove it from the Initiative Tracker.", 
        cls: "mod-warning" 
      });

      const buttonContainer = modal.contentEl.createDiv();
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.gap = "10px";
      buttonContainer.style.marginTop = "20px";

      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        modal.close();
        resolve(false);
      };

      const deleteBtn = buttonContainer.createEl("button", { text: "Delete", cls: "mod-warning" });
      deleteBtn.onclick = () => {
        modal.close();
        resolve(true);
      };

      modal.open();
    });

    if (!confirmed) return;

    try {
      // Delete the encounter file
      const file = this.app.vault.getAbstractFileByPath(this.originalEncounterPath);
      if (file instanceof TFile) {
        await this.app.vault.delete(file);
        console.log(`Deleted encounter file: ${this.originalEncounterPath}`);
      }

      // Remove from Initiative Tracker
      const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      console.log("Initiative Tracker plugin found:", !!initiativeTracker);
      
      if (initiativeTracker?.data?.encounters) {
        console.log("Current encounters in Initiative Tracker:", Object.keys(initiativeTracker.data.encounters));
        console.log(`Attempting to delete encounter: "${this.encounterName}"`);
        console.log("Encounter exists in data:", !!initiativeTracker.data.encounters[this.encounterName]);
        
        if (initiativeTracker.data.encounters[this.encounterName]) {
          delete initiativeTracker.data.encounters[this.encounterName];
          console.log(`‚úì Deleted encounter "${this.encounterName}" from data.encounters`);
          
          if (initiativeTracker.saveSettings) {
            await initiativeTracker.saveSettings();
            console.log("‚úì Initiative Tracker settings saved after deletion");
            new Notice(`‚úì Encounter deleted from Initiative Tracker`);
          } else {
            console.warn("Initiative Tracker saveSettings not available");
            new Notice("‚ö†Ô∏è Could not persist deletion to Initiative Tracker");
          }
        } else {
          console.warn(`Encounter "${this.encounterName}" not found in Initiative Tracker`);
          new Notice("‚ö†Ô∏è Encounter not found in Initiative Tracker");
        }
      } else {
        console.warn("Initiative Tracker data.encounters not accessible");
        new Notice("‚ö†Ô∏è Initiative Tracker data not accessible");
      }

      new Notice(`Encounter "${this.encounterName}" deleted from vault`);
      this.close();
    } catch (error) {
      console.error("Error deleting encounter:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new Notice(`Error deleting encounter: ${errorMessage}`);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

const SESSION_PREP_VIEW_TYPE = "session-prep-dashboard";
const SESSION_RUN_VIEW_TYPE = "session-run-dashboard";
const DM_SCREEN_VIEW_TYPE = "dm-screen";
const PLAYER_MAP_VIEW_TYPE = "dnd-player-map-view";

/**
 * A media element (image or video) that exposes image-compatible dimension properties.
 * For video elements, these are shimmed at runtime via Object.defineProperty.
 */
type MapMediaElement = (HTMLImageElement | HTMLVideoElement) & {
  readonly naturalWidth: number;
  readonly naturalHeight: number;
  readonly complete: boolean;
  readonly width: number;
  readonly height: number;
};

export default class DndCampaignHubPlugin extends Plugin {
  settings!: DndCampaignHubSettings;
  SessionCreationModal = SessionCreationModal;
  migrationManager!: MigrationManager;
  encounterBuilder!: EncounterBuilder;
  mapManager!: MapManager;
  markerLibrary!: MarkerLibrary;
  musicPlayer!: MusicPlayer;
  _playerMapViews: Set<PlayerMapView> = new Set();
  _hexcrawlBridge: HexcrawlBridge | null = null;

  async onload() {
    await this.loadSettings();

    // Register the Session Prep Dashboard view
    this.registerView(
      SESSION_PREP_VIEW_TYPE,
      (leaf) => new SessionPrepDashboardView(leaf, this)
    );

    // Register the Session Run Dashboard view
    this.registerView(
      SESSION_RUN_VIEW_TYPE,
      (leaf) => new SessionRunDashboardView(leaf, this)
    );

    // Register the DM Screen view
    this.registerView(
      DM_SCREEN_VIEW_TYPE,
      (leaf) => new DMScreenView(leaf, this)
    );

    // Register the Player Map View (for popout player view)
    this.registerView(
      PLAYER_MAP_VIEW_TYPE,
      (leaf) => {
        const view = new PlayerMapView(leaf, this);
        this._playerMapViews.add(view);
        return view;
      }
    );

    // Register the Hexcrawl View (right sidebar panel)
    this.registerView(
      HEXCRAWL_VIEW_TYPE,
      (leaf) => new HexcrawlView(leaf, this)
    );

    // Initialize the encounter builder
    this.encounterBuilder = new EncounterBuilder(this.app, this);

    // Initialize the map manager
    this.mapManager = new MapManager(this.app);

    // Initialize the marker library
    this.markerLibrary = new MarkerLibrary(this.app, this.manifest.id);
    await this.markerLibrary.load();

    // Initialize the migration manager (after marker library)
    this.migrationManager = new MigrationManager(this.app, this.markerLibrary);

    // Initialize the music player
    this.musicPlayer = new MusicPlayer(this.app, this.settings.musicSettings);

    // Register markdown code block processor for rendering maps
    this.registerMarkdownCodeBlockProcessor('dnd-map', (source, el, ctx) => {
      this.renderMapView(source, el, ctx);
    });

    // Register markdown code block processor for rendering encounter cards
    this.registerMarkdownCodeBlockProcessor('dnd-encounter', async (source, el, ctx) => {
      await this.renderEncounterView(source, el, ctx);
    });

    // Register markdown code block processor for rendering party stats
    this.registerMarkdownCodeBlockProcessor('dnd-party', async (source, el, ctx) => {
      await this.renderPartyView(source, el, ctx);
    });

    // Register markdown code block processor for rendering PoI cards
    this.registerMarkdownCodeBlockProcessor('dnd-poi', async (source, el, ctx) => {
      await this.renderPoiView(source, el, ctx);
    });

    // Register markdown code block processor for scene music cards
    this.registerMarkdownCodeBlockProcessor('dnd-music', (source, el, ctx) => {
      renderSceneMusicBlock(source, el, ctx, this.musicPlayer, this.settings.musicSettings);
    });

    // Register markdown code block processor for encounter table cards
    this.registerMarkdownCodeBlockProcessor('dnd-encounter-table', (source, el, ctx) => {
      import('./encounter/EncounterTableBlock').then(({ renderEncounterTableBlock }) => {
        renderEncounterTableBlock(source, el, ctx, this.app, this);
      });
    });

    console.log("D&D Campaign Hub: Plugin loaded");

    // Check for version updates
    await this.checkForUpdates();

    // Add the main command with configurable hotkey
    this.addCommand({
      id: "open-dnd-hub",
      name: "Open D&D Campaign Hub",
      callback: () => {
        new DndHubModal(this.app, this).open();
      },
      hotkeys: [
        {
          modifiers: ["Ctrl", "Shift"],
          key: "M",
        },
      ],
    });

    this.addCommand({
      id: "initialize-dnd-hub",
      name: "Initialize D&D Campaign Hub",
      callback: async () => {
        if (this.isVaultInitialized()) {
          new Notice("D&D Campaign Hub is already initialized in this vault.");
          return;
        }
        await this.initializeVault();
      },
    });

    this.addCommand({
      id: "update-dnd-hub-templates",
      name: "Migrate D&D Hub Files",
      callback: () => {
        if (!this.isVaultInitialized()) {
          new Notice("Initialize D&D Campaign Hub before migrating files.");
          return;
        }
        this.migrateTemplates();
      },
    });

    // Add commands for the features available in the preview release
    this.addCommand({
      id: "create-campaign",
      name: "Create New Campaign",
      callback: () => this.createCampaign(),
    });

    this.addCommand({
      id: "create-session",
      name: "Create New Session",
      callback: () => this.createSession(),
    });

    this.addCommand({
      id: "session-prep-dashboard",
      name: "Open Session Prep Dashboard",
      callback: () => this.openSessionPrepDashboard(),
    });

    this.addCommand({
      id: "session-run-dashboard",
      name: "Open Session Run Dashboard",
      callback: () => this.openSessionRunDashboard(),
    });

    this.addCommand({
      id: "create-npc",
      name: "Create New NPC",
      callback: () => this.createNpc(),
    });

    this.addCommand({
      id: "edit-npc",
      name: "Edit NPC",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "npc") {
            this.editNpc(file.path);
          } else {
            new Notice("This is not an NPC note");
          }
        } else {
          new Notice("Please open an NPC note first");
        }
      },
    });

    this.addCommand({
      id: "delete-npc",
      name: "Delete NPC",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "npc") {
            const npcName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete the map token if it exists
              const tokenId = cache.frontmatter.token_id;
              if (tokenId) {
                await this.markerLibrary.deleteMarker(tokenId);
              }
              
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted NPC file: ${file.path}`);
              
              new Notice(`‚úì NPC "${npcName}" deleted`);
            }
          } else {
            new Notice("This is not an NPC note");
          }
        } else {
          new Notice("Please open an NPC note first");
        }
      },
    });

    this.addCommand({
      id: "create-pc",
      name: "Create New PC",
      callback: () => this.createPc(),
    });

    this.addCommand({
      id: "edit-pc",
      name: "Edit PC",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "player") {
            this.editPc(file.path);
          } else {
            new Notice("This is not a PC note");
          }
        } else {
          new Notice("Please open a PC note first");
        }
      },
    });

    this.addCommand({
      id: "delete-pc",
      name: "Delete PC",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "player") {
            const pcName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete the map token if it exists
              const tokenId = cache.frontmatter.token_id;
              if (tokenId) {
                await this.markerLibrary.deleteMarker(tokenId);
              }
              
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted PC file: ${file.path}`);
              
              new Notice(`‚úì PC "${pcName}" deleted`);
            }
          } else {
            new Notice("This is not a PC note");
          }
        } else {
          new Notice("Please open a PC note first");
        }
      },
    });

    this.addCommand({
      id: "create-faction",
      name: "Create New Faction",
      callback: () => this.createFaction(),
    });

    this.addCommand({
      id: "edit-poi",
      name: "Edit Point of Interest",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "point-of-interest") {
            // Open edit modal
            import('./poi/PoiModals').then(({ PoiEditModal }) => {
              new PoiEditModal(this.app, file.path).open();
            });
          } else {
            new Notice("This is not a PoI note");
          }
        } else {
          new Notice("Please open a PoI note first");
        }
      },
    });

    this.addCommand({
      id: "delete-poi",
      name: "Delete Point of Interest",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "point-of-interest") {
            const poiName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Remove all references to this PoI from maps
              // This would require iterating through all map annotations
              // For now, just delete the note and references will be broken
              
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted PoI file: ${file.path}`);
              
              new Notice(`‚úì Point of Interest "${poiName}" deleted`);
            }
          } else {
            new Notice("This is not a PoI note");
          }
        } else {
          new Notice("Please open a PoI note first");
        }
      },
    });

    this.addCommand({
      id: "insert-poi-codeblock",
      name: "üìç Insert PoI Code Block",
      editorCallback: (editor, view) => {
        // Detect campaign from current file path
        let campaignName = "";
        const file = view.file;
        if (file) {
          const pathParts = file.path.split('/');
          const ttrpgsIndex = pathParts.indexOf('ttrpgs');
          if (ttrpgsIndex >= 0 && ttrpgsIndex < pathParts.length - 1) {
            campaignName = pathParts[ttrpgsIndex + 1] || "";
          }
        }
        
        // Open multi-select modal
        import('./poi/PoiModals').then(({ PoiPickerMultiModal }) => {
          new PoiPickerMultiModal(this.app, editor, campaignName).open();
        });
      },
    });

    this.addCommand({
      id: "update-poi-icons",
      name: "üîÑ Update PoI Icons",
      callback: async () => {
        await this.updatePoiIcons();
      },
    });

    this.addCommand({
      id: "create-adventure",
      name: "Create New Adventure",
      callback: () => this.createAdventure(),
    });

    this.addCommand({
      id: "create-spell",
      name: "Create New Spell",
      callback: () => this.createSpell(),
    });

    this.addCommand({
      id: "create-map",
      name: "üó∫Ô∏è Create Battle Map",
      callback: () => this.createMap(),
    });

    this.addCommand({
      id: "create-scene",
      name: "Create New Scene",
      callback: () => this.createScene(),
    });

    this.addCommand({
      id: "edit-scene",
      name: "Edit Scene",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.editScene(file.path);
        } else {
          new Notice("Please open a scene note first");
        }
      },
    });

    this.addCommand({
      id: "delete-scene",
      name: "Delete Scene",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "scene") {
            const sceneName = cache.frontmatter.name || file.basename;
            const encounterName = cache.frontmatter.tracker_encounter;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted scene file: ${file.path}`);
              
              // Remove encounter from Initiative Tracker if it exists
              if (encounterName) {
                const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
                console.log("Initiative Tracker plugin found:", !!initiativeTracker);
                
                if (initiativeTracker?.data?.encounters) {
                  console.log(`Attempting to delete encounter: "${encounterName}"`);
                  
                  if (initiativeTracker.data.encounters[encounterName]) {
                    delete initiativeTracker.data.encounters[encounterName];
                    console.log(`‚úì Deleted encounter "${encounterName}" from data.encounters`);
                    
                    if (initiativeTracker.saveSettings) {
                      await initiativeTracker.saveSettings();
                      console.log("‚úì Initiative Tracker settings saved after deletion");
                      new Notice(`‚úì Scene "${sceneName}" and its encounter deleted`);
                    } else {
                      console.warn("Initiative Tracker saveSettings not available");
                      new Notice(`‚ö†Ô∏è Scene deleted but could not persist encounter deletion`);
                    }
                  } else {
                    console.warn(`Encounter "${encounterName}" not found in Initiative Tracker`);
                    new Notice(`‚úì Scene "${sceneName}" deleted from vault`);
                  }
                } else {
                  console.warn("Initiative Tracker data.encounters not accessible");
                  new Notice(`‚úì Scene "${sceneName}" deleted from vault`);
                }
              } else {
                new Notice(`‚úì Scene "${sceneName}" deleted from vault`);
              }
            }
          } else {
            new Notice("This is not a scene note");
          }
        } else {
          new Notice("Please open a scene note first");
        }
      },
    });

    this.addCommand({
      id: "create-trap",
      name: "Create New Trap",
      callback: () => this.createTrap(),
    });

    this.addCommand({
      id: "edit-trap",
      name: "Edit Trap",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.editTrap(file.path);
        } else {
          new Notice("Please open a trap note first");
        }
      },
    });

    this.addCommand({
      id: "delete-trap",
      name: "Delete Trap",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "trap") {
            const trapName = cache.frontmatter.trap_name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete trap statblocks from Fantasy Statblocks first
              await this.deleteTrapStatblocks(trapName);
              
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted trap file: ${file.path}`);
              
              new Notice(`‚úì Trap "${trapName}" deleted`);
            }
          } else {
            new Notice("This is not a trap note");
          }
        } else {
          new Notice("Please open a trap note first");
        }
      },
    });

    this.addCommand({
      id: "create-item",
      name: "‚öîÔ∏è Create New Item",
      callback: () => this.createItem(),
    });

    this.addCommand({
      id: "edit-item",
      name: "Edit Item",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.editItem(file.path);
        } else {
          new Notice("Please open an item note first");
        }
      },
    });

    this.addCommand({
      id: "delete-item",
      name: "Delete Item",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "item") {
            const itemName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted item file: ${file.path}`);
              
              new Notice(`‚úì Item "${itemName}" deleted`);
            }
          } else {
            new Notice("This is not an item note");
          }
        } else {
          new Notice("Please open an item note first");
        }
      },
    });

    this.addCommand({
      id: "create-creature",
      name: "üêâ Create New Creature",
      callback: () => this.createCreature(),
    });

    this.addCommand({
      id: "edit-creature",
      name: "Edit Creature",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.editCreature(file.path);
        } else {
          new Notice("Please open a creature note first");
        }
      },
    });

    this.addCommand({
      id: "delete-creature",
      name: "Delete Creature",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.statblock === true) {
            const creatureName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted creature file: ${file.path}`);
              
              // Delete from Fantasy Statblocks plugin
              await this.deleteCreatureStatblock(creatureName);
              
              new Notice(`‚úì Creature "${creatureName}" deleted`);
            }
          } else {
            new Notice("This is not a creature note");
          }
        } else {
          new Notice("Please open a creature note first");
        }
      },
    });

    this.addCommand({
      id: "create-encounter",
      name: "Create New Encounter",
      callback: () => this.createEncounter(),
    });

    this.addCommand({
      id: "edit-encounter",
      name: "Edit Encounter",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.editEncounter(file.path);
        } else {
          new Notice("Please open an encounter note first");
        }
      },
    });

    // Register file watcher for encounter modifications
    this.registerEvent(
      this.app.vault.on('modify', async (file) => {
        if (file instanceof TFile && file.path.startsWith('z_Encounters/')) {
          console.log(`[File Watcher] Encounter modified: ${file.path}`);
          // Wait for metadata cache to update
          setTimeout(async () => {
            await this.syncEncounterToScenes(file);
          }, 100);
        }
      })
    );

    this.addCommand({
      id: "delete-encounter",
      name: "Delete Encounter",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (cache?.frontmatter?.type === "encounter") {
            const encounterName = cache.frontmatter.name || file.basename;
            const confirmed = await this.confirmDelete(file.name);
            if (confirmed) {
              // Delete from vault
              await this.app.vault.delete(file);
              console.log(`Deleted encounter file: ${file.path}`);
              
              // Remove from Initiative Tracker
              const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
              console.log("Initiative Tracker plugin found:", !!initiativeTracker);
              
              if (initiativeTracker?.data?.encounters) {
                console.log("Current encounters in Initiative Tracker:", Object.keys(initiativeTracker.data.encounters));
                console.log(`Attempting to delete encounter: "${encounterName}"`);
                console.log("Encounter exists in data:", !!initiativeTracker.data.encounters[encounterName]);
                
                if (initiativeTracker.data.encounters[encounterName]) {
                  delete initiativeTracker.data.encounters[encounterName];
                  console.log(`‚úì Deleted encounter "${encounterName}" from data.encounters`);
                  
                  if (initiativeTracker.saveSettings) {
                    await initiativeTracker.saveSettings();
                    console.log("‚úì Initiative Tracker settings saved after deletion");
                    new Notice(`‚úì Encounter "${encounterName}" deleted from vault and Initiative Tracker`);
                  } else {
                    console.warn("Initiative Tracker saveSettings not available");
                    new Notice(`‚ö†Ô∏è Encounter deleted from vault but could not persist deletion to Initiative Tracker`);
                  }
                } else {
                  console.warn(`Encounter "${encounterName}" not found in Initiative Tracker`);
                  new Notice(`‚ö†Ô∏è Encounter deleted from vault but not found in Initiative Tracker`);
                }
              } else {
                console.warn("Initiative Tracker data.encounters not accessible");
                new Notice(`‚ö†Ô∏è Encounter deleted from vault but Initiative Tracker data not accessible`);
              }
            }
          } else {
            new Notice("This is not an encounter note");
          }
        } else {
          new Notice("Please open an encounter note first");
        }
      },
    });

    // ‚îÄ‚îÄ‚îÄ Music Player Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    this.addCommand({
      id: "toggle-music-playback",
      name: "Toggle Music Play / Pause",
      callback: () => {
        this.musicPlayer.togglePlayPause();
      },
    });

    this.addCommand({
      id: "next-track",
      name: "Next Track",
      callback: () => {
        this.musicPlayer.next();
      },
    });

    this.addCommand({
      id: "previous-track",
      name: "Previous Track",
      callback: () => {
        this.musicPlayer.previous();
      },
    });

    this.addCommand({
      id: "stop-music",
      name: "Stop All Music",
      callback: () => {
        this.musicPlayer.stopAll();
      },
    });

    this.addCommand({
      id: "insert-scene-music",
      name: "üéµ Insert Scene Music Block",
      editorCallback: (editor: Editor) => {
        new SceneMusicModal(
          this.app,
          this.settings.musicSettings,
          null,
          (config) => {
            const codeblock = buildSceneMusicCodeblock(config);
            editor.replaceSelection(codeblock + '\n');
            new Notice('Scene music block inserted');
          }
        ).open();
      },
    });

    this.addCommand({
      id: "open-music-settings",
      name: "Open Music Settings",
      callback: () => {
        new MusicSettingsModal(this.app, this.settings.musicSettings, async (updated: MusicSettings) => {
          this.settings.musicSettings = updated;
          this.musicPlayer.reloadSettings(updated);
          await this.saveSettings();
          new Notice("Music settings saved");
        }).open();
      },
    });

    this.addCommand({
      id: "purge-vault",
      name: "Purge D&D Campaign Hub Data",
      callback: () => {
        new PurgeConfirmModal(this.app, this).open();
      },
    });

    // ‚îÄ‚îÄ Random Encounter Table commands ‚îÄ‚îÄ
    this.addCommand({
      id: "create-random-encounter-table",
      name: "Create Random Encounter Table",
      callback: () => {
        new RandomEncounterTableModal(this.app, this).open();
      },
    });

    this.addCommand({
      id: "roll-random-encounter",
      name: "Roll Random Encounter",
      callback: async () => {
        await this.rollRandomEncounter();
      },
    });

    this.addCommand({
      id: "insert-encounter-table-codeblock",
      name: "üé≤ Insert Encounter Table Code Block",
      editorCallback: (editor) => {
        import('./encounter/InsertEncounterTableModal').then(({ InsertEncounterTableModal }) => {
          new InsertEncounterTableModal(this.app, this, (codeblock) => {
            editor.replaceSelection(codeblock + '\n');
          }).open();
        });
      },
    });

    this.addCommand({
      id: "reroll-encounter-table-entry",
      name: "üîÑ Reroll Encounter Table Entry",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new Notice("Open an encounter table note first.");
          return;
        }
        const cache = this.app.metadataCache.getFileCache(activeFile);
        if (cache?.frontmatter?.type !== "encounter-table") {
          new Notice("‚ö†Ô∏è This is not an encounter table note.");
          return;
        }
        import('./encounter/RerollEncounterModal').then(({ RerollEncounterModal }) => {
          new RerollEncounterModal(this.app, this, activeFile).open();
        });
      },
    });

    this.addCommand({
      id: "edit-encounter-table",
      name: "‚úèÔ∏è Edit Encounter Table",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new Notice("Please open an encounter table note first");
          return;
        }
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache?.frontmatter?.type !== "encounter-table") {
          new Notice("This is not an encounter table note");
          return;
        }
        import('./encounter/RerollEncounterModal').then(({ RerollEncounterModal }) => {
          new RerollEncounterModal(this.app, this, file).open();
        });
      },
    });

    this.addCommand({
      id: "delete-encounter-table",
      name: "üóëÔ∏è Delete Encounter Table",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new Notice("Please open an encounter table note first");
          return;
        }
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache?.frontmatter?.type !== "encounter-table") {
          new Notice("This is not an encounter table note");
          return;
        }
        const tableName = cache.frontmatter.name || file.basename;
        const confirmed = await this.confirmDelete(file.name);
        if (confirmed) {
          await this.app.vault.delete(file);
          new Notice(`‚úì Encounter table "${tableName}" deleted`);
        }
      },
    });

    this.addSettingTab(new DndCampaignHubSettingTab(this.app, this));
  }

  onunload() {
    this.musicPlayer?.destroy();
  }

	async loadSettings() {
		const saved = await this.loadData();
		this.settings = Object.assign({}, DEFAULT_SETTINGS, saved);
		// Deep-merge musicSettings so new default fields are present for existing users
		if (saved?.musicSettings) {
			this.settings.musicSettings = Object.assign(
				{},
				DEFAULT_MUSIC_SETTINGS,
				saved.musicSettings
			);
		}
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}

	/**
	 * Check if plugin has been updated and notify user
	 */
	async checkForUpdates() {
		const manifest = this.manifest;
		const currentVersion = manifest.version;
		const savedVersion = this.settings.pluginVersion;

		if (savedVersion !== currentVersion) {
			// Plugin was updated
			if (savedVersion !== "0.0.0") {
				new Notice(`D&D Campaign Hub updated to v${currentVersion}! Use "Migrate D&D Hub Files" to safely update your existing files.`, 10000);
			}
			
			// Update saved version
			this.settings.pluginVersion = currentVersion;
			await this.saveSettings();
		}
	}

	/**
	 * Migrate template files safely without data loss
	 */
	async migrateTemplates() {
		// Show migration modal
		new MigrationModal(this.app, this).open();
	}

	/**
	 * Update all existing PoI icons based on their type
	 */
	async updatePoiIcons() {
		const { POI_TYPES } = await import('./map/types');
		
		try {
			const allFiles = this.app.vault.getMarkdownFiles();
			const poiFiles = allFiles.filter(file => file.path.includes('/locations/'));
			
			let updated = 0;
			let skipped = 0;
			
			for (const file of poiFiles) {
				const cache = this.app.metadataCache.getFileCache(file);
				const fm = cache?.frontmatter;
				
				if (fm?.type !== 'point-of-interest') {
					continue;
				}
				
				// Get the correct icon for this PoI type
				const poiType = fm['poi-type'] || 'custom';
				const typeDefinition = POI_TYPES.find(t => t.value === poiType);
				
				if (!typeDefinition) {
					console.warn(`Unknown PoI type: ${poiType} for ${file.path}`);
					skipped++;
					continue;
				}
				
				const correctIcon = typeDefinition.icon;
				const currentIcon = fm.icon || 'üìç';
				
				// Skip if already correct
				if (currentIcon === correctIcon) {
					skipped++;
					continue;
				}
				
				// Update the file
				let content = await this.app.vault.read(file);
				
				// Update frontmatter icon
				content = content.replace(
					/^icon:\s*.+$/m,
					`icon: ${correctIcon}`
				);
				
				// Update heading icon (first heading after frontmatter)
				const headingRegex = /^(---\n[\s\S]*?\n---\n\n)# (.+?) (.+)$/m;
				const headingMatch = content.match(headingRegex);
				if (headingMatch) {
					content = content.replace(headingRegex, `$1# ${correctIcon} $3`);
				}
				
				await this.app.vault.modify(file, content);
				updated++;
				console.log(`Updated PoI icon: ${file.basename} -> ${correctIcon}`);
			}
			
			new Notice(`‚úÖ Updated ${updated} PoI icons (${skipped} already correct)`);
			
		} catch (error) {
			console.error('Error updating PoI icons:', error);
			new Notice('‚ùå Failed to update PoI icons');
		}
	}

	/**
	 * Check if the vault has been initialized with the required folder structure
	 */
	isVaultInitialized(): boolean {
		const requiredFolders = [
			"z_Templates",
			"z_Assets",
			"z_Beastiarity",
			"z_Databases",
			"z_Dataviews",
			"z_Daten",
			"z_Decks",
			"z_Log",
			"z_Scripts",
			"z_SessionTranscripts",
			"z_Tables",
			"ttrpgs"
		];

		return requiredFolders.every(folder => {
			const folderExists = this.app.vault.getAbstractFileByPath(folder);
			return folderExists instanceof TFolder;
		});
	}

  /**
   * Purge all D&D Campaign Hub files and folders from the vault
   */
  async purgeVault() {
		const foldersToRemove = [
			"z_Templates",
			"z_Assets",
			"z_Beastiarity",
			"z_Databases",
			"z_Dataviews",
			"z_Daten",
			"z_Decks",
			"z_Log",
			"z_Scripts",
			"z_SessionTranscripts",
			"z_Tables",
			"z_Spells",
			"z_AbilityScores",
			"z_Classes",
			"z_Conditions",
			"z_DamageTypes",
			"z_Equipment",
			"z_Features",
			"z_Languages",
			"z_MagicSchools",
			"z_Proficiencies",
			"z_Races",
			"z_Skills",
			"z_Subclasses",
			"z_Subraces",
			"z_Traits",
			"z_WeaponProperties",
			"ttrpgs"
		];

		let removedCount = 0;
		let errors: string[] = [];

		for (const folderPath of foldersToRemove) {
			try {
				const folder = this.app.vault.getAbstractFileByPath(folderPath);
				if (folder instanceof TFolder) {
					await this.app.vault.delete(folder, true); // true = recursive delete
					removedCount++;
				}
			} catch (error) {
				errors.push(`${folderPath}: ${error instanceof Error ? error.message : String(error)}`);
			}
		}

		if (errors.length > 0) {
			new Notice(`Purge completed with errors. Removed ${removedCount} folders. Errors: ${errors.join(", ")}`);
		} else {
			new Notice(`Successfully purged ${removedCount} D&D Campaign Hub folders.`);
		}
	}

  /**
   * Install required community plugins
   */
  async installRequiredPlugins() {
    const requiredPlugins = [
      {
        id: "buttons",
        name: "Buttons",
        repo: "shabegom/buttons",
        version: "0.5.1"
      },
      {
        id: "dataview",
        name: "Dataview",
        repo: "blacksmithgu/obsidian-dataview",
        version: "0.5.68"
      },
      {
        id: "calendarium",
        name: "Calendarium",
        repo: "javalent/calendarium",
        version: "2.1.0"
      },
      {
        id: "initiative-tracker",
        name: "Initiative Tracker",
        repo: "javalent/initiative-tracker",
        version: "9.2.5"
      }
    ];

    new Notice("Installing required plugins...");

    for (const plugin of requiredPlugins) {
      try {
        await this.installPlugin(plugin);
      } catch (error) {
        console.error(`Failed to install ${plugin.name}:`, error);
        new Notice(`Failed to install ${plugin.name}. Please install manually.`);
      }
    }

    // Enable the plugins programmatically
    await this.enablePlugins(requiredPlugins.map(p => p.id));

    new Notice("Required plugins installed! Please reload Obsidian (Ctrl+R) to activate them.");
  }

  /**
   * Install a single plugin from GitHub
   */
  async installPlugin(plugin: { id: string; name: string; repo: string; version: string }) {
    const adapter = this.app.vault.adapter;
    const pluginsFolder = `.obsidian/plugins`;
    const pluginPath = `${pluginsFolder}/${plugin.id}`;

    // Check if plugin already exists
    const exists = await adapter.exists(pluginPath);
    if (exists) {
      console.log(`Plugin ${plugin.name} already installed`);
      return;
    }

    // Create plugin directory
    await adapter.mkdir(pluginPath);

    // Download manifest.json using Obsidian's requestUrl to bypass CORS
    const manifestUrl = `https://raw.githubusercontent.com/${plugin.repo}/HEAD/manifest.json`;
    const manifestResponse = await requestUrl({ url: manifestUrl });
    const manifest = manifestResponse.text;
    await adapter.write(`${pluginPath}/manifest.json`, manifest);

    // Download main.js from specific version
    const mainUrl = `https://github.com/${plugin.repo}/releases/download/${plugin.version}/main.js`;
    const mainResponse = await requestUrl({
      url: mainUrl,
      method: 'GET'
    });
    const mainJsArray = new Uint8Array(mainResponse.arrayBuffer);
    await adapter.writeBinary(`${pluginPath}/main.js`, mainJsArray.buffer);

    // Download styles.css if it exists
    try {
      const stylesUrl = `https://github.com/${plugin.repo}/releases/download/${plugin.version}/styles.css`;
      const stylesResponse = await requestUrl({ url: stylesUrl });
      await adapter.write(`${pluginPath}/styles.css`, stylesResponse.text);
    } catch (error) {
      // styles.css is optional
    }

    console.log(`Installed plugin: ${plugin.name}`);
  }

  /**
   * Enable plugins in community-plugins.json
   */
  async enablePlugins(pluginIds: string[]) {
    const adapter = this.app.vault.adapter;
    const configPath = `.obsidian/community-plugins.json`;

    let enabledPlugins: string[] = [];

    const exists = await adapter.exists(configPath);
    if (exists) {
      const content = await adapter.read(configPath);
      enabledPlugins = JSON.parse(content);
    }

    // Add new plugins if not already enabled
    for (const id of pluginIds) {
      if (!enabledPlugins.includes(id)) {
        enabledPlugins.push(id);
      }
    }

    await adapter.write(configPath, JSON.stringify(enabledPlugins, null, 2));
  }

  /**
   * Check if required dependencies are installed
   */
  async checkDependencies(): Promise<{ missing: string[]; installed: string[] }> {
    const requiredPlugins = [
      { id: "buttons", name: "Buttons" },
      { id: "dataview", name: "Dataview" },
      { id: "calendarium", name: "Calendarium" },
      { id: "templater-obsidian", name: "Templater" },
      { id: "initiative-tracker", name: "Initiative Tracker" }
    ];

    const installed: string[] = [];
    const missing: string[] = [];
    const enabledPlugins: Set<string> = (this.app as any).plugins?.enabledPlugins ?? new Set();

    for (const plugin of requiredPlugins) {
      if (enabledPlugins.has(plugin.id)) {
        installed.push(plugin.name);
      } else {
        missing.push(plugin.name);
      }
    }

    return { missing, installed };
  }

  /**
   * Show dependency status to user. Returns dependency summary for caller reuse.
   */
  async showDependencyModal(force = false, silentWhenSatisfied = false): Promise<{ missing: string[]; installed: string[] }> {
    const deps = await this.checkDependencies();
    if (deps.missing.length > 0 || force) {
      new DependencyModal(this.app, deps).open();
    } else if (!silentWhenSatisfied) {
      new Notice("All required D&D Campaign Hub plugins are already installed.");
    }

    return deps;
  }

	/**
	 * Initialize the vault with the required folder structure and templates
	 */
  async initializeVault() {
    new Notice("Initializing D&D Campaign Hub vault structure...");

    // Install required plugins first
    await this.installRequiredPlugins();

    // Verify dependencies before continuing
    const deps = await this.showDependencyModal(false, true);
    if (deps.missing.length > 0) {
      return;
    }

		// Create all required folders
		const foldersToCreate = [
			"z_Templates",
			"z_Assets",
			"z_Beastiarity", 
			"z_Databases",
			"z_Dataviews",
			"z_Daten",
			"z_Decks",
			"z_Log",
			"z_Scripts",
			"z_SessionTranscripts",
			"z_Tables",
			"z_Backups",
			"ttrpgs"
		];

		for (const folder of foldersToCreate) {
			try {
				await this.app.vault.createFolder(folder);
			} catch (error) {
				// Folder might already exist
			}
		}

		// Create template files
		await this.createTemplateFiles();

		// Configure plugin settings
		await this.configurePluginSettings();

		new Notice("Vault initialized successfully!");
	}

	/**
	 * Create template files in z_Templates folder
	 */
	async createTemplateFiles() {
		const templates = {
			"z_Templates/world.md": WORLD_TEMPLATE,
			"z_Templates/session-gm.md": SESSION_GM_TEMPLATE,
			"z_Templates/session-player.md": SESSION_PLAYER_TEMPLATE,
			"z_Templates/Frontmatter - NPC.md": NPC_TEMPLATE,
			"z_Templates/Frontmatter - Player Character.md": PC_TEMPLATE,
			"z_Templates/Frontmatter - Adventure.md": ADVENTURE_TEMPLATE,
			"z_Templates/Frontmatter - Faction.md": FACTION_TEMPLATE,
			"z_Templates/Frontmatter - Item.md": ITEM_TEMPLATE,
			"z_Templates/Frontmatter - Spell.md": SPELL_TEMPLATE,
		};

		for (const [path, content] of Object.entries(templates)) {
			try {
				// Check if file already exists
				const existingFile = this.app.vault.getAbstractFileByPath(path);
				if (existingFile instanceof TFile) {
					// Update existing template
					await this.app.vault.modify(existingFile, content);
				} else {
					// Create new template
					await this.app.vault.create(path, content);
				}
			} catch (error) {
				console.error(`Failed to create/update template ${path}:`, error);
			}
		}
	}

	/**
	 * Configure settings for integrated plugins
	 */
	async configurePluginSettings() {
		// Configure Templater
		try {
			const templaterSettings = {
				templates_folder: "z_Templates",
				user_scripts_folder: "z_Scripts",
				trigger_on_file_creation: true,
				enable_folder_templates: true,
				folder_templates: [
					{
						folder: "ttrpgs",
						template: "z_Templates/world.md"
					}
				]
			};
			
			// Note: We can't directly modify other plugin settings, but we can provide guidance
			console.log("D&D Campaign Hub: Suggested Templater settings:", templaterSettings);
		} catch (error) {
			console.error("Failed to configure Templater:", error);
		}

		// Configure Hide Folders
		try {
			const hideFoldersSettings = {
				attachmentFolderNames: ["startsWith::z_"],
				matchCaseInsensitive: true
			};
			console.log("D&D Campaign Hub: Suggested Hide Folders settings:", hideFoldersSettings);
		} catch (error) {
			console.error("Failed to configure Hide Folders:", error);
		}
	}

	async createCampaign() {
		// Open campaign creation modal instead of simple name prompt
		new CampaignCreationModal(this.app, this).open();
	}

	async createNpc() {
		// Check dependencies first
		const deps = await this.checkDependencies();
		if (deps.missing.length > 0) {
			new DependencyModal(this.app, deps).open();
			return;
		}
		
		// Open NPC creation modal instead of simple name prompt
		new NPCCreationModal(this.app, this).open();
	}

	async editNpc(npcPath: string) {
		// Open NPC creation modal in edit mode
		new NPCCreationModal(this.app, this, npcPath).open();
	}

	async createPc() {
		// Open PC creation modal
		new PCCreationModal(this.app, this).open();
	}

	async editPc(pcPath: string) {
		// Open PC creation modal in edit mode
		new PCCreationModal(this.app, this, pcPath).open();
	}

	async createAdventure() {
		// Open Adventure creation modal
		new AdventureCreationModal(this.app, this).open();
	}

	async createScene() {
		// Open Scene creation modal
		new SceneCreationModal(this.app, this).open();
	}

	async createTrap() {
		// Open Trap creation modal
		new TrapCreationModal(this.app, this).open();
	}

	async editTrap(trapPath: string) {
		// Open Trap creation modal in edit mode
		new TrapCreationModal(this.app, this, undefined, undefined, trapPath).open();
	}

	async createItem() {
		// Open Item creation modal
		new ItemCreationModal(this.app, this).open();
	}

	async editItem(itemPath: string) {
		// Open Item creation modal in edit mode
		new ItemCreationModal(this.app, this, itemPath).open();
	}

	async createCreature() {
		// Open Creature creation modal
		new CreatureCreationModal(this.app, this).open();
	}

	async editCreature(creaturePath: string) {
		// Open Creature creation modal in edit mode
		new CreatureCreationModal(this.app, this, creaturePath).open();
	}

	async deleteCreatureStatblock(creatureName: string) {
		try {
			const statblocksPlugin = (this.app as any).plugins.getPlugin("obsidian-5e-statblocks");
			if (!statblocksPlugin) {
				console.warn("Fantasy Statblocks plugin not found.");
				return;
			}

			// Delete from bestiary
			const bestiary = statblocksPlugin.data?.bestiary || [];
			const index = bestiary.findIndex((c: any) => c.name === creatureName);
			
			if (index !== -1) {
				bestiary.splice(index, 1);
				await statblocksPlugin.saveSettings();
				console.log(`Deleted creature "${creatureName}" from Fantasy Statblocks`);
			}
		} catch (error) {
			console.error("Error deleting creature statblock:", error);
		}
	}

	async deleteTrapStatblocks(trapName: string) {
		try {
			const statblocksPlugin = (this.app as any).plugins.getPlugin("obsidian-5e-statblocks");
			if (!statblocksPlugin) {
				console.warn("Fantasy Statblocks plugin not found.");
				return;
			}

			const homebrewSource = `Trap: ${trapName}`;
			let deletedCount = 0;

			// Try to delete from data.monsters
			if (statblocksPlugin.data?.monsters && Array.isArray(statblocksPlugin.data.monsters)) {
				const originalLength = statblocksPlugin.data.monsters.length;
				
				// Remove all statblocks with matching source (includes all elements for complex traps)
				statblocksPlugin.data.monsters = statblocksPlugin.data.monsters.filter(
					(m: any) => m.source !== homebrewSource
				);
				
				deletedCount = originalLength - statblocksPlugin.data.monsters.length;
				
				if (deletedCount > 0) {
					// Save plugin data
					await statblocksPlugin.saveData(statblocksPlugin.data);
					console.log(`Deleted ${deletedCount} trap statblock(s) from Fantasy Statblocks`);
				}
			}
		} catch (error) {
			console.error("Error deleting trap statblocks:", error);
		}
	}

	async createEncounter() {
		// Open Encounter Builder modal
		new EncounterBuilderModal(this.app, this).open();
	}

	async editEncounter(encounterPath: string) {
		// Open Encounter Builder modal in edit mode
		new EncounterBuilderModal(this.app, this, encounterPath).open();
	}

	async editScene(scenePath: string) {
		// Open Scene creation modal in edit mode
		new SceneCreationModal(this.app, this, undefined, scenePath).open();
	}

	async confirmDelete(fileName: string): Promise<boolean> {
		return new Promise((resolve) => {
			const modal = new Modal(this.app);
			modal.titleEl.setText("Confirm Delete");
			modal.contentEl.createEl("p", { text: `Are you sure you want to delete "${fileName}"?` });
			modal.contentEl.createEl("p", { 
				text: "This action cannot be undone.", 
				attr: { style: "color: var(--text-error); font-weight: bold;" }
			});

			const buttonContainer = modal.contentEl.createDiv({ cls: "modal-button-container" });
			buttonContainer.style.display = "flex";
			buttonContainer.style.gap = "10px";
			buttonContainer.style.justifyContent = "flex-end";
			buttonContainer.style.marginTop = "20px";

			const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
			cancelBtn.onclick = () => {
				resolve(false);
				modal.close();
			};

			const deleteBtn = buttonContainer.createEl("button", { text: "Delete" });
			deleteBtn.style.backgroundColor = "var(--interactive-accent)";
			deleteBtn.style.color = "var(--text-on-accent)";
			deleteBtn.onclick = () => {
				resolve(true);
				modal.close();
			};

			modal.open();
		});
	}

	/**
	 * Sync encounter modifications back to linked scenes and Initiative Tracker
	 * Called when an encounter file is modified in z_Encounters folder
	 */
	async syncEncounterToScenes(encounterFile: TFile) {
		try {
			console.log(`[SyncEncounter] Starting sync for: ${encounterFile.path}`);

			// Wait a moment for metadata cache to update, then read file directly
			await new Promise(resolve => setTimeout(resolve, 100));

			// Read the file content directly and parse frontmatter
			const content = await this.app.vault.read(encounterFile);
			const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
			
			if (!frontmatterMatch || !frontmatterMatch[1]) {
				console.log(`[SyncEncounter] No frontmatter found in encounter`);
				return;
			}

			// Parse YAML frontmatter manually
			const frontmatterText = frontmatterMatch[1];
			const lines = frontmatterText.split('\n');
			
			let encounterName = encounterFile.basename;
			let encounterCreatures: any[] = [];
			let encounterDifficulty = 'easy';
			let selectedPartyId: string | null = null;
			let useColorNames = false;
			
			// Parse creatures array
			let inCreaturesArray = false;
			let currentCreature: any = null;
			
			for (const line of lines) {
				const trimmed = line.trim();
				
				// Check for top-level fields (no indentation at start of line)
				const isTopLevel = line.length > 0 && line[0] !== ' ' && line[0] !== '\t';
				
				if (trimmed.startsWith('name:') && isTopLevel) {
					encounterName = trimmed.substring(5).trim().replace(/^["']|["']$/g, '');
				} else if (trimmed === 'creatures:' && isTopLevel) {
					inCreaturesArray = true;
					if (currentCreature) {
						encounterCreatures.push(currentCreature);
						currentCreature = null;
					}
				} else if (isTopLevel && trimmed.includes(':') && inCreaturesArray) {
					// Any top-level field ends the creatures array
					inCreaturesArray = false;
					if (currentCreature) {
						encounterCreatures.push(currentCreature);
						currentCreature = null;
					}
					
					// Process the field we just encountered
					if (trimmed.startsWith('selected_party_id:')) {
						selectedPartyId = trimmed.substring(18).trim().replace(/^["']|["']$/g, '') || null;
					} else if (trimmed.startsWith('use_color_names:')) {
						useColorNames = trimmed.substring(16).trim().toLowerCase() === 'true';
					}
				} else if (inCreaturesArray && trimmed.startsWith('- name:')) {
					if (currentCreature) {
						encounterCreatures.push(currentCreature);
					}
					currentCreature = {
						name: trimmed.substring(7).trim().replace(/^["']|["']$/g, ''),
						count: 1,
						hp: null,
						ac: null,
						cr: null,
						path: null,
						source: null
					};
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('count:')) {
					currentCreature.count = parseInt(trimmed.substring(6).trim());
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('hp:')) {
					currentCreature.hp = parseInt(trimmed.substring(3).trim());
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('ac:')) {
					currentCreature.ac = parseInt(trimmed.substring(3).trim());
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('cr:')) {
					currentCreature.cr = trimmed.substring(3).trim().replace(/^["']|["']$/g, '');
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('path:')) {
					currentCreature.path = trimmed.substring(5).trim().replace(/^["']|["']$/g, '');
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('source:')) {
					currentCreature.source = trimmed.substring(7).trim().replace(/^["']|["']$/g, '');
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('is_trap:')) {
					currentCreature.isTrap = trimmed.substring(8).trim().toLowerCase() === 'true';
				} else if (inCreaturesArray && currentCreature && trimmed.startsWith('trap_path:')) {
					// Store trap file path for later loading
					currentCreature.trapPath = trimmed.substring(10).trim().replace(/^["']|["']$/g, '');
				} else if (!inCreaturesArray && trimmed.startsWith('selected_party_id:')) {
					selectedPartyId = trimmed.substring(18).trim().replace(/^["']|["']$/g, '') || null;
				} else if (!inCreaturesArray && trimmed.startsWith('use_color_names:')) {
					useColorNames = trimmed.substring(16).trim().toLowerCase() === 'true';
				}
			}
			
			// Add last creature if exists
			if (currentCreature) {
				encounterCreatures.push(currentCreature);
			}

			console.log(`[SyncEncounter] Parsed encounter data:`, {
				name: encounterName,
				creatures: encounterCreatures.length,
				creaturesDetails: encounterCreatures,
				difficulty: encounterDifficulty,
				partyId: selectedPartyId,
				useColorNames
			});

			// Find all scenes that link to this encounter
			const encounterWikiLink = `[[${encounterFile.path}]]`;
			const scenesLinking: TFile[] = [];

			// Search through all scene files
			for (const file of this.app.vault.getMarkdownFiles()) {
				const cache = this.app.metadataCache.getFileCache(file);
				if (cache?.frontmatter?.type === 'scene') {
					const sceneEncounterFile = cache.frontmatter.encounter_file;
					if (sceneEncounterFile && 
						(sceneEncounterFile === encounterWikiLink || 
						 sceneEncounterFile === encounterFile.path ||
						 sceneEncounterFile.includes(encounterFile.basename))) {
						scenesLinking.push(file);
					}
				}
			}

			console.log(`[SyncEncounter] Found ${scenesLinking.length} scenes linking to this encounter`);

			// Update each scene's frontmatter
			for (const sceneFile of scenesLinking) {
				await this.updateSceneFrontmatter(sceneFile, {
					encounter_creatures: JSON.stringify(encounterCreatures),
					encounter_difficulty: encounterDifficulty,
					selected_party_id: selectedPartyId
				});
				console.log(`[SyncEncounter] Updated scene: ${sceneFile.path}`);
			}

			// Update Initiative Tracker encounter
			await this.updateInitiativeTrackerEncounter(encounterName, encounterCreatures, selectedPartyId, useColorNames);

			if (scenesLinking.length > 0) {
				new Notice(`‚úÖ Encounter "${encounterName}" synced to ${scenesLinking.length} scene(s)`);
			}
		} catch (error) {
			console.error('[SyncEncounter] Error:', error);
			new Notice('‚ö†Ô∏è Error syncing encounter to scenes');
		}
	}

	/**
	 * Update a scene's frontmatter fields
	 */
	async updateSceneFrontmatter(sceneFile: TFile, updates: Record<string, any>) {
		const content = await this.app.vault.read(sceneFile);
		const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
		
		if (!frontmatterMatch || !frontmatterMatch[1]) {
			console.error(`No frontmatter found in ${sceneFile.path}`);
			return;
		}

		let frontmatter = frontmatterMatch[1];

		// Update each field
		for (const [key, value] of Object.entries(updates)) {
			const fieldMatch = frontmatter.match(new RegExp(`^${key}:\\s*(.*)$`, 'm'));
			if (fieldMatch) {
				// Update existing field
				frontmatter = frontmatter.replace(
					new RegExp(`^${key}:\\s*.*$`, 'm'),
					`${key}: ${value}`
				);
			} else {
				// Add new field at the end
				frontmatter = `${frontmatter}\n${key}: ${value}`;
			}
		}

		const newContent = content.replace(
			/^---\n[\s\S]*?\n---/,
			`---\n${frontmatter}\n---`
		);

		await this.app.vault.modify(sceneFile, newContent);
	}

	/**
	 * Update Initiative Tracker encounter data
	 */
	async updateInitiativeTrackerEncounter(encounterName: string, creatures: any[], selectedPartyId: string | null, useColorNames: boolean = false) {
		try {
			console.log(`[UpdateTracker] Starting update for encounter: ${encounterName}`);
			console.log(`[UpdateTracker] Creatures:`, creatures);
			console.log(`[UpdateTracker] Party ID: ${selectedPartyId}, Use color names: ${useColorNames}`);

			const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
			if (!initiativePlugin?.data?.encounters) {
				console.log('[UpdateTracker] Initiative Tracker not available');
				return;
			}

			// Check if encounter exists in Initiative Tracker
			if (!initiativePlugin.data.encounters[encounterName]) {
				console.log(`[UpdateTracker] Encounter "${encounterName}" not found in tracker`);
				return;
			}

			// Helper function to generate unique IDs like Initiative Tracker does
			const generateId = () => {
				const chars = '0123456789abcdef';
				let id = 'ID_';
				for (let i = 0; i < 12; i++) {
					id += chars[Math.floor(Math.random() * chars.length)];
				}
				return id;
			};

			// Get party members if a party is selected
			let partyMembers: any[] = [];
			if (selectedPartyId && initiativePlugin.data.parties) {
				const party = Object.values(initiativePlugin.data.parties).find((p: any) => p.id === selectedPartyId);
				if (party && (party as any).players) {
					partyMembers = (party as any).players.map((player: any) => ({
						...player,
						id: player.id || generateId(),
						status: player.status || [],
						friendly: false,  // Party members should NOT be marked as friendly
						player: true  // Ensure player flag is set
					}));
					console.log(`[UpdateTracker] Loaded ${partyMembers.length} party members from party: ${(party as any).name}`);
				}
			}

			// Convert creatures to Initiative Tracker format
			const colors = ['Red', 'Blue', 'Green', 'Yellow', 'Purple', 'Orange', 'Pink', 'Brown'];
			
			const trackerCreatures = await Promise.all(creatures.map(async (c: any) => {
				const instances: any[] = [];
				const count = c.count || 1;
				
				console.log(`[UpdateTracker] Processing creature: ${c.name}, count: ${count}, HP: ${c.hp}, AC: ${c.ac}`);
				
				for (let i = 0; i < count; i++) {
					let creatureName = c.name;
					let displayName = c.name;

					// Use the encounter-level useColorNames setting
					if (count > 1 && useColorNames) {
						const colorIndex = i % colors.length;
						creatureName = `${c.name} (${colors[colorIndex]})`;
						displayName = creatureName;
					}

					instances.push({
						name: creatureName,
						display: displayName,
						initiative: 0,
						static: false,
						modifier: 0,
						hp: c.hp || 1,
						currentMaxHP: c.hp || 1,
						cr: c.cr || undefined,
						ac: c.ac || 10,
						currentAC: c.ac || 10,
						id: generateId(),
						currentHP: c.hp || 1,
						tempHP: 0,
						status: [],  // CRITICAL: Initialize empty status array
						enabled: true,
						active: false,
						hidden: c.isHidden || false,
						friendly: c.isFriendly || false,
						rollHP: false,
						note: c.path || '',
						path: c.path || ''
					});
				}
				return instances;
			}));

			const flatCreatures = trackerCreatures.flat();
			const allCombatants = [...partyMembers, ...flatCreatures];

			console.log(`[UpdateTracker] Total combatants: ${allCombatants.length} (${partyMembers.length} party + ${flatCreatures.length} creatures)`);

			// Update the encounter in Initiative Tracker
			initiativePlugin.data.encounters[encounterName] = {
				...initiativePlugin.data.encounters[encounterName],
				creatures: allCombatants
			};

			// Save settings
			if (initiativePlugin.saveSettings) {
				await initiativePlugin.saveSettings();
				console.log(`[UpdateTracker] ‚úÖ Successfully updated encounter "${encounterName}" in Initiative Tracker`);
				new Notice(`‚úÖ Initiative Tracker updated with latest encounter data`);
			}
		} catch (error) {
			console.error('[UpdateTracker] Error updating Initiative Tracker:', error);
		}
	}

	async createSession() {
		// Detect campaign from active file or use default
		const campaignPath = this.detectCampaignFromActiveFile() || this.settings.currentCampaign;
		// Open session creation modal
		new SessionCreationModal(this.app, this, undefined, campaignPath).open();
	}

	async openSessionPrepDashboard() {
		// Detect campaign from active file or use default
		const campaignPath = this.detectCampaignFromActiveFile() || this.settings.currentCampaign;
		
		// Check if view is already open
		const existing = this.app.workspace.getLeavesOfType(SESSION_PREP_VIEW_TYPE);
		if (existing.length > 0 && existing[0]) {
			// Reveal existing view and update campaign
			this.app.workspace.revealLeaf(existing[0]);
			const view = existing[0].view as SessionPrepDashboardView;
			view.setCampaign(campaignPath);
			return;
		}

		// Open in left pane
		const leaf = this.app.workspace.getLeftLeaf(false);
		if (leaf) {
			await leaf.setViewState({
				type: SESSION_PREP_VIEW_TYPE,
				active: true,
			});
			const view = leaf.view as SessionPrepDashboardView;
			view.setCampaign(campaignPath);
			this.app.workspace.revealLeaf(leaf);
		}
	}

	async openSessionRunDashboard() {
		// Detect campaign from active file or use default
		const campaignPath = this.detectCampaignFromActiveFile() || this.settings.currentCampaign;
		
		// Check if dashboard view is already open
		const existing = this.app.workspace.getLeavesOfType(SESSION_RUN_VIEW_TYPE);
		if (existing.length > 0 && existing[0]) {
			this.app.workspace.revealLeaf(existing[0]);
			const view = existing[0].view as SessionRunDashboardView;
			view.setCampaign(campaignPath);
			// Setup the session layout even if already open
			await view.setupSessionLayout();
			
			// Also open DM Screen if not already open
			await this.openDMScreen();
			return;
		}

		// Open dashboard control panel in left sidebar
		const dashboardLeaf = this.app.workspace.getLeftLeaf(false);
		if (dashboardLeaf) {
			await dashboardLeaf.setViewState({
				type: SESSION_RUN_VIEW_TYPE,
				active: true,
			});
			const view = dashboardLeaf.view as SessionRunDashboardView;
			view.setCampaign(campaignPath);
			this.app.workspace.revealLeaf(dashboardLeaf);
			
			// Setup the session layout with multiple panes
			await view.setupSessionLayout();
			
			// Open DM Screen in right sidebar
			await this.openDMScreen();
		}
	}

	async openDMScreen() {
		// Check if DM Screen is already open
		const existing = this.app.workspace.getLeavesOfType(DM_SCREEN_VIEW_TYPE);
		if (existing.length > 0 && existing[0]) {
			this.app.workspace.revealLeaf(existing[0]);
			return;
		}

		// Open DM Screen in right sidebar
		const dmScreenLeaf = this.app.workspace.getRightLeaf(false);
		if (dmScreenLeaf) {
			await dmScreenLeaf.setViewState({
				type: DM_SCREEN_VIEW_TYPE,
				active: true,
			});
			this.app.workspace.revealLeaf(dmScreenLeaf);
		}
	}

	/**
	 * Open the Hexcrawl panel in the bottom-right split.
	 * If already open, just reveal it.
	 */
	async openHexcrawlPanel() {
		const existing = this.app.workspace.getLeavesOfType(HEXCRAWL_VIEW_TYPE);
		if (existing.length > 0 && existing[0]) {
			this.app.workspace.revealLeaf(existing[0]);
			return;
		}

		// Open in the right sidebar ‚Äî use createLeafInParent to split bottom
		const rightLeaf = this.app.workspace.getRightLeaf(false);
		if (rightLeaf) {
			await rightLeaf.setViewState({
				type: HEXCRAWL_VIEW_TYPE,
				active: true,
			});
			this.app.workspace.revealLeaf(rightLeaf);
		}
	}

	/**
	 * Refresh any open HexcrawlView leaves (called after map state changes).
	 */
	refreshHexcrawlView() {
		const leaves = this.app.workspace.getLeavesOfType(HEXCRAWL_VIEW_TYPE);
		for (const leaf of leaves) {
			const view = leaf.view as HexcrawlView;
			if (view && typeof view.refresh === 'function') {
				view.refresh();
			}
		}
	}

	/**
	 * Detect campaign path from the currently active file
	 */
	detectCampaignFromActiveFile(): string | null {
		const activeFile = this.app.workspace.getActiveFile();
		if (!activeFile) return null;
		
		// Check if file is in a campaign folder (ttrpgs/CampaignName/...)
		const pathMatch = activeFile.path.match(/^ttrpgs\/([^\/]+)/);
		if (pathMatch && pathMatch[1]) {
			return `ttrpgs/${pathMatch[1]}`;
		}
		
		return null;
	}

	async createSpell() {
		// Open Spell Import/Creation modal with SRD API integration
		new SpellImportModal(this.app, this).open();
	}

	async createMap() {
		// Open Map creation modal
		new MapCreationModal(this.app, this, this.mapManager).open();
	}

	/**
	 * Render map view from dnd-map code block
	 */
	async renderMapView(source: string, el: HTMLElement, ctx: any) {
		try {
			// Parse the map configuration (code block only needs mapId)
			const config = JSON.parse(source);
			
			// Ensure mapId exists
			if (!config.mapId) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è Map configuration missing mapId',
					cls: 'dnd-map-error'
				});
				return;
			}

			// Load full map data from JSON file (source of truth for all settings + annotations)
			const savedData = await this.loadMapAnnotations(config.mapId);
			
			// Merge saved settings into config (JSON overrides code block)
			if (savedData.imageFile) config.imageFile = savedData.imageFile;
			if (savedData.name) config.name = savedData.name;
			if (savedData.type) config.type = savedData.type;
			if (savedData.gridType) config.gridType = savedData.gridType;
			if (savedData.gridSize) config.gridSize = savedData.gridSize;
			if (savedData.scale) config.scale = savedData.scale;
			if (savedData.dimensions) config.dimensions = savedData.dimensions;
			if (savedData.gridOffsetX !== undefined) config.gridOffsetX = savedData.gridOffsetX;
			if (savedData.gridOffsetY !== undefined) config.gridOffsetY = savedData.gridOffsetY;
			if (savedData.isVideo !== undefined) config.isVideo = savedData.isVideo;
			
			// Ensure grid offset defaults
			if (config.gridOffsetX === undefined) config.gridOffsetX = 0;
			if (config.gridOffsetY === undefined) config.gridOffsetY = 0;
			
			// Load annotations
			config.highlights = savedData.highlights || [];
			config.markers = savedData.markers || [];
			config.drawings = savedData.drawings || [];
			config.aoeEffects = savedData.aoeEffects || [];
			config.tunnels = savedData.tunnels || [];
			config.poiReferences = savedData.poiReferences || [];
			
			// Load hexcrawl terrain, climate, and state data
			config.hexTerrains = savedData.hexTerrains || [];
			config.hexClimates = savedData.hexClimates || [];
			config.customTerrainDescriptions = savedData.customTerrainDescriptions || {};
			config.hexcrawlState = savedData.hexcrawlState || null;
			
			// Load fog of war data
			config.fogOfWar = savedData.fogOfWar || { enabled: true, regions: [] };
			
			// Load dynamic lighting walls (Background layer only)
			config.walls = savedData.walls || [];
			console.log('Loaded walls from savedData:', config.walls.length, 'walls');
			
			// Load light sources (Background layer only)
			config.lightSources = savedData.lightSources || [];
			console.log('Loaded light sources from savedData:', config.lightSources.length, 'lights');
			
			// Load active layer (defaults to Player)
			config.activeLayer = savedData.activeLayer || 'Player';
			
			// Store the source note path for campaign detection
			const notePath = ctx?.sourcePath || '';
			
			// Validate imageFile (must come from JSON or code block)
			if (!config.imageFile) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è Map data not found. Please recreate the map.',
					cls: 'dnd-map-error'
				});
				return;
			}

			// Get the image file from vault
			const imageFile = this.app.vault.getAbstractFileByPath(config.imageFile);
			if (!imageFile || !(imageFile instanceof TFile)) {
				el.createEl('div', { 
					text: `‚ö†Ô∏è Image file not found: ${config.imageFile}`,
					cls: 'dnd-map-error'
				});
				return;
			}

			// Auto-detect video files from extension if not already set
			const videoExtensions = ['mp4', 'webm'];
			if (config.isVideo === undefined) {
				config.isVideo = videoExtensions.includes(imageFile.extension.toLowerCase());
			}

			// Create container for the map
			const mapContainer = el.createDiv({ cls: 'dnd-map-viewer' });
			
			// Add map title if available
			if (config.name) {
				const titleBar = mapContainer.createDiv({ cls: 'dnd-map-title' });
				titleBar.createEl('h4', { text: config.name });
				
				// Add map info
				const info = titleBar.createEl('span', { cls: 'dnd-map-info' });
				const typeEmoji = config.type === 'battlemap' ? '‚öîÔ∏è' : config.type === 'world' ? 'üåé' : 'üó∫Ô∏è';
				info.textContent = `${typeEmoji} ${config.type} ‚Ä¢ ${config.dimensions.width}√ó${config.dimensions.height}px`;
				
				if (config.scale) {
					const scale = titleBar.createEl('span', { cls: 'dnd-map-scale' });
					scale.textContent = `üìè ${config.scale.value} ${config.scale.unit} per square`;
				}
			}

			// Tool state
    let activeTool: 'pan' | 'select' | 'highlight' | 'draw' | 'ruler' | 'target-distance' | 'eraser' | 'move-grid' | 'marker' | 'aoe' | 'fog' | 'walls' | 'lights' | 'player-view' | 'poi' | 'terrain-paint' | 'climate-paint' | 'hexcrawl-move' | 'set-start-hex' | 'hex-desc' = 'pan';
		let selectedColor = '#ff0000';
      // GM player-view rect drag state
      let gmDragStart: { x: number; y: number } | null = null;
      let gmDragCurrent: { x: number; y: number } | null = null;
      let isDraggingGmRect = false;
      let isMovingGmRect = false; // True when dragging existing rect to move it
		let selectedMarkerId: string | null = null; // Currently selected marker from library
		let draggingMarkerIndex = -1; // Index of marker being dragged (-1 = none)
		let dragOffsetX = 0;
		let dragOffsetY = 0;
		let markerDragOrigin: { x: number; y: number } | null = null; // Original position when dragging a marker
		// Light dragging state
		let draggingLightIndex = -1; // Index of light being dragged (-1 = none)
		let lightDragOffsetX = 0;
		let lightDragOffsetY = 0;
		let lightDragOrigin: { x: number; y: number } | null = null;
			let rulerStart: { x: number; y: number } | null = null;
			let rulerEnd: { x: number; y: number } | null = null;
			let rulerComplete = false; // Track if ruler endpoint was set by click (not just mousemove preview)
			// Target Distance tool state
			let targetDistOriginIdx = -1; // Index of origin marker
			let targetDistTargetIdx = -1; // Index of target marker
			let targetDistState: 'selecting-origin' | 'selecting-target' | 'showing' = 'selecting-origin';
			let isDrawing = false;
			let currentPath: { x: number; y: number }[] = [];
			// AoE tool state
			let selectedAoeShape: 'circle' | 'cone' | 'square' | 'line' = 'circle';
			let aoeOrigin: { x: number; y: number } | null = null;
			let aoePreviewEnd: { x: number; y: number } | null = null;
			let pendingAoeAnchorMarkerId: string | null = null; // Set when AoE is cast from token context menu
			// Hexcrawl travel range overlay state
			let hexcrawlMoveHoverHex: { col: number; row: number } | null = null;

			// Hex distance helper for offset-coordinate hex grids (used for movement range)
			const hexDistance = (c1: number, r1: number, c2: number, r2: number): number => {
				if (config.gridType === 'hex-horizontal') {
					// Offset (odd-col) hex grid ‚Üí convert to cube coordinates
					const x1 = c1;
					const z1 = r1 - (c1 - (c1 & 1)) / 2;
					const y1 = -x1 - z1;
					const x2 = c2;
					const z2 = r2 - (c2 - (c2 & 1)) / 2;
					const y2 = -x2 - z2;
					return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
				} else {
					// hex-vertical ‚Üí offset (odd-row) hex grid ‚Üí convert to cube coordinates
					const x1 = c1 - (r1 - (r1 & 1)) / 2;
					const z1 = r1;
					const y1 = -x1 - z1;
					const x2 = c2 - (r2 - (r2 & 1)) / 2;
					const z2 = r2;
					const y2 = -x2 - z2;
					return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
				}
			};

			// Ensure aoeEffects array exists on config
			if (!config.aoeEffects) config.aoeEffects = [];
			
			// D&D 5e Light Source Definitions
			const LIGHT_SOURCES = {
				candle: { name: 'Candle', bright: 5, dim: 5, icon: 'üïØÔ∏è' },
				torch: { name: 'Torch', bright: 20, dim: 20, icon: 'üî•' },
				lantern: { name: 'Lantern', bright: 30, dim: 30, icon: 'üèÆ' },
				bullseye: { name: 'Bullseye Lantern', bright: 60, dim: 60, cone: true, icon: 'üî¶' },
				light: { name: 'Light Spell', bright: 20, dim: 20, icon: '‚ú®' },
				dancing: { name: 'Dancing Lights', bright: 0, dim: 10, icon: 'üí´' },
				continual: { name: 'Continual Flame', bright: 20, dim: 20, icon: 'üî•' },
				daylight: { name: 'Daylight Spell', bright: 60, dim: 60, icon: '‚òÄÔ∏è' }
			} as const;
			type LightSourceType = keyof typeof LIGHT_SOURCES;
			// Fog of War tool state
			let selectedFogShape: 'circle' | 'rect' | 'polygon' | 'brush' = 'brush';
			let fogMode: 'reveal' | 'hide' = 'reveal'; // Whether fog tool reveals or hides
			let fogDragStart: { x: number; y: number } | null = null;
			let fogDragEnd: { x: number; y: number } | null = null;
			let fogPolygonPoints: { x: number; y: number }[] = [];
			if (!config.fogOfWar) config.fogOfWar = { enabled: true, regions: [] };
			// Dynamic Lighting walls state (pivot/chain drawing)
			let wallPoints: { x: number; y: number }[] = [];
			let wallPreviewPos: { x: number; y: number } | null = null;
			if (!config.walls) config.walls = [];
			// Vision token selection state (for player view)
			// null = show all player tokens' vision (current default behavior)
			// string = marker id - show only that specific token's vision
			let selectedVisionTokenId: string | null = null;
			// Wall drag state
			let draggingWallIndex = -1; // Index of wall being dragged (-1 = none)
			let wallDragOffsetStartX = 0;
			let wallDragOffsetStartY = 0;
			let wallDragOffsetEndX = 0;
			let wallDragOffsetEndY = 0;
			// Wall types for dynamic lighting
			const WALL_TYPES = {
				wall: { name: 'Wall', icon: 'üß±', color: '#ff4500', style: 'solid', blocksSight: true, blocksMovement: true },
				door: { name: 'Door', icon: 'üö™', color: '#8B4513', style: 'door', blocksSight: true, blocksMovement: true },
				window: { name: 'Window', icon: 'ü™ü', color: '#87CEEB', style: 'window', blocksSight: false, blocksMovement: true },
				secret: { name: 'Secret Door', icon: 'üîí', color: '#666666', style: 'dashed', blocksSight: true, blocksMovement: true },
				invisible: { name: 'Invisible Wall', icon: 'üëª', color: '#cccccc', style: 'dotted', blocksSight: true, blocksMovement: true },
				terrain: { name: 'Terrain', icon: 'ü™®', color: '#8B7355', style: 'solid', blocksSight: false, blocksMovement: true },
			} as const;
			type WallType = keyof typeof WALL_TYPES;
			let selectedWallType: WallType = 'wall';
			
			// Helper function to calculate bounding size of rotated rectangle
			const getRotatedRectBoundingSize = (rect: any): { w: number; h: number } => {
				const deg = (rect.rotation || 0);
				const t = (deg * Math.PI) / 180;
				const ca = Math.abs(Math.cos(t));
				const sa = Math.abs(Math.sin(t));
				const w = ca * rect.w + sa * rect.h;
				const h = sa * rect.w + ca * rect.h;
				return { w, h };
			};
			// Dynamic Lighting sources state
			let selectedLightSource: LightSourceType = 'torch';
			if (!config.lightSources) config.lightSources = [];
			let isCalibrating = false;
			let calibrationPoint1: { x: number; y: number } | null = null;
			let calibrationPoint2: { x: number; y: number } | null = null;
			
			// Undo/Redo history stack
			interface HistoryState {
				markers: any[];
				walls: any[];
				lightSources: any[];
				drawings: any[];
				fogOfWar: any;
				highlights: any[];
				aoeEffects: any[];
				tunnels: any[];
			}
			const undoStack: HistoryState[] = [];
			const redoStack: HistoryState[] = [];
			const MAX_HISTORY = 50;
			
			// Placeholder for button visibility function (assigned after buttons are created)
			let updateUndoRedoButtons: () => void = () => {};
			
			// Save current state to undo stack
			const saveToHistory = () => {
				const state: HistoryState = {
					markers: JSON.parse(JSON.stringify(config.markers || [])),
					walls: JSON.parse(JSON.stringify(config.walls || [])),
					lightSources: JSON.parse(JSON.stringify(config.lightSources || [])),
					drawings: JSON.parse(JSON.stringify(config.drawings || [])),
					fogOfWar: JSON.parse(JSON.stringify(config.fogOfWar || { enabled: true, regions: [] })),
					highlights: JSON.parse(JSON.stringify(config.highlights || [])),
					aoeEffects: JSON.parse(JSON.stringify(config.aoeEffects || [])),
					tunnels: JSON.parse(JSON.stringify(config.tunnels || []))
				};
				undoStack.push(state);
				if (undoStack.length > MAX_HISTORY) undoStack.shift();
				// Clear redo stack when new action is taken
				redoStack.length = 0;
				updateUndoRedoButtons();
			};
			
			// Undo function
			const undo = () => {
				if (undoStack.length === 0) {
					new Notice('Nothing to undo');
					return;
				}
				// Save current state to redo before restoring
				const currentState: HistoryState = {
					markers: JSON.parse(JSON.stringify(config.markers || [])),
					walls: JSON.parse(JSON.stringify(config.walls || [])),
					lightSources: JSON.parse(JSON.stringify(config.lightSources || [])),
					drawings: JSON.parse(JSON.stringify(config.drawings || [])),
					fogOfWar: JSON.parse(JSON.stringify(config.fogOfWar || { enabled: true, regions: [] })),
					highlights: JSON.parse(JSON.stringify(config.highlights || [])),
					aoeEffects: JSON.parse(JSON.stringify(config.aoeEffects || [])),
					tunnels: JSON.parse(JSON.stringify(config.tunnels || []))
				};
				redoStack.push(currentState);
				
				// Restore previous state
				const prevState = undoStack.pop()!;
				config.markers = prevState.markers;
				config.walls = prevState.walls;
				config.lightSources = prevState.lightSources;
				config.drawings = prevState.drawings;
				config.fogOfWar = prevState.fogOfWar;
				config.highlights = prevState.highlights;
				config.aoeEffects = prevState.aoeEffects;
				config.tunnels = prevState.tunnels;
				
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
				if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
				updateUndoRedoButtons();
				new Notice('Undo');
			};
			
			// Redo function
			const redo = () => {
				if (redoStack.length === 0) {
					new Notice('Nothing to redo');
					return;
				}
				// Save current state to undo before restoring
				const currentState: HistoryState = {
					markers: JSON.parse(JSON.stringify(config.markers || [])),
					walls: JSON.parse(JSON.stringify(config.walls || [])),
					lightSources: JSON.parse(JSON.stringify(config.lightSources || [])),
					drawings: JSON.parse(JSON.stringify(config.drawings || [])),
					fogOfWar: JSON.parse(JSON.stringify(config.fogOfWar || { enabled: true, regions: [] })),
					highlights: JSON.parse(JSON.stringify(config.highlights || [])),
					aoeEffects: JSON.parse(JSON.stringify(config.aoeEffects || [])),
					tunnels: JSON.parse(JSON.stringify(config.tunnels || []))
				};
				undoStack.push(currentState);
				
				// Restore redo state
				const nextState = redoStack.pop()!;
				config.markers = nextState.markers;
				config.walls = nextState.walls;
				config.lightSources = nextState.lightSources;
				config.drawings = nextState.drawings;
				config.fogOfWar = nextState.fogOfWar;
				config.highlights = nextState.highlights;
				config.aoeEffects = nextState.aoeEffects;
				config.tunnels = nextState.tunnels;
				
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
				if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
				updateUndoRedoButtons();
				new Notice('Redo');
			};


		// Create scrollable viewport
		const viewport = mapContainer.createDiv({ cls: 'dnd-map-viewport' });
		viewport.setAttribute('tabindex', '0'); // Make viewport focusable for keyboard events
		
		// Create wrapper that will be transformed (zoom + pan)
		const mapWrapper = viewport.createDiv({ cls: 'dnd-map-wrapper' });
		
		// Get the resource path for the image
		const resourcePath = this.app.vault.getResourcePath(imageFile);
		
		// Create the map background element (image or video)
		let img: MapMediaElement;
		if (config.isVideo) {
			const video = mapWrapper.createEl('video', {
				cls: 'dnd-map-image dnd-map-video',
				attr: {
					src: resourcePath,
					autoplay: '',
					loop: '',
					muted: '',
					playsinline: '',
				}
			});
			video.autoplay = true;
			video.loop = true;
			video.muted = true;
			video.playsInline = true;
			// Shim image-compatible properties so existing code works transparently
			Object.defineProperty(video, 'naturalWidth', { get: () => video.videoWidth, configurable: true });
			Object.defineProperty(video, 'naturalHeight', { get: () => video.videoHeight, configurable: true });
			Object.defineProperty(video, 'complete', { get: () => video.readyState >= 2, configurable: true });
			// Shim width/height to return rendered size (HTMLImageElement.width returns clientWidth)
			Object.defineProperty(video, 'width', { get: () => video.clientWidth || video.videoWidth, configurable: true });
			Object.defineProperty(video, 'height', { get: () => video.clientHeight || video.videoHeight, configurable: true });
			img = video as MapMediaElement;
		} else {
			img = mapWrapper.createEl('img', {
				cls: 'dnd-map-image',
				attr: {
					src: resourcePath,
					alt: config.name || 'Battle Map'
				}
			});
		}

		// Add floating toolbar wrapper (holds toolbar + layer menu)
		const toolbarWrapper = viewport.createDiv({ cls: 'dnd-map-toolbar-wrapper' });
		
		// Add undo/redo bar at top center
		const undoRedoBar = viewport.createDiv({ cls: 'dnd-map-undoredo-bar' });
		undoRedoBar.style.cssText = 'position: absolute; top: 8px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; gap: 4px; background: var(--background-secondary); border-radius: 6px; padding: 4px 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);';
		// Prevent clicks on the bar from propagating to map tools
		undoRedoBar.addEventListener('mousedown', (e) => { e.stopPropagation(); e.preventDefault(); });
		undoRedoBar.addEventListener('click', (e) => { e.stopPropagation(); });
		
		const undoBtn = undoRedoBar.createEl('button', { cls: 'dnd-map-undoredo-btn', attr: { title: 'Undo (Ctrl+Z)' } });
		undoBtn.innerHTML = '‚Ü∂';
		undoBtn.style.cssText = 'background: transparent; border: none; font-size: 18px; cursor: pointer; padding: 4px 8px; border-radius: 4px; color: var(--text-normal);';
		undoBtn.addEventListener('click', (e) => { e.stopPropagation(); e.preventDefault(); undo(); });
		undoBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); e.preventDefault(); });
		undoBtn.addEventListener('mouseenter', () => undoBtn.style.background = 'var(--background-modifier-hover)');
		undoBtn.addEventListener('mouseleave', () => undoBtn.style.background = 'transparent');
		
		const redoBtn = undoRedoBar.createEl('button', { cls: 'dnd-map-undoredo-btn', attr: { title: 'Redo (Ctrl+Y)' } });
		redoBtn.innerHTML = '‚Ü∑';
		redoBtn.style.cssText = 'background: transparent; border: none; font-size: 18px; cursor: pointer; padding: 4px 8px; border-radius: 4px; color: var(--text-normal);';
		redoBtn.addEventListener('click', (e) => { e.stopPropagation(); e.preventDefault(); redo(); });
		redoBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); e.preventDefault(); });
		redoBtn.addEventListener('mouseenter', () => redoBtn.style.background = 'var(--background-modifier-hover)');
		redoBtn.addEventListener('mouseleave', () => redoBtn.style.background = 'transparent');
		
		// Update undo/redo button visibility based on stack state
		updateUndoRedoButtons = () => {
			undoBtn.style.display = undoStack.length > 0 ? '' : 'none';
			redoBtn.style.display = redoStack.length > 0 ? '' : 'none';
			// Hide the bar entirely if both are hidden
			undoRedoBar.style.display = (undoStack.length > 0 || redoStack.length > 0) ? 'flex' : 'none';
		};
		updateUndoRedoButtons(); // Initialize visibility

		// Add floating toolbar inside wrapper
		const toolbar = toolbarWrapper.createDiv({ cls: 'dnd-map-toolbar' });
		
		// Toolbar header with just collapse toggle icon
		const toolbarHeader = toolbar.createDiv({ cls: 'dnd-map-toolbar-header' });
		const toggleIcon = toolbarHeader.createEl('span', { 
			text: '‚ñº', 
			cls: 'dnd-map-toolbar-toggle' 
		});
		
		// Toolbar content wrapper for collapse animation
		const toolbarContent = toolbar.createDiv({ cls: 'dnd-map-toolbar-content' });
		
		// === COMMON TOOLS (2-column grid, always visible) ===
		const commonToolGroup = toolbarContent.createDiv({ cls: 'dnd-map-tool-group' });
		
		// Helper to create icon-only buttons with hover labels
		const createToolBtn = (parent: HTMLElement, icon: string, label: string, isActive = false, fullWidth = false): HTMLButtonElement => {
			const btn = parent.createEl('button', { 
				cls: 'dnd-map-tool-btn' + (isActive ? ' active' : '') + (fullWidth ? ' full-width' : '')
			});
			btn.createEl('span', { text: icon, cls: 'dnd-map-tool-btn-icon' });
			const labelSpan = btn.createEl('span', { text: label, cls: 'dnd-map-tool-btn-label' });
			// Check if button will be in the right column (every even button in 2-column grid)
			// We'll mark right-column buttons to adjust tooltip position
			setTimeout(() => {
				const parentGrid = btn.parentElement;
				if (parentGrid && parentGrid.classList.contains('dnd-map-tool-group')) {
					const buttons = Array.from(parentGrid.querySelectorAll('.dnd-map-tool-btn:not(.full-width)'));
					const index = buttons.indexOf(btn);
					if (index % 2 === 1) {
						labelSpan.classList.add('right-column-tooltip');
					}
				}
			}, 0);
			return btn;
		};
		
		// Common navigation and editing tools (2 columns)
		const panBtn = createToolBtn(commonToolGroup, '‚¨Ü', 'Pan', true);
		const selectBtn = createToolBtn(commonToolGroup, 'üëÜ', 'Select');
		const highlightIcon = config.gridType === 'square' ? '‚¨ú' : '‚¨°';
		const highlightBtn = createToolBtn(commonToolGroup, highlightIcon, 'Highlight');
		const poiBtn = createToolBtn(commonToolGroup, 'üìç', 'Point of Interest');
		const markerBtn = createToolBtn(commonToolGroup, 'üéØ', 'Marker');
		const drawBtn = createToolBtn(commonToolGroup, '‚úè', 'Draw');
		const rulerBtn = createToolBtn(commonToolGroup, 'üìè', 'Ruler');
		const targetDistBtn = createToolBtn(commonToolGroup, 'üìê', 'Token Distance');
		const aoeBtn = createToolBtn(commonToolGroup, 'üí•', 'AoE');
		const eraserBtn = createToolBtn(commonToolGroup, 'üßπ', 'Eraser');
		
		// === HEXCRAWL SECTION (expandable, hex maps on world/regional maps only) ===
		const isHexcrawlMap = (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && (config.type === 'world' || config.type === 'regional');
		const hcLang = (config.hexcrawlState?.descriptionLanguage as 'en' | 'de') || 'en';
		const hexcrawlSectionHeader = toolbarContent.createDiv({ cls: 'dnd-map-section-header' });
		hexcrawlSectionHeader.createEl('span', { text: hLoc(hcLang, 'toolbarHexcrawl'), cls: 'dnd-map-section-title' });
		hexcrawlSectionHeader.createEl('span', { text: '‚ñº', cls: 'dnd-map-section-toggle' });
		const hexcrawlContent = toolbarContent.createDiv({ cls: 'dnd-map-section-content' });
		
		// Hide hexcrawl section on non-hex maps
		hexcrawlSectionHeader.toggleClass('hidden', !isHexcrawlMap);
		hexcrawlContent.toggleClass('hidden', !isHexcrawlMap);
		
		const terrainPaintBtn = createToolBtn(hexcrawlContent, 'üåç', hLoc(hcLang, 'toolTerrainPaint'));
		const climatePaintBtn = createToolBtn(hexcrawlContent, 'üå°Ô∏è', hLoc(hcLang, 'toolClimatePaint'));
		const setStartHexBtn = createToolBtn(hexcrawlContent, 'üìå', hLoc(hcLang, 'toolSetStartHex'));
		const hexDescBtn = createToolBtn(hexcrawlContent, 'üìù', hLoc(hcLang, 'toolHexDesc'));
		
		// Terrain picker sub-menu (shown when terrain-paint tool is active)
		let selectedTerrainType: TerrainType = 'forest';
		const terrainPicker = terrainPaintBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		for (const def of TERRAIN_DEFINITIONS) {
			const tName = hLoc(hcLang, `terrain.${def.id}`);
			const btn = terrainPicker.createEl('button', {
				cls: `dnd-map-aoe-shape-btn ${def.id === selectedTerrainType ? 'active' : ''}`,
				attr: { title: `${tName} ‚Äî Speed √ó${def.travelModifier}` },
			});
			btn.createEl('span', { text: def.icon });
			btn.addEventListener('click', (e) => {
				e.stopPropagation();
				selectedTerrainType = def.id;
				terrainPicker.querySelectorAll('.dnd-map-aoe-shape-btn').forEach(b => b.removeClass('active'));
				btn.addClass('active');
				terrainPicker.addClass('hidden');
			});
		}
		// Clear terrain button
		terrainPicker.createDiv({ cls: 'dnd-fog-picker-sep' });
		const clearTerrainBtn = terrainPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: hLoc(hcLang, 'clearAllTerrain') },
		});
		clearTerrainBtn.createEl('span', { text: 'üóëÔ∏è' });
		clearTerrainBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			config.hexTerrains = [];
			redrawTerrainLayer();
			redrawAnnotations();
			this.saveMapAnnotations(config, el);
			new Notice(hLoc(hcLang, 'allTerrainCleared'));
			this.refreshHexcrawlView();
		});
		// Description settings button
		terrainPicker.createDiv({ cls: 'dnd-fog-picker-sep' });
		const descSettingsBtn = terrainPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: hLoc(hcLang, 'customTerrainDescsTooltip') },
		});
		descSettingsBtn.createEl('span', { text: '‚öôÔ∏è' });
		descSettingsBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			terrainPicker.addClass('hidden');
			new HexDescriptionSettingsModal(
				this.app,
				config.customTerrainDescriptions || {},
				(updated) => {
					config.customTerrainDescriptions = updated;
					this.saveMapAnnotations(config, el);
					new Notice(hLoc(hcLang, 'customDescsSaved'));
				},
				hcLang,
			).open();
		});

		// Climate picker sub-menu (shown when climate-paint tool is active)
		let selectedClimateType: import('./hexcrawl/types').ClimateType = 'temperate';
		const climatePicker = climatePaintBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		for (const cdef of CLIMATE_DEFINITIONS) {
			const cName = hLoc(hcLang, `climate.${cdef.id}`);
			const cDesc = hLoc(hcLang, `climateDesc.${cdef.id}`);
			const btn = climatePicker.createEl('button', {
				cls: `dnd-map-aoe-shape-btn ${cdef.id === selectedClimateType ? 'active' : ''}`,
				attr: { title: `${cName} ‚Äî ${cDesc}` },
			});
			btn.createEl('span', { text: cdef.icon });
			btn.addEventListener('click', (e) => {
				e.stopPropagation();
				selectedClimateType = cdef.id;
				climatePicker.querySelectorAll('.dnd-map-aoe-shape-btn').forEach(b => b.removeClass('active'));
				btn.addClass('active');
				climatePicker.addClass('hidden');
			});
		}
		// Clear climate button
		climatePicker.createDiv({ cls: 'dnd-fog-picker-sep' });
		const clearClimateBtn = climatePicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: hLoc(hcLang, 'clearAllClimate') },
		});
		clearClimateBtn.createEl('span', { text: 'üóëÔ∏è' });
		clearClimateBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			config.hexClimates = [];
			redrawTerrainLayer();
			redrawAnnotations();
			this.saveMapAnnotations(config, el);
			new Notice(hLoc(hcLang, 'allClimateCleared'));
			this.refreshHexcrawlView();
		});
		
		// Open Hexcrawl Panel button
		const openHexcrawlBtn = createToolBtn(hexcrawlContent, 'üìã', hLoc(hcLang, 'toolOpenPanel'));
		openHexcrawlBtn.addEventListener('click', async () => {
			await this.openHexcrawlPanel();
		});
		
		// Toggle hexcrawl section visibility
		let hexcrawlSectionOpen = true;
		hexcrawlSectionHeader.addEventListener('click', () => {
			hexcrawlSectionOpen = !hexcrawlSectionOpen;
			hexcrawlContent.toggleClass('hidden', !hexcrawlSectionOpen || !isHexcrawlMap);
			hexcrawlSectionHeader.querySelector('.dnd-map-section-toggle')!.textContent = hexcrawlSectionOpen ? '‚ñº' : '‚ñ∂';
		});

		// === VISION SECTION (expandable, Background layer only) ===
		const visionSectionHeader = toolbarContent.createDiv({ cls: 'dnd-map-section-header' });
		visionSectionHeader.createEl('span', { text: 'Vision', cls: 'dnd-map-section-title' });
		visionSectionHeader.createEl('span', { text: '‚ñº', cls: 'dnd-map-section-toggle' });
		const visionContent = toolbarContent.createDiv({ cls: 'dnd-map-section-content' });
		
		const fogBtn = createToolBtn(visionContent, 'üå´Ô∏è', 'Fog');
		const wallsBtn = createToolBtn(visionContent, 'üß±', 'Walls');
		const lightsBtn = createToolBtn(visionContent, 'üí°', 'Lights');

		// Toggle vision section visibility based on layer (hidden entirely for hexcrawl maps)
		visionSectionHeader.toggleClass('hidden', config.activeLayer !== 'Background' || isHexcrawlMap);
		visionContent.toggleClass('hidden', config.activeLayer !== 'Background' || isHexcrawlMap);

		// === TOKEN VISION TOGGLE (always visible, all layers ‚Äî hidden for hexcrawl) ===
		const tokenVisionSectionHeader = toolbarContent.createDiv({ cls: 'dnd-map-section-header' });
		tokenVisionSectionHeader.createEl('span', { text: 'Token Vision', cls: 'dnd-map-section-title' });
		tokenVisionSectionHeader.createEl('span', { text: '‚ñº', cls: 'dnd-map-section-toggle' });
		const tokenVisionContent = toolbarContent.createDiv({ cls: 'dnd-map-section-content' });
		tokenVisionSectionHeader.toggleClass('hidden', isHexcrawlMap);
		tokenVisionContent.toggleClass('hidden', isHexcrawlMap);

		// Token Vision Selector - custom dropdown to pick which token's vision to show in Player View
		const visionSelectorRow = tokenVisionContent.createDiv({ cls: 'dnd-map-vision-selector' });
		visionSelectorRow.createEl('span', { text: 'View as:', cls: 'dnd-map-vision-label' });
		const visionDropdown = visionSelectorRow.createDiv({ cls: 'dnd-map-vision-dropdown' });
		const visionSelected = visionDropdown.createDiv({ cls: 'dnd-map-vision-selected' });
		visionSelected.setAttribute('title', 'Select which token\'s vision to show in Player View');
		const visionMenu = visionDropdown.createDiv({ cls: 'dnd-map-vision-menu' });

		// Toggle menu open/close
		visionSelected.addEventListener('click', (e) => {
			e.stopPropagation();
			visionMenu.toggleClass('open', !visionMenu.hasClass('open'));
		});
		// Close on outside click
		document.addEventListener('click', () => {
			visionMenu.removeClass('open');
		});

		// Helper to build an option item (used for both "All Players" and token entries)
		const buildVisionOption = (
			container: HTMLElement,
			icon: string,
			name: string,
			value: string,
			borderColor?: string
		) => {
			const item = container.createDiv({ cls: 'dnd-map-vision-item' });
			item.createEl('span', { text: icon, cls: 'dnd-map-vision-item-icon' });
			item.createEl('span', { text: name, cls: 'dnd-map-vision-item-name' });
			if (borderColor) {
				const dot = item.createEl('span', { cls: 'dnd-map-vision-color-dot' });
				dot.style.backgroundColor = borderColor;
			}
			item.dataset.value = value;
			if ((value === '' && selectedVisionTokenId === null) || value === selectedVisionTokenId) {
				item.addClass('active');
			}
			item.addEventListener('click', (e) => {
				e.stopPropagation();
				selectedVisionTokenId = value === '' ? null : value;
				visionMenu.removeClass('open');
				refreshVisionSelector();
				if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
				new Notice(selectedVisionTokenId ? `Vision: ${icon} ${name}` : 'Vision: All Players');
			});
			return item;
		};

		// Function to refresh the vision selector options based on current markers
		const refreshVisionSelector = () => {
			visionMenu.empty();

			// Collect tokens
			const visionTokens = (config.markers || []).filter((m: any) => {
				const markerDef = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
				if (!markerDef) return false;
				return ['player', 'npc', 'creature'].includes(markerDef.type);
			});

			// Count name occurrences to detect duplicates
			const nameCounts = new Map<string, number>();
			visionTokens.forEach((m: any) => {
				const markerDef = this.markerLibrary.getMarker(m.markerId);
				const name = markerDef?.name || m.id;
				nameCounts.set(name, (nameCounts.get(name) || 0) + 1);
			});

			// "All Players" option
			buildVisionOption(visionMenu, 'üë•', 'All Players', '');

			// Token options
			visionTokens.forEach((m: any) => {
				const markerDef = this.markerLibrary.getMarker(m.markerId);
				const icon = markerDef?.type === 'player' ? 'üë§' : markerDef?.type === 'creature' ? 'üëπ' : 'üßë';
				const name = markerDef?.name || m.id;
				const isDupe = (nameCounts.get(name) || 0) > 1;
				const borderColor = isDupe ? (m.borderColor || markerDef?.borderColor || '#ffffff') : undefined;
				buildVisionOption(visionMenu, icon, name, m.id, borderColor);
			});

			// Update selected display
			visionSelected.empty();
			if (selectedVisionTokenId === null) {
				visionSelected.createEl('span', { text: 'üë•', cls: 'dnd-map-vision-item-icon' });
				visionSelected.createEl('span', { text: 'All Players', cls: 'dnd-map-vision-item-name' });
			} else {
				const selMarker = visionTokens.find((m: any) => m.id === selectedVisionTokenId);
				if (selMarker) {
					const selDef = this.markerLibrary.getMarker(selMarker.markerId);
					const selIcon = selDef?.type === 'player' ? 'üë§' : selDef?.type === 'creature' ? 'üëπ' : 'üßë';
					const selName = selDef?.name || selMarker.id;
					const isDupe = (nameCounts.get(selName) || 0) > 1;
					visionSelected.createEl('span', { text: selIcon, cls: 'dnd-map-vision-item-icon' });
					visionSelected.createEl('span', { text: selName, cls: 'dnd-map-vision-item-name' });
					if (isDupe) {
						const selColor = selMarker.borderColor || selDef?.borderColor || '#ffffff';
						const dot = visionSelected.createEl('span', { cls: 'dnd-map-vision-color-dot' });
						dot.style.backgroundColor = selColor;
					}
				} else {
					// Selected token was removed, reset
					selectedVisionTokenId = null;
					visionSelected.createEl('span', { text: 'üë•', cls: 'dnd-map-vision-item-icon' });
					visionSelected.createEl('span', { text: 'All Players', cls: 'dnd-map-vision-item-name' });
				}
			}
			// Add dropdown arrow
			visionSelected.createEl('span', { text: '‚ñæ', cls: 'dnd-map-vision-arrow' });
		};

		// Initial population
		refreshVisionSelector();

		// === TUNNELS SECTION (expandable) ===
		const tunnelsSectionHeader = toolbarContent.createDiv({ cls: 'dnd-map-section-header' });
		tunnelsSectionHeader.createEl('span', { text: 'Tunnels', cls: 'dnd-map-section-title' });
		tunnelsSectionHeader.createEl('span', { text: '‚ñº', cls: 'dnd-map-section-toggle' });
		const tunnelsContent = toolbarContent.createDiv({ cls: 'dnd-map-section-content' });
		
		const clearTunnelsBtn = createToolBtn(tunnelsContent, 'üßπ', 'Clear Tunnels');
		
		// Toggle tunnels section visibility based on layer
		tunnelsSectionHeader.toggleClass('hidden', config.activeLayer !== 'Subterranean' || isHexcrawlMap);
		tunnelsContent.toggleClass('hidden', config.activeLayer !== 'Subterranean' || isHexcrawlMap);
		
		// === SETUP SECTION (expandable) ===
		const setupSectionHeader = toolbarContent.createDiv({ cls: 'dnd-map-section-header' });
		setupSectionHeader.createEl('span', { text: 'Setup', cls: 'dnd-map-section-title' });
		setupSectionHeader.createEl('span', { text: '‚ñº', cls: 'dnd-map-section-toggle' });
		const setupContent = toolbarContent.createDiv({ cls: 'dnd-map-section-content' });
		
		const moveGridBtn = createToolBtn(setupContent, '‚ú•', 'Move Grid');
		const calibrateBtn = createToolBtn(setupContent, '‚öô', 'Calibrate');
		
		// === PLAYER VIEW (full-width, prominent) ===
		const viewGroup = toolbarContent.createDiv({ cls: 'dnd-map-tool-group' });
		const viewBtn = createToolBtn(viewGroup, 'üì∫', 'Player View', false, true);

		// Fog of War shape picker sub-menu (shown when fog tool is active)
		const fogPicker = fogBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		// Fog mode toggle (reveal/hide)
		const fogModeBtn = fogPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-mode-btn active',
			attr: { title: 'Mode: Reveal' }
		});
		fogModeBtn.createEl('span', { text: 'üëÅÔ∏è' });
		fogModeBtn.addEventListener('click', () => {
			fogMode = fogMode === 'reveal' ? 'hide' : 'reveal';
			fogModeBtn.setAttribute('title', fogMode === 'reveal' ? 'Mode: Reveal' : 'Mode: Hide');
			const iconEl = fogModeBtn.querySelector('span');
			if (iconEl) iconEl.textContent = fogMode === 'reveal' ? 'üëÅÔ∏è' : 'üö´';
			fogModeBtn.toggleClass('fog-hide-mode', fogMode === 'hide');
		});
		// Separator in picker
		const fogSep = fogPicker.createDiv({ cls: 'dnd-fog-picker-sep' });
		// Shape picker buttons
		const fogShapes: { shape: 'brush' | 'circle' | 'rect' | 'polygon'; icon: string; label: string }[] = [
			{ shape: 'brush', icon: 'üñåÔ∏è', label: 'Brush (drag)' },
			{ shape: 'circle', icon: '‚≠ï', label: 'Circle' },
			{ shape: 'rect', icon: '‚¨ú', label: 'Rectangle' },
			{ shape: 'polygon', icon: '‚¨†', label: 'Polygon' },
		];
		const fogShapeButtons: Map<string, HTMLButtonElement> = new Map();
		fogShapes.forEach(({ shape, icon, label }) => {
			const btn = fogPicker.createEl('button', {
				cls: 'dnd-map-aoe-shape-btn' + (shape === selectedFogShape ? ' active' : ''),
				attr: { title: label }
			});
			btn.createEl('span', { text: icon });
			fogShapeButtons.set(shape, btn);
			btn.addEventListener('click', () => {
				selectedFogShape = shape;
				fogShapeButtons.forEach((b) => b.removeClass('active'));
				btn.addClass('active');
			});
		});
		// Reveal All / Hide All buttons
		const fogRevealAllBtn = fogPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: 'Reveal All' }
		});
		fogRevealAllBtn.createEl('span', { text: '‚òÄÔ∏è' });
		fogRevealAllBtn.addEventListener('click', () => {
			config.fogOfWar.regions = [];
			config.fogOfWar.enabled = false;
			redrawAnnotations();
			this.saveMapAnnotations(config, el);
			// Sync to player view
			const viewport = el.querySelector('.dnd-map-viewport') as any;
			if (viewport && viewport._syncPlayerView) viewport._syncPlayerView();
			new Notice('Fog cleared ‚Äî entire map revealed');
		});
		const fogHideAllBtn = fogPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: 'Hide All' }
		});
		fogHideAllBtn.createEl('span', { text: 'üåë' });
		fogHideAllBtn.addEventListener('click', () => {
			config.fogOfWar.regions = [];
			config.fogOfWar.enabled = true;
			redrawAnnotations();
			this.saveMapAnnotations(config, el);
			// Sync to player view
			const viewport = el.querySelector('.dnd-map-viewport') as any;
			if (viewport && viewport._syncPlayerView) viewport._syncPlayerView();
			new Notice('Entire map hidden by fog');
		});
		// Only show fog, walls, and lights buttons when on Background layer
		fogBtn.toggleClass('hidden', config.activeLayer !== 'Background');
		wallsBtn.toggleClass('hidden', config.activeLayer !== 'Background');
		lightsBtn.toggleClass('hidden', config.activeLayer !== 'Background');

		// Wall type picker sub-menu (shown when walls tool is active)
		const wallsPicker = wallsBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		const wallTypeButtons: Map<string, HTMLButtonElement> = new Map();
		(Object.entries(WALL_TYPES) as [WallType, typeof WALL_TYPES[WallType]][]).forEach(([type, wallDef]) => {
			const btn = wallsPicker.createEl('button', {
				cls: 'dnd-map-aoe-shape-btn' + (type === selectedWallType ? ' active' : ''),
				attr: { title: wallDef.name }
			});
			btn.createEl('span', { text: wallDef.icon });
			wallTypeButtons.set(type, btn);
			btn.addEventListener('click', () => {
				selectedWallType = type;
				wallTypeButtons.forEach((b) => b.removeClass('active'));
				btn.addClass('active');
			});
		});
		// Separator
		wallsPicker.createDiv({ cls: 'dnd-fog-picker-sep' });
		// Delete all walls button
		const clearWallsBtn = wallsPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: 'Delete All Walls' }
		});
		clearWallsBtn.createEl('span', { text: 'üóëÔ∏è' });
		clearWallsBtn.addEventListener('click', () => {
			if (config.walls && config.walls.length > 0) {
				saveToHistory();
				config.walls = [];
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
				const viewport = el.querySelector('.dnd-map-viewport') as any;
				if (viewport && viewport._syncPlayerView) viewport._syncPlayerView();
				new Notice('All walls deleted');
			} else {
				new Notice('No walls to delete');
			}
		});

		// Light Sources picker sub-menu (shown when lights tool is active)
		const lightsPicker = lightsBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		const lightTypes: { type: string; source: any }[] = [
			{ type: 'candle', source: LIGHT_SOURCES.candle },
			{ type: 'torch', source: LIGHT_SOURCES.torch },
			{ type: 'lantern', source: LIGHT_SOURCES.lantern },
			{ type: 'bullseye', source: LIGHT_SOURCES.bullseye },
			{ type: 'light', source: LIGHT_SOURCES.light },
			{ type: 'dancing', source: LIGHT_SOURCES.dancing },
			{ type: 'continual', source: LIGHT_SOURCES.continual },
			{ type: 'daylight', source: LIGHT_SOURCES.daylight }
		];
		const lightTypeButtons: Map<string, HTMLButtonElement> = new Map();
		lightTypes.forEach(({ type, source }) => {
			const btn = lightsPicker.createEl('button', {
				cls: 'dnd-map-aoe-shape-btn' + (type === selectedLightSource ? ' active' : ''),
				attr: { title: `${source.name} (${source.bright}/${source.dim} ft)` }
			});
			btn.createEl('span', { text: source.icon });
			lightTypeButtons.set(type, btn);
			btn.addEventListener('click', () => {
				selectedLightSource = type as LightSourceType;
				lightTypeButtons.forEach((b) => b.removeClass('active'));
				btn.addClass('active');
			});
		});
		// Clear All Lights button
		const clearLightsBtn = lightsPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn dnd-fog-action-btn',
			attr: { title: 'Clear All Lights' }
		});
		clearLightsBtn.createEl('span', { text: 'üåë' });
		clearLightsBtn.addEventListener('click', () => {
			config.lightSources = [];
			redrawAnnotations();
			this.saveMapAnnotations(config, el);
			new Notice('All light sources removed');
		});

		// Player View controls picker sub-menu (shown when player-view tool is active)
		const pvPicker = viewBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		const pvFullscreenBtn = pvPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn',
			attr: { title: 'Toggle Fullscreen on Player View' }
		});
		pvFullscreenBtn.createEl('span', { text: 'üñµ' });
		pvFullscreenBtn.addEventListener('click', () => {
			if ((this as any)._playerMapViews) {
				(this as any)._playerMapViews.forEach((pv: any) => {
					try { if (typeof pv.toggleFullscreen === 'function') pv.toggleFullscreen(); else (pv as any).toggleFullscreen?.(); } catch (e) {}
				});
			}
		});
		
		const pvCalibrateBtn = pvPicker.createEl('button', {
			cls: 'dnd-map-aoe-shape-btn',
			attr: { title: 'Calibrate Player View for Physical Miniatures' }
		});
		pvCalibrateBtn.createEl('span', { text: 'üéØ' });
		pvCalibrateBtn.addEventListener('click', () => {
			const popoutWin = window;
			new TabletopCalibrationModal(this.app, this, popoutWin, () => {
				// After calibration, compute and send scale to player views based on current gm rect
				try {
					const rect = (viewport as any)._gmViewRect || (this as any)._gmViewRect || null;
					if (!rect) return;
					if ((this as any)._playerMapViews) {
						(this as any)._playerMapViews.forEach((pv: any) => {
							try {
								// Prefer calibration-derived scale so each grid cell maps to the
								// configured physical miniature base size on the player's screen.
								const cal = this.settings.tabletopCalibration;
								const gridSize = config?.gridSize || 0;
								if (cal && gridSize > 0) {
									// scale such that (gridSize * scale) CSS px == (miniBaseMm * pixelsPerMm)
									const calibratedScale = (cal.pixelsPerMm * cal.miniBaseMm) / gridSize;
									const safeScale = Math.max(0.001, Math.min(100, calibratedScale));
									if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(safeScale as number);
									else pv.tabletopScale = safeScale;
									if (typeof pv.syncCanvasToImage === 'function') pv.syncCanvasToImage();
								} else {
									// Fallback: preserve previous behavior (fit GM view rect into PV viewport)
									const bounds = getRotatedRectBoundingSize(rect);
									const wrap = pv?.mapContainer as HTMLElement | undefined;
									if (wrap && bounds.w > 0 && bounds.h > 0) {
										const r = wrap.getBoundingClientRect();
										const desiredScale = Math.max(0.001, Math.min(100, Math.min(r.width / bounds.w, r.height / bounds.h)));
										if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
										else pv.tabletopScale = desiredScale;
										if (typeof pv.syncCanvasToImage === 'function') pv.syncCanvasToImage();
									}
								}
							} catch (e) {}
						});
					}
				} catch (e) { console.warn('pvCalibrate callback error', e); }
			}).open();
		});

		// AoE shape picker sub-menu (shown when AoE tool is active, positioned right of button)
		const aoePicker = aoeBtn.createDiv({ cls: 'dnd-map-aoe-picker hidden' });
		const aoeShapes: { shape: 'circle' | 'cone' | 'square' | 'line'; icon: string; label: string }[] = [
			{ shape: 'circle', icon: '‚≠ï', label: 'Circle' },
			{ shape: 'cone', icon: 'üî∫', label: 'Cone' },
			{ shape: 'square', icon: '‚¨ú', label: 'Square' },
			{ shape: 'line', icon: '‚ûñ', label: 'Line' },
		];
		const aoeShapeButtons: Map<string, HTMLButtonElement> = new Map();
		aoeShapes.forEach(({ shape, icon, label }) => {
			const btn = aoePicker.createEl('button', {
				cls: 'dnd-map-aoe-shape-btn' + (shape === selectedAoeShape ? ' active' : ''),
				attr: { title: label }
			});
			btn.createEl('span', { text: icon });
			aoeShapeButtons.set(shape, btn);
			btn.addEventListener('click', () => {
				selectedAoeShape = shape;
				aoeShapeButtons.forEach((b) => b.removeClass('active'));
				btn.addClass('active');
			});
		});
		
		// Helper: show/hide grid tools (calibrate, move-grid) based on whether annotations exist
		const updateGridToolsVisibility = () => {
			const hasAnnotations = (config.highlights?.length > 0) || (config.markers?.length > 0) || (config.drawings?.length > 0) || (config.aoeEffects?.length > 0);
			const isHexcrawl = (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical');
			
			// For hexcrawl maps, highlights are stored as col/row so grid can still be moved
			// For non-hexcrawl, hide tools once annotations exist to prevent misalignment
			const shouldHideGridTools = hasAnnotations && !isHexcrawl;
			
			calibrateBtn.toggleClass('hidden', shouldHideGridTools);
			moveGridBtn.toggleClass('hidden', shouldHideGridTools);
			
			// PoI button only visible for hexcrawl maps
			poiBtn.toggleClass('hidden', !isHexcrawl);
			
			// If calibration was active and annotations appeared (non-hexcrawl), cancel it
			if (shouldHideGridTools && isCalibrating) {
				isCalibrating = false;
				calibrationPoint1 = null;
				calibrationPoint2 = null;
				calibrateBtn.removeClass('active');
			}
			// If move-grid tool was active and annotations appeared (non-hexcrawl), switch to pan
			if (shouldHideGridTools && activeTool === 'move-grid') {
				setActiveTool('pan');
			}
		};
		// Set initial visibility
		updateGridToolsVisibility();

		calibrateBtn.addEventListener('click', () => {
			if (isCalibrating) {
				// Cancel calibration
				isCalibrating = false;
				calibrationPoint1 = null;
				calibrationPoint2 = null;
				calibrateBtn.removeClass('active');
				setActiveTool('pan');
				redrawAnnotations();
				new Notice('Calibration cancelled');
			} else {
				// Start calibration ‚Äî set flag AFTER setActiveTool so it doesn't get cancelled
				setActiveTool('pan'); // Clear other tools first
				isCalibrating = true;
				calibrationPoint1 = null;
				calibrationPoint2 = null;
				calibrateBtn.addClass('active');
				viewport.style.cursor = 'crosshair';
				new Notice('Click two points on the map to measure one hex width');
			}
		});
		
		clearTunnelsBtn.addEventListener('click', () => {
			if (!config.tunnels || config.tunnels.length === 0) {
				new Notice('No tunnels to clear');
				return;
			}
			
			const tunnelCount = config.tunnels.length;
			config.tunnels = [];
			this.saveMapAnnotations(config, el);
			redrawAnnotations();
			if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
			new Notice(`Cleared ${tunnelCount} tunnel${tunnelCount === 1 ? '' : 's'}`);
		});

		// Grid size slider (flyout on move-grid button, visible when grid is enabled)
		const hasGrid = config.gridType && config.gridType !== 'none';
		
		// Create the slider flyout attached to the move-grid button
		const gridSliderFlyout = moveGridBtn.createDiv({ cls: 'dnd-map-grid-slider-flyout' });
		const gridSliderLabel = gridSliderFlyout.createEl('span', { 
			text: `${Math.round(config.gridSize * 10) / 10}px`, 
			cls: 'dnd-map-grid-slider-label' 
		});
		
		// Click label to manually enter a value
		gridSliderLabel.addEventListener('click', (e) => {
			e.stopPropagation();
			const input = document.createElement('input');
			input.type = 'number';
			input.value = String(Math.round(config.gridSize * 10) / 10);
			input.min = '10';
			input.max = '300';
			input.step = '0.1';
			input.className = 'dnd-map-grid-size-input';
			gridSliderLabel.replaceWith(input);
			input.focus();
			input.select();
			
			const applyValue = () => {
				let val = parseFloat(input.value);
				if (isNaN(val) || val < 10) val = 10;
				if (val > 300) val = 300;
				config.gridSize = val;
				gridSlider.value = String(val);
				gridSliderLabel.textContent = `${Math.round(val * 10) / 10}px`;
				input.replaceWith(gridSliderLabel);
				// Redraw grid
				redrawGridOverlays();
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
			};
			
			input.addEventListener('blur', applyValue);
			input.addEventListener('keydown', (ke) => {
				if (ke.key === 'Enter') { ke.preventDefault(); applyValue(); }
				if (ke.key === 'Escape') { input.replaceWith(gridSliderLabel); }
			});
			input.addEventListener('mousedown', (me) => me.stopPropagation());
		});
		
		const gridSlider = gridSliderFlyout.createEl('input', {
			type: 'range',
			cls: 'dnd-map-grid-slider-input',
			attr: { 
				min: '10', 
				max: '300', 
				value: String(config.gridSize),
				step: '0.0001'
			}
		});
		// Prevent slider interaction from triggering button click or map events
		gridSliderFlyout.addEventListener('mousedown', (e) => e.stopPropagation());
		gridSliderFlyout.addEventListener('click', (e) => e.stopPropagation());
		
		let gridSliderTimeout: ReturnType<typeof setTimeout> | null = null;
		gridSlider.addEventListener('input', (e) => {
			const newSize = parseFloat((e.target as HTMLInputElement).value);
			config.gridSize = newSize;
			gridSliderLabel.textContent = `${Math.round(newSize * 10) / 10}px`;
			// Redraw grid live
			redrawGridOverlays();
			redrawAnnotations();
			// Debounced save
			if (gridSliderTimeout) clearTimeout(gridSliderTimeout);
			gridSliderTimeout = setTimeout(() => {
				this.saveMapAnnotations(config, el);
			}, 500);
		});

		// Separator for color picker (hidden by default)
		const colorSeparator = toolbarContent.createDiv({ cls: 'dnd-map-tool-separator hidden' });

		// Color picker for highlights/drawings (hidden by default)
		const colorPicker = toolbarContent.createDiv({ cls: 'dnd-map-color-picker hidden' });
		const colorInput = colorPicker.createEl('input', { 
			type: 'color',
			cls: 'dnd-map-color-input',
			attr: { value: selectedColor }
		});
		colorInput.addEventListener('change', (e) => {
			selectedColor = (e.target as HTMLInputElement).value;
		});
		
		// Toolbar collapse/expand functionality
		toolbarHeader.addEventListener('click', () => {
			toolbar.toggleClass('collapsed', !toolbar.hasClass('collapsed'));
		});
		
		// Section header collapse/expand functionality
		visionSectionHeader.addEventListener('click', () => {
			const isCollapsed = visionSectionHeader.hasClass('collapsed');
			visionSectionHeader.toggleClass('collapsed', !isCollapsed);
			visionContent.toggleClass('collapsed', !isCollapsed);
		});

		tokenVisionSectionHeader.addEventListener('click', () => {
			const isCollapsed = tokenVisionSectionHeader.hasClass('collapsed');
			tokenVisionSectionHeader.toggleClass('collapsed', !isCollapsed);
			tokenVisionContent.toggleClass('collapsed', !isCollapsed);
		});
		
		setupSectionHeader.addEventListener('click', () => {
			const isCollapsed = setupSectionHeader.hasClass('collapsed');
			setupSectionHeader.toggleClass('collapsed', !isCollapsed);
			setupContent.toggleClass('collapsed', !isCollapsed);
		});

		// Add layer menu below toolbar - append to wrapper as sibling
		const layerMenu = toolbarWrapper.createDiv({ cls: 'dnd-map-layer-menu' });

		// Layer icons
		const layerIcons: Record<Layer, string> = {
			'Player': 'üë•',
			'Elevated': 'ü¶Ö',
			'Subterranean': 'üï≥Ô∏è',
			'DM': 'üé≤',
			'Background': 'üó∫Ô∏è'
		};
		
		// Create layer buttons
		const layers: Layer[] = ['Player', 'Elevated', 'Subterranean', 'DM', 'Background'];
		const layerButtons: Record<Layer, HTMLButtonElement> = {} as any;
		
		layers.forEach(layer => {
			const btn = layerMenu.createEl('button', {
				cls: 'dnd-map-layer-btn' + (layer === config.activeLayer ? ' active' : ''),
				attr: { 'data-layer': layer, 'title': layer }
			});
			btn.createEl('span', { text: layerIcons[layer], cls: 'dnd-map-layer-icon' });
			layerButtons[layer] = btn;
			
			btn.addEventListener('click', () => {
				// Toggle menu expansion
				if (layer === config.activeLayer) {
					layerMenu.toggleClass('expanded', !layerMenu.hasClass('expanded'));
				} else {
					// Switch active layer
					config.activeLayer = layer;
					layers.forEach(l => layerButtons[l].removeClass('active'));
					btn.addClass('active');
					layerMenu.removeClass('expanded');
					// Show/hide Vision section based on layer (only available on Background, hidden for hexcrawl)
					if (layer !== 'Background' || isHexcrawlMap) {
						visionSectionHeader.addClass('hidden');
						visionContent.addClass('hidden');
					} else {
						visionSectionHeader.removeClass('hidden');
						visionContent.removeClass('hidden');
						// Ensure section is expanded when switching to Background layer
						visionSectionHeader.removeClass('collapsed');
						visionContent.removeClass('collapsed');
						// Show individual vision tool buttons
						fogBtn.removeClass('hidden');
						wallsBtn.removeClass('hidden');
						lightsBtn.removeClass('hidden');
					}
					// Show/hide Tunnels section based on layer (only available on Subterranean, hidden for hexcrawl)
					if (layer !== 'Subterranean' || isHexcrawlMap) {
						tunnelsSectionHeader.addClass('hidden');
						tunnelsContent.addClass('hidden');
					} else {
						tunnelsSectionHeader.removeClass('hidden');
						tunnelsContent.removeClass('hidden');
						// Ensure section is expanded when switching to Subterranean layer
						tunnelsSectionHeader.removeClass('collapsed');
						tunnelsContent.removeClass('collapsed');
					}
					if (layer !== 'Background' && (activeTool === 'fog' || activeTool === 'walls' || activeTool === 'lights')) {
						setActiveTool('pan');
					}
					// Terrain/climate canvas follows Background layer visibility
					if (terrainCanvas) {
						terrainCanvas.style.opacity = layer === 'Background' ? '1' : '0.25';
					}
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					// Sync to player view on layer change (needed for fog/light visibility)
					if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
				}
			});
		});

		// For hexcrawl maps, hide Elevated and Subterranean layers
		if (isHexcrawlMap) {
			layerButtons['Elevated']?.addClass('hidden');
			layerButtons['Subterranean']?.addClass('hidden');

			// Wire up the hexcrawl bridge so HexcrawlView can read/write state
			// NOTE: setActiveTool is patched in later once the function is defined
			this._hexcrawlBridge = {
				config,
				el,
				save: () => this.saveMapAnnotations(config, el),
				redraw: () => { redrawTerrainLayer(); redrawAnnotations(); },
				setActiveTool: () => {},
			};
			this.refreshHexcrawlView();
		}

		// Add Player View button (top right)
		const playerViewBtn = viewport.createEl('button', {
			cls: 'dnd-map-player-view-btn',
			attr: { title: 'Open Player View' }
		});
		playerViewBtn.innerHTML = 'üëÅÔ∏è Player View';
		
		playerViewBtn.addEventListener('click', async () => {
            // Allow multiple player views; do not close existing player view windows
			
			// Open a popout window with the player map view
			const popoutLeaf = this.app.workspace.openPopoutLeaf({
				size: { width: 1920, height: 1080 }
			});
			
			await popoutLeaf.setViewState({
				type: PLAYER_MAP_VIEW_TYPE,
				active: true,
				state: {
					mapId: config.mapId || resourcePath,
					mapConfig: {
						markers: config.markers,
						drawings: config.drawings,
						highlights: config.highlights,
						aoeEffects: config.aoeEffects,
						fogOfWar: config.fogOfWar,
						walls: config.walls,
						lightSources: config.lightSources,
						tunnels: config.tunnels,
						poiReferences: config.poiReferences,
						gridType: config.gridType,
						gridSize: config.gridSize,
						gridOffsetX: config.gridOffsetX || 0,
						gridOffsetY: config.gridOffsetY || 0,
						scale: config.scale,
						name: config.name,
						isVideo: config.isVideo,
						type: config.type
					},
					imageResourcePath: resourcePath
				}
			});

      // After opening a player view, if we have a GM-side viewRect, push its position to the new view
      if ((viewport as any)._gmViewRect) {
        const rect = (viewport as any)._gmViewRect as any;
        // Delay a frame to allow player view to initialize
        setTimeout(() => {
          const pv = popoutLeaf.view as any;
          if (pv && typeof pv.setTabletopPanFromImageCoords === 'function') {
            try {
              // compute and set PV scale so GM indicator maps to PV viewport
              try {
                const bounds = getRotatedRectBoundingSize(rect);
                const wrap = (pv as any)?.mapContainer as HTMLElement | undefined;
                if (wrap && bounds.w > 0 && bounds.h > 0) {
                  const r = wrap.getBoundingClientRect();
                  const desiredScale = Math.max(0.001, Math.min(100, Math.min(r.width / bounds.w, r.height / bounds.h)));
                  try { console.log('[GM] setPVScale', { site: 'open-player-view', scale: desiredScale }); } catch (e) {}
                  if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
                  else (pv as any).tabletopScale = desiredScale;
                }
              } catch (e) { }

              // Send rectangle center to player view (center-based approach)
              const centerX = rect.x + rect.w / 2;
              const centerY = rect.y + rect.h / 2;
              try { console.log('[GM] sending pan', { centerX, centerY, source: 'GM', rect, zoom: config.scale }); } catch (e) {}
              pv.setTabletopPanFromImageCoords(centerX, centerY);
            } catch (e) { }
          }
        }, 50);
      }
			
      // Store sync function that pushes updates to all open player views
      (viewport as any)._syncPlayerView = () => {
        if (this._playerMapViews && this._playerMapViews.size > 0) {
          // Build drag ruler data if a marker is being dragged
          let dragRuler: { origin: { x: number; y: number }; current: { x: number; y: number } } | null = null;
          if (markerDragOrigin && draggingMarkerIndex >= 0 && config.markers[draggingMarkerIndex]) {
            dragRuler = {
              origin: { x: markerDragOrigin.x, y: markerDragOrigin.y },
              current: { x: config.markers[draggingMarkerIndex].position.x, y: config.markers[draggingMarkerIndex].position.y }
            };
          }
          // Build measure ruler data if ruler is active
          let measureRuler: { start: { x: number; y: number }; end: { x: number; y: number } } | null = null;
          if (rulerStart && rulerEnd && rulerComplete) {
            measureRuler = {
              start: { x: rulerStart.x, y: rulerStart.y },
              end: { x: rulerEnd.x, y: rulerEnd.y }
            };
          }
          // Build target distance ruler data if active
          let targetDistRuler: { origin: { x: number; y: number; elevation: number }; target: { x: number; y: number; elevation: number } } | null = null;
          if (targetDistOriginIdx >= 0 && targetDistTargetIdx >= 0 && config.markers[targetDistOriginIdx] && config.markers[targetDistTargetIdx]) {
            const oMarker = config.markers[targetDistOriginIdx];
            const tMarker = config.markers[targetDistTargetIdx];
            const oElev = (oMarker.elevation?.height || 0) - (oMarker.elevation?.depth || 0);
            const tElev = (tMarker.elevation?.height || 0) - (tMarker.elevation?.depth || 0);
            targetDistRuler = {
              origin: { x: oMarker.position.x, y: oMarker.position.y, elevation: oElev },
              target: { x: tMarker.position.x, y: tMarker.position.y, elevation: tElev }
            };
          }
          const payload: any = {
            markers: config.markers,
            drawings: config.drawings,
            highlights: config.highlights,
            aoeEffects: config.aoeEffects,
            fogOfWar: config.fogOfWar,
            walls: config.walls,
            lightSources: config.lightSources,
            tunnels: config.tunnels,
            poiReferences: config.poiReferences,
            gridType: config.gridType,
            gridSize: config.gridSize,
            gridOffsetX: config.gridOffsetX || 0,
            gridOffsetY: config.gridOffsetY || 0,
            scale: config.scale,
            name: config.name,
            type: config.type,
            dragRuler: dragRuler,
            measureRuler: measureRuler,
            targetDistRuler: targetDistRuler,
            selectedVisionTokenId: selectedVisionTokenId,
            hexTerrains: config.hexTerrains,
            hexClimates: config.hexClimates,
            hexcrawlState: config.hexcrawlState,
            hexcrawlRangeOverlay: (activeTool === 'hexcrawl-move' && config.hexcrawlState?.enabled && config.hexcrawlState?.partyPosition) ? {
              active: true,
              hoverHex: hexcrawlMoveHoverHex,
            } : null,
          };
          // Attach pending hexcrawl travel animation data (set by hexcrawl-move handler)
          if ((viewport as any)._pendingHexcrawlTravel) {
            payload.hexcrawlTravel = (viewport as any)._pendingHexcrawlTravel;
            (viewport as any)._pendingHexcrawlTravel = null;
          }
          const mapId = config.mapId || resourcePath;
          console.log('[GM] Syncing player views for mapId:', mapId);
          console.log('[GM] Payload:', payload);
          this._playerMapViews.forEach(view => {
            const viewMapId = (view as any).mapId;
            console.log('[Player View] has mapId:', viewMapId, 'comparing with:', mapId, 'match:', viewMapId === mapId);
            if (viewMapId === mapId) {
              console.log('[GM] Calling updateMapData on player view');
              try { 
                view.updateMapData(payload); 
                console.log('[GM] updateMapData completed successfully');
              } catch (e) { 
                console.error('Failed to update player view', e); 
              }
            }
          });
        }
      };
			
			// Initial sync after a short delay to ensure player view is ready
			setTimeout(() => {
				if ((viewport as any)._syncPlayerView) {
					console.log('[GM] Initial sync to player view');
					(viewport as any)._syncPlayerView();
				}
			}, 200);
			
			new Notice('Player view opened');
		});

		// State for zoom and pan
		let scale = 1;
		let translateX = 0;
		let translateY = 0;
		let isDragging = false;
		let startX = 0;
		let startY = 0;
		// Middle mouse button temporary pan state
		let previousToolBeforePan: 'pan' | 'select' | 'highlight' | 'draw' | 'ruler' | 'target-distance' | 'eraser' | 'move-grid' | 'marker' | 'aoe' | 'fog' | 'walls' | 'lights' | 'player-view' | 'poi' | 'terrain-paint' | 'climate-paint' | 'hexcrawl-move' | 'set-start-hex' | 'hex-desc' | null = null;
		let isTemporaryPan = false;
		let gridCanvas: HTMLCanvasElement | null = null;
		let terrainCanvas: HTMLCanvasElement | null = null;
		let annotationCanvas: HTMLCanvasElement | null = null;

		// Function to update transform
		const updateTransform = () => {
			mapWrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
		};

		// Function to convert screen coordinates to map coordinates (in natural image pixel space)
		const screenToMap = (screenX: number, screenY: number) => {
			const rect = viewport.getBoundingClientRect();
			// First get coordinates in displayed image space
			const displayX = (screenX - rect.left - translateX) / scale;
			const displayY = (screenY - rect.top - translateY) / scale;
			
			// Scale to natural image dimensions (for canvas drawing)
			const scaleX = img.naturalWidth / img.width;
			const scaleY = img.naturalHeight / img.height;
			const x = displayX * scaleX;
			const y = displayY * scaleY;
			
			return { x, y };
		};

		// Helper function to generate tunnel walls from path
		const generateTunnelWalls = (
			path: Array<{x: number, y: number}>,
			tunnelWidth: number
		): Array<{start: {x: number, y: number}, end: {x: number, y: number}}> => {
			if (!path || path.length < 2) return [];
			
			const walls: Array<{start: {x: number, y: number}, end: {x: number, y: number}}> = [];
			const halfWidth = tunnelWidth / 2;
			
			// Generate parallel walls along each segment of the path
			for (let i = 0; i < path.length - 1; i++) {
				const p1 = path[i];
				const p2 = path[i + 1];
				if (!p1 || !p2) continue;
				
				// Calculate perpendicular vector for this segment
				const dx = p2.x - p1.x;
				const dy = p2.y - p1.y;
				const len = Math.sqrt(dx * dx + dy * dy);
				
				if (len === 0) continue;
				
				// Normalized perpendicular vector (rotated 90 degrees)
				const perpX = -dy / len;
				const perpY = dx / len;
				
				// Calculate wall endpoints for this segment
				const leftStart = { x: p1.x + perpX * halfWidth, y: p1.y + perpY * halfWidth };
				const leftEnd = { x: p2.x + perpX * halfWidth, y: p2.y + perpY * halfWidth };
				const rightStart = { x: p1.x - perpX * halfWidth, y: p1.y - perpY * halfWidth };
				const rightEnd = { x: p2.x - perpX * halfWidth, y: p2.y - perpY * halfWidth };
				
				// Add left wall segment
				walls.push({ start: leftStart, end: leftEnd });
				
				// Add right wall segment
				walls.push({ start: rightStart, end: rightEnd });
			}
			
			// Add end caps to close the tunnel at entrance and exit
			if (path.length >= 2) {
				// Entrance cap
				const firstSegment = path[1];
				const firstPoint = path[0];
				if (firstSegment && firstPoint) {
					const dx = firstSegment.x - firstPoint.x;
					const dy = firstSegment.y - firstPoint.y;
					const len = Math.sqrt(dx * dx + dy * dy);
					if (len > 0) {
						const perpX = -dy / len;
						const perpY = dx / len;
						walls.push({
							start: { x: firstPoint.x + perpX * halfWidth, y: firstPoint.y + perpY * halfWidth },
							end: { x: firstPoint.x - perpX * halfWidth, y: firstPoint.y - perpY * halfWidth }
						});
					}
				}
				
				// Exit cap
				const lastIdx = path.length - 1;
				const lastPoint = path[lastIdx];
				const secondLastPoint = path[lastIdx - 1];
				if (lastPoint && secondLastPoint) {
					const dx = lastPoint.x - secondLastPoint.x;
					const dy = lastPoint.y - secondLastPoint.y;
					const len = Math.sqrt(dx * dx + dy * dy);
					if (len > 0) {
						const perpX = -dy / len;
						const perpY = dx / len;
						walls.push({
							start: { x: lastPoint.x + perpX * halfWidth, y: lastPoint.y + perpY * halfWidth },
							end: { x: lastPoint.x - perpX * halfWidth, y: lastPoint.y - perpY * halfWidth }
						});
					}
				}
			}
			
			return walls;
		};

		// Helper function to calculate distance from point to line segment
		const distanceToLineSegment = (px: number, py: number, x1: number, y1: number, x2: number, y2: number) => {
			const A = px - x1;
			const B = py - y1;
			const C = x2 - x1;
			const D = y2 - y1;
			
			const dot = A * C + B * D;
			const lenSq = C * C + D * D;
			let param = -1;
			
			if (lenSq !== 0) {
				param = dot / lenSq;
			}
			
			let xx, yy;
			
			if (param < 0) {
				xx = x1;
				yy = y1;
			} else if (param > 1) {
				xx = x2;
				yy = y2;
			} else {
				xx = x1 + param * C;
				yy = y1 + param * D;
			}
			
			const dx = px - xx;
			const dy = py - yy;
			return Math.sqrt(dx * dx + dy * dy);
		};

			// Helper: Get effective grid size (fixed single grid ‚Äî no pace scaling)
			const getEffectiveGridSize = () => {
				return config.gridSize;
			};

			// Function to get cell coordinates from pixel position (accounts for grid offset)
			const pixelToHex = (x: number, y: number) => {
				const ox = config.gridOffsetX || 0;
				const oy = config.gridOffsetY || 0;
				const effectiveSize = getEffectiveGridSize();
				
				if (config.gridType === 'hex-horizontal') {
					const horiz = effectiveSize;
					const size = (2/3) * horiz;
					const vert = Math.sqrt(3) * size;
					
					const col = Math.round((x - ox) / horiz);
					const row = Math.round(((y - oy) - ((col & 1) ? vert / 2 : 0)) / vert);
					return { col, row };
				} else if (config.gridType === 'hex-vertical') {
					const vert = effectiveSize;
					const size = (2/3) * vert;
					const horiz = Math.sqrt(3) * size;
					
					const row = Math.round((y - oy) / vert);
					const col = Math.round(((x - ox) - ((row & 1) ? horiz / 2 : 0)) / horiz);
					return { col, row };
				} else if (config.gridType === 'square') {
					const col = Math.floor((x - ox) / effectiveSize);
					const row = Math.floor((y - oy) / effectiveSize);
					return { col, row };
				}
				return { col: 0, row: 0 };
			};

			// Function to redraw grid overlays (single fixed grid)
			const redrawGridOverlays = () => {
				// Remove all existing grid overlays
				const existingOverlays = mapWrapper.querySelectorAll('.dnd-map-grid-overlay');
				existingOverlays.forEach(overlay => overlay.remove());
				gridCanvas = null;
				
				// Draw single grid overlay
				if (config.gridType && config.gridType !== 'none' && config.gridSize) {
					gridCanvas = this.drawGridOverlay(mapWrapper, img, config, config.gridOffsetX || 0, config.gridOffsetY || 0);
				}
			};

			// Function to redraw the terrain/climate background canvas
			const redrawTerrainLayer = () => {
				if (!terrainCanvas) return;
				const tctx = terrainCanvas.getContext('2d');
				if (!tctx) return;
				tctx.clearRect(0, 0, terrainCanvas.width, terrainCanvas.height);

				// Draw terrain hexes
				if (config.hexTerrains && config.hexTerrains.length > 0 && config.gridSize) {
					const ox = config.gridOffsetX || 0;
					const oy = config.gridOffsetY || 0;
					const effectiveGridSz = getEffectiveGridSize();
					config.hexTerrains.forEach((ht: HexTerrain) => {
						const def = TERRAIN_DEFINITIONS.find(d => d.id === ht.terrain);
						if (!def) return;
						if (config.gridType === 'hex-horizontal') {
							const horiz = effectiveGridSz;
							const size = (2/3) * horiz;
							const vert = Math.sqrt(3) * size;
							const colOffsetY = (ht.col & 1) ? vert / 2 : 0;
							const cx = ht.col * horiz + ox;
							const cy = ht.row * vert + colOffsetY + oy;
							drawTerrainHex(tctx, cx, cy, size, def, 'hex-horizontal');
						} else if (config.gridType === 'hex-vertical') {
							const vert = effectiveGridSz;
							const size = (2/3) * vert;
							const horiz = Math.sqrt(3) * size;
							const rowOffsetX = (ht.row & 1) ? horiz / 2 : 0;
							const cx = ht.col * horiz + rowOffsetX + ox;
							const cy = ht.row * vert + oy;
							drawTerrainHex(tctx, cx, cy, size, def, 'hex-vertical');
						}
					});
				}

				// Draw climate zone borders
				if (config.hexClimates && config.hexClimates.length > 0 && config.gridSize) {
					const ox = config.gridOffsetX || 0;
					const oy = config.gridOffsetY || 0;
					const effectiveGridSz = getEffectiveGridSize();
					config.hexClimates.forEach((hc: any) => {
						const cdef = CLIMATE_DEFINITIONS.find(d => d.id === hc.climate);
						if (!cdef) return;
						if (config.gridType === 'hex-horizontal') {
							const horiz = effectiveGridSz;
							const size = (2/3) * horiz;
							const vert = Math.sqrt(3) * size;
							const colOffsetY = (hc.col & 1) ? vert / 2 : 0;
							const cx = hc.col * horiz + ox;
							const cy = hc.row * vert + colOffsetY + oy;
							drawClimateHexBorder(tctx, cx, cy, size, cdef, 'hex-horizontal');
						} else if (config.gridType === 'hex-vertical') {
							const vert = effectiveGridSz;
							const size = (2/3) * vert;
							const horiz = Math.sqrt(3) * size;
							const rowOffsetX = (hc.row & 1) ? horiz / 2 : 0;
							const cx = hc.col * horiz + rowOffsetX + ox;
							const cy = hc.row * vert + oy;
							drawClimateHexBorder(tctx, cx, cy, size, cdef, 'hex-vertical');
						}
					});
				}
			};

			// Function to redraw annotations
			const redrawAnnotations = () => {
				console.log('redrawAnnotations called, annotationCanvas exists:', !!annotationCanvas);
				if (!annotationCanvas) return;
				const ctx = annotationCanvas.getContext('2d');
				console.log('Got canvas context:', !!ctx);
				if (!ctx) return;
				
				ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
				
				// Draw highlights
				if (config.highlights) {
					config.highlights.forEach((highlight: any) => {
						drawHighlight(ctx, highlight);
					});
				}

				// Draw PoI icons
				if (config.poiReferences) {
					config.poiReferences.forEach((poiRef: any) => {
						drawPoiIcon(ctx, poiRef);
					});
				}

				// Draw AoE effects
				if (config.aoeEffects) {
					config.aoeEffects.forEach((aoe: any) => {
						drawAoeEffect(ctx, aoe);
					});
				}
				
				// Draw light glow around markers that have lights attached
				if (config.markers) {
					const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
					config.markers.forEach((marker: any) => {
						if (marker.light && marker.light.bright !== undefined) {
							const brightRadiusPx = marker.light.bright * pixelsPerFoot;
							const dimRadiusPx = marker.light.dim * pixelsPerFoot;
							
							// Draw light glow behind marker
							if (brightRadiusPx > 0) {
								ctx.globalAlpha = 0.2;
								ctx.fillStyle = '#ffff88';
								ctx.beginPath();
								ctx.arc(marker.position.x, marker.position.y, brightRadiusPx, 0, Math.PI * 2);
								ctx.fill();
								ctx.globalAlpha = 1.0;
							}
							if (dimRadiusPx > 0) {
								ctx.globalAlpha = 0.1;
								ctx.fillStyle = '#aaaa44';
								ctx.beginPath();
								ctx.arc(marker.position.x, marker.position.y, brightRadiusPx + dimRadiusPx, 0, Math.PI * 2);
								ctx.fill();
								ctx.globalAlpha = 1.0;
							}
						}
					});
				}
				
				// Draw tunnel entrances and exits (below markers so tokens aren't covered)
				console.log('[Tunnel Debug GM Render] config.tunnels:', config.tunnels ? config.tunnels.length : 'undefined');
				if (config.tunnels && config.tunnels.length > 0) {
					const CREATURE_SIZE_SQUARES: Record<string, number> = {
						'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
					};
					
					config.tunnels.forEach((tunnel: any) => {
						console.log('[Tunnel Debug GM Render] Rendering tunnel:', tunnel.id, 'visible:', tunnel.visible, 'active:', tunnel.active, 'entrance:', tunnel.entrancePosition);
						if (!tunnel.visible) return;
						
						const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
						const radius = (squares * config.gridSize) / 2.5;
						
						// Draw entrance
						const entrance = tunnel.entrancePosition;
						ctx.save();
						ctx.globalAlpha = 0.7;
						
						// Draw dark circle for tunnel entrance
						ctx.fillStyle = '#1a1a1a';
						ctx.beginPath();
						ctx.arc(entrance.x, entrance.y, radius, 0, Math.PI * 2);
						ctx.fill();
						
						// Draw rocky border
						ctx.strokeStyle = '#654321';
						ctx.lineWidth = Math.max(3, radius * 0.15);
						ctx.stroke();
						
						// Add inner shadow effect
						const gradient = ctx.createRadialGradient(entrance.x, entrance.y, radius * 0.3, entrance.x, entrance.y, radius);
						gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
						gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
						ctx.fillStyle = gradient;
						ctx.fill();
						
						// Add tunnel entrance icon
						ctx.globalAlpha = 0.8;
						ctx.fillStyle = '#8B4513';
						ctx.font = `${Math.max(12, radius * 0.8)}px sans-serif`;
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						ctx.fillText('üï≥Ô∏è', entrance.x, entrance.y);
						
						ctx.restore();
						
						// Draw exit if tunnel is inactive (completed) and has a different exit position
						if (!tunnel.active && tunnel.path && tunnel.path.length > 1) {
							const exit = tunnel.path[tunnel.path.length - 1];
							// Only draw exit if it's different from entrance
							if (Math.abs(exit.x - entrance.x) > 5 || Math.abs(exit.y - entrance.y) > 5) {
								ctx.save();
								ctx.globalAlpha = 0.7;
								
								// Draw dark circle for tunnel exit
								ctx.fillStyle = '#1a1a1a';
								ctx.beginPath();
								ctx.arc(exit.x, exit.y, radius, 0, Math.PI * 2);
								ctx.fill();
								
								// Draw rocky border
								ctx.strokeStyle = '#654321';
								ctx.lineWidth = Math.max(3, radius * 0.15);
								ctx.stroke();
								
								// Add inner shadow effect
								const exitGradient = ctx.createRadialGradient(exit.x, exit.y, radius * 0.3, exit.x, exit.y, radius);
								exitGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
								exitGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
								ctx.fillStyle = exitGradient;
								ctx.fill();
								
								// Add tunnel exit icon
								ctx.globalAlpha = 0.8;
								ctx.fillStyle = '#8B4513';
								ctx.font = `${Math.max(12, radius * 0.8)}px sans-serif`;
								ctx.textAlign = 'center';
								ctx.textBaseline = 'middle';
								ctx.fillText('üï≥Ô∏è', exit.x, exit.y);
								
								console.log('[Tunnel Debug GM Render] Drew exit at:', exit);
								ctx.restore();
							}
						}
					});
				}
				
				// Draw token auras (behind markers)
				if (config.markers) {
					const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
					config.markers.forEach((marker: any) => {
						if (marker.auras && marker.auras.length > 0) {
							marker.auras.forEach((aura: any) => {
								const radiusPx = (aura.radius || 0) * pixelsPerFoot;
								if (radiusPx > 0) {
									ctx.globalAlpha = aura.opacity || 0.25;
									ctx.fillStyle = aura.color || '#ffcc00';
									ctx.beginPath();
									ctx.arc(marker.position.x, marker.position.y, radiusPx, 0, Math.PI * 2);
									ctx.fill();
									// Draw aura border
									ctx.globalAlpha = Math.min((aura.opacity || 0.25) + 0.3, 0.8);
									ctx.strokeStyle = aura.color || '#ffcc00';
									ctx.lineWidth = 2;
									ctx.stroke();
									ctx.globalAlpha = 1.0;
								}
							});
						}
					});
				}
				
				// Draw markers
				if (config.markers) {
					config.markers.forEach((marker: any) => {
						drawMarker(ctx, marker);
					});
				}
				
				// Draw tunnel paths (GM view only - shows where burrowed creatures traveled)
				// Only visible on Subterranean layer to avoid visual clutter
				if (config.tunnels && config.tunnels.length > 0 && config.activeLayer === 'Subterranean') {
					const CREATURE_SIZE_SQUARES: Record<string, number> = {
						'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
					};
					
					config.tunnels.forEach((tunnel: any) => {
						if (!tunnel.path || tunnel.path.length < 2) return;
						
					// Use stored tunnel width, or calculate as (size + 0.5) * gridSize
					const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
					const tunnelWidth = tunnel.tunnelWidth || (squares + 0.5) * config.gridSize;
						ctx.strokeStyle = '#2a2a2a';
						ctx.lineWidth = tunnelWidth;
						ctx.lineCap = 'round';
						ctx.lineJoin = 'round';
						
						// Draw tunnel path as a thick line
						ctx.beginPath();
						ctx.moveTo(tunnel.path[0].x, tunnel.path[0].y);
						for (let i = 1; i < tunnel.path.length; i++) {
							ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
						}
						ctx.stroke();
						
						// Draw border for tunnel corridor
						ctx.globalAlpha = 0.7;
						ctx.strokeStyle = '#654321';
						ctx.lineWidth = tunnelWidth + 4;
						ctx.beginPath();
						ctx.moveTo(tunnel.path[0].x, tunnel.path[0].y);
						for (let i = 1; i < tunnel.path.length; i++) {
							ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
						}
						ctx.stroke();
						
						// Draw inner tunnel path (darker)
						ctx.globalAlpha = 0.8;
						ctx.strokeStyle = '#1a1a1a';
						ctx.lineWidth = tunnelWidth * 0.7;
						ctx.beginPath();
						ctx.moveTo(tunnel.path[0].x, tunnel.path[0].y);
						for (let i = 1; i < tunnel.path.length; i++) {
							ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
						}
						ctx.stroke();
						
						ctx.restore();
					});
				}
				
				// Draw drawings
				if (config.drawings) {
					config.drawings.forEach((drawing: any) => {
						drawDrawing(ctx, drawing);
					});
				}

				// Draw AoE preview (before sync so it doesn't show in player view until placed)
				if (activeTool === 'aoe' && aoeOrigin && aoePreviewEnd) {
					drawAoeShape(ctx, aoeOrigin, aoePreviewEnd, selectedAoeShape, selectedColor, true, !!pendingAoeAnchorMarkerId);
				}
				
				// NOTE: _syncPlayerView() is now only called when map data actually changes
				// (markers added/moved, fog updated, etc.), not on every redraw.
				// This prevents the infinite sync loop that was causing performance issues.

				// Draw Fog of War (GM view: semi-transparent)
				if (config.fogOfWar && config.fogOfWar.enabled) {
					drawFogOfWar(ctx, annotationCanvas.width, annotationCanvas.height, false);
				}
				// Draw fog preview during drag
				if (activeTool === 'fog') {
					if (fogDragStart && fogDragEnd) {
						drawFogPreview(ctx);
					}
					if (fogPolygonPoints.length > 0) {
						drawFogPolygonPreview(ctx);
					}
				}

				// Draw Dynamic Lighting Walls (only on Background layer)
				if (config.activeLayer === 'Background' && config.walls && config.walls.length > 0) {
					config.walls.forEach((wall: any) => {
						const wallType = wall.type || 'wall';
						const wallDef = WALL_TYPES[wallType as WallType] || WALL_TYPES.wall;
						const isOpen = wall.open === true;
						
						ctx.strokeStyle = wallDef.color;
						ctx.lineWidth = 4;
						ctx.lineCap = 'round';
						
						// Set line dash based on style
						if (wallDef.style === 'dashed') {
							ctx.setLineDash([10, 6]);
						} else if (wallDef.style === 'dotted') {
							ctx.setLineDash([3, 6]);
						} else {
							ctx.setLineDash([]);
						}
						
						// Calculate wall segment properties
						const dx = wall.end.x - wall.start.x;
						const dy = wall.end.y - wall.start.y;
						const length = Math.sqrt(dx * dx + dy * dy);
						const angle = Math.atan2(dy, dx);
						const midX = (wall.start.x + wall.end.x) / 2;
						const midY = (wall.start.y + wall.end.y) / 2;
						const isDraggingThis = draggingWallIndex === config.walls.indexOf(wall);
						
						// Draw selection indicator if dragging
						if (isDraggingThis) {
							ctx.strokeStyle = '#00ff00';
							ctx.lineWidth = 2;
							ctx.setLineDash([4, 4]);
							const selPad = 12;
							ctx.strokeRect(
								Math.min(wall.start.x, wall.end.x) - selPad,
								Math.min(wall.start.y, wall.end.y) - selPad,
								Math.abs(dx) + selPad * 2,
								Math.abs(dy) + selPad * 2
							);
							ctx.setLineDash([]);
						}
						
						// Draw based on type
						if (wallDef.style === 'door') {
							// Roll20-style door: rectangular door frame with swing arc
							const doorWidth = Math.max(length, 20);
							const doorHeight = 8;
							
							ctx.save();
							ctx.translate(midX, midY);
							ctx.rotate(angle);
							
							if (isOpen) {
								// Open door: draw frame outline, door swung open
								// Frame (empty rectangle)
								ctx.strokeStyle = '#654321';
								ctx.lineWidth = 2;
								ctx.strokeRect(-doorWidth / 2, -doorHeight / 2, doorWidth, doorHeight);
								
								// Door panel swung open (perpendicular)
								ctx.fillStyle = '#8B6914';
								ctx.globalAlpha = 0.7;
								ctx.save();
								ctx.rotate(Math.PI / 2); // Rotate 90 degrees for open
								ctx.fillRect(-doorWidth / 2, -doorHeight / 2 - doorWidth / 2, doorWidth, doorHeight);
								ctx.strokeStyle = '#654321';
								ctx.strokeRect(-doorWidth / 2, -doorHeight / 2 - doorWidth / 2, doorWidth, doorHeight);
								ctx.restore();
								ctx.globalAlpha = 1.0;
								
								// Swing arc
								ctx.strokeStyle = '#888888';
								ctx.lineWidth = 1;
								ctx.setLineDash([4, 4]);
								ctx.beginPath();
								ctx.arc(-doorWidth / 2, 0, doorWidth, 0, -Math.PI / 2, true);
								ctx.stroke();
								ctx.setLineDash([]);
							} else {
								// Closed door: solid door panel in frame
								ctx.fillStyle = '#8B4513';
								ctx.fillRect(-doorWidth / 2, -doorHeight / 2, doorWidth, doorHeight);
								
								// Door frame
								ctx.strokeStyle = '#654321';
								ctx.lineWidth = 2;
								ctx.strokeRect(-doorWidth / 2, -doorHeight / 2, doorWidth, doorHeight);
								
								// Door handle
								ctx.fillStyle = '#FFD700';
								ctx.beginPath();
								ctx.arc(doorWidth / 2 - 6, 0, 3, 0, Math.PI * 2);
								ctx.fill();
								
								// Swing arc hint
								ctx.strokeStyle = '#888888';
								ctx.lineWidth = 1;
								ctx.setLineDash([4, 4]);
								ctx.globalAlpha = 0.4;
								ctx.beginPath();
								ctx.arc(-doorWidth / 2, 0, doorWidth, 0, -Math.PI / 2, true);
								ctx.stroke();
								ctx.setLineDash([]);
								ctx.globalAlpha = 1.0;
							}
							
							ctx.restore();
							
						} else if (wallDef.style === 'window') {
							// Roll20-style window: rectangular pane with cross-hatching
							const windowWidth = Math.max(length, 16);
							const windowHeight = 8;
							
							ctx.save();
							ctx.translate(midX, midY);
							ctx.rotate(angle);
							
							// Window frame (outer)
							ctx.fillStyle = '#4488aa';
							ctx.globalAlpha = 0.4;
							ctx.fillRect(-windowWidth / 2, -windowHeight / 2, windowWidth, windowHeight);
							ctx.globalAlpha = 1.0;
							
							// Window frame border
							ctx.strokeStyle = '#336688';
							ctx.lineWidth = 2;
							ctx.strokeRect(-windowWidth / 2, -windowHeight / 2, windowWidth, windowHeight);
							
							// Window panes (vertical dividers)
							ctx.strokeStyle = '#557799';
							ctx.lineWidth = 1;
							// Center divider
							ctx.beginPath();
							ctx.moveTo(0, -windowHeight / 2);
							ctx.lineTo(0, windowHeight / 2);
							ctx.stroke();
							
							// Cross pattern for glass effect
							ctx.strokeStyle = '#aaccdd';
							ctx.globalAlpha = 0.5;
							ctx.lineWidth = 0.5;
							const crossSize = 4;
							for (let cx = -windowWidth / 2 + crossSize; cx < windowWidth / 2; cx += crossSize * 2) {
								ctx.beginPath();
								ctx.moveTo(cx, -windowHeight / 2);
								ctx.lineTo(cx, windowHeight / 2);
								ctx.stroke();
							}
							ctx.globalAlpha = 1.0;
							
							ctx.restore();
							
						} else {
							// Standard wall/secret/invisible/terrain - just draw line
							ctx.beginPath();
							ctx.moveTo(wall.start.x, wall.start.y);
							ctx.lineTo(wall.end.x, wall.end.y);
							ctx.stroke();
						}
						
						ctx.setLineDash([]);
					});
				}
				// Draw wall preview (chain drawing)
				if (activeTool === 'walls' && wallPoints.length > 0) {
					const previewWallDef = WALL_TYPES[selectedWallType];
					ctx.strokeStyle = previewWallDef.color;
					ctx.lineWidth = 4;
					ctx.lineCap = 'round';
					ctx.setLineDash([5, 5]);
					// Draw segments between points
					for (let i = 0; i < wallPoints.length - 1; i++) {
						ctx.beginPath();
						ctx.moveTo(wallPoints[i]!.x, wallPoints[i]!.y);
						ctx.lineTo(wallPoints[i + 1]!.x, wallPoints[i + 1]!.y);
						ctx.stroke();
					}
					// Draw preview line to cursor
					if (wallPreviewPos) {
						ctx.beginPath();
						ctx.moveTo(wallPoints[wallPoints.length - 1]!.x, wallPoints[wallPoints.length - 1]!.y);
						ctx.lineTo(wallPreviewPos.x, wallPreviewPos.y);
						ctx.stroke();
					}
					ctx.setLineDash([]);
					// Draw points
					ctx.fillStyle = previewWallDef.color;
					wallPoints.forEach((p: any) => {
						ctx.beginPath();
						ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
						ctx.fill();
					});
				}

				// Draw Dynamic Lighting (only on Background layer)
				if (config.activeLayer === 'Background' && config.lightSources && config.lightSources.length > 0) {
					// Calculate pixels per foot based on grid settings
					const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
					
					config.lightSources.forEach((light: any, idx: number) => {
						const isActive = light.active !== false; // Default to active
						const isDragging = draggingLightIndex === idx;
						
						// Convert feet to pixels
						const brightRadiusPx = light.bright * pixelsPerFoot;
						const dimRadiusPx = light.dim * pixelsPerFoot;
						
						// Only draw light radii if the light is active
						if (isActive) {
							// Draw light radius (bright light) - subtle on Background layer
							if (brightRadiusPx > 0) {
								ctx.globalAlpha = 0.12;
								ctx.fillStyle = '#ffff88';
								ctx.beginPath();
								ctx.arc(light.x, light.y, brightRadiusPx, 0, Math.PI * 2);
								ctx.fill();
								ctx.globalAlpha = 1.0;
							}
							
							// Draw dim light radius - very subtle on Background layer
							if (dimRadiusPx > 0) {
								ctx.globalAlpha = 0.06;
								ctx.fillStyle = '#aaaa44';
								ctx.beginPath();
								ctx.arc(light.x, light.y, brightRadiusPx + dimRadiusPx, 0, Math.PI * 2);
								ctx.fill();
								ctx.globalAlpha = 1.0;
							}
							
							// Draw cone for bullseye lantern (showing direction) - subtle
							if (light.cone) {
								const direction = (light.direction || 0) * Math.PI / 180; // Convert degrees to radians
								const coneAngle = Math.PI / 6; // 30 degree half-angle (60 degree total cone)
								
								ctx.globalAlpha = 0.1;
								ctx.fillStyle = '#ffffff';
								ctx.beginPath();
								ctx.moveTo(light.x, light.y);
								ctx.arc(light.x, light.y, brightRadiusPx, direction - coneAngle, direction + coneAngle);
								ctx.closePath();
								ctx.fill();
								ctx.globalAlpha = 1.0;
							}
						}
						
// Draw dashed selection rectangle to show clickable area
							const selectionPadding = 15; // Same as lightClickRadius
							ctx.globalAlpha = 0.5;
							ctx.strokeStyle = isDragging ? '#00ff00' : '#888888';
							ctx.lineWidth = 1;
							ctx.setLineDash([4, 4]);
							ctx.strokeRect(
								light.x - selectionPadding,
								light.y - selectionPadding,
								selectionPadding * 2,
								selectionPadding * 2
							);
							ctx.setLineDash([]);
							ctx.globalAlpha = 1.0;
							
							// Draw light source icon (subtle light bulb) - always visible for editing
						const iconRadius = 12;
						ctx.globalAlpha = isDragging ? 1.0 : (isActive ? 0.8 : 0.4);
						
						// Draw bulb body (circle)
						ctx.fillStyle = isActive ? '#ffdd44' : '#666666';
						ctx.strokeStyle = isDragging ? '#00ff00' : (isActive ? '#ff8800' : '#444444');
						ctx.lineWidth = isDragging ? 3 : 2;
						ctx.beginPath();
						ctx.arc(light.x, light.y - 2, iconRadius * 0.6, 0, Math.PI * 2);
						ctx.fill();
						ctx.stroke();
						
						// Draw bulb base (small rectangle)
						ctx.fillStyle = isActive ? '#ccaa33' : '#555555';
						ctx.fillRect(light.x - 4, light.y + 4, 8, 5);
						
						// Draw light rays or direction arrow if active
						if (isActive) {
							ctx.lineWidth = 1.5;
							const rayOffset = iconRadius * 0.8;
							
							// If cone light (bullseye), draw direction arrow instead of rays
							if (light.cone) {
								const direction = (light.direction || 0) * Math.PI / 180;
								const arrowLength = 18;
								const arrowHeadSize = 6;
								
								ctx.strokeStyle = '#ff6600';
								ctx.fillStyle = '#ff6600';
								ctx.lineWidth = 2;
								
								// Arrow shaft
								const startX = light.x + Math.cos(direction) * rayOffset;
								const startY = light.y - 2 + Math.sin(direction) * rayOffset;
								const endX = light.x + Math.cos(direction) * (rayOffset + arrowLength);
								const endY = light.y - 2 + Math.sin(direction) * (rayOffset + arrowLength);
								
								ctx.beginPath();
								ctx.moveTo(startX, startY);
								ctx.lineTo(endX, endY);
								ctx.stroke();
								
								// Arrow head
								ctx.beginPath();
								ctx.moveTo(endX, endY);
								ctx.lineTo(
									endX - Math.cos(direction - Math.PI / 6) * arrowHeadSize,
									endY - Math.sin(direction - Math.PI / 6) * arrowHeadSize
								);
								ctx.lineTo(
									endX - Math.cos(direction + Math.PI / 6) * arrowHeadSize,
									endY - Math.sin(direction + Math.PI / 6) * arrowHeadSize
								);
								ctx.closePath();
								ctx.fill();
							} else {
								// Regular rays for non-cone lights
								ctx.strokeStyle = '#ffff88';
								const rayLength = 6;
								for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
									ctx.beginPath();
									ctx.moveTo(
										light.x + Math.cos(angle) * rayOffset,
										light.y - 2 + Math.sin(angle) * rayOffset
									);
									ctx.lineTo(
										light.x + Math.cos(angle) * (rayOffset + rayLength),
										light.y - 2 + Math.sin(angle) * (rayOffset + rayLength)
									);
									ctx.stroke();
								}
							}
						}
						
						ctx.globalAlpha = 1.0;
					});
				}

        // Draw GM-side player view rectangle if present (rotated to match player orientation)
        try {
          const gmRect = (this as any)._gmViewRect || (viewport as any)._gmViewRect;
          if (gmRect && gmRect.w && gmRect.h) {
            ctx.save();
            
            const rotation = gmRect.rotation || 0;
            const centerX = gmRect.x + gmRect.w / 2;
            const centerY = gmRect.y + gmRect.h / 2;
            
            // Draw the indicator with rotation. The sign here determines visual alignment:
            // +rotation: rotates indicator same direction as player view (image rotation)
            // -rotation: rotates indicator opposite direction (viewport rotation)
            // Current: using +rotation - test to verify correct alignment with player viewport
            ctx.translate(centerX, centerY);
            ctx.rotate(((rotation || 0) * Math.PI) / 180);
            
            // Draw rotated rectangle (centered at origin)
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(-gmRect.w / 2, -gmRect.h / 2, gmRect.w, gmRect.h);
            
            // Draw rotation indicator arrow (pointing to "up" direction of player view)
            const arrowLen = Math.min(gmRect.w, gmRect.h) * 0.12;
            ctx.strokeStyle = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            // Arrow shaft pointing up (this shows which way is "up" on the player screen)
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -arrowLen);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(0, -arrowLen);
            ctx.lineTo(-arrowLen * 0.3, -arrowLen * 0.7);
            ctx.lineTo(arrowLen * 0.3, -arrowLen * 0.7);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
          }
        } catch (e) { }
				
				// Draw hexcrawl party position marker (visible on Player layer for GM)
				if (config.hexcrawlState && config.hexcrawlState.enabled && config.hexcrawlState.partyPosition &&
					(config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') &&
					(config.type === 'world' || config.type === 'regional')) {
					const hcPos = config.hexcrawlState.partyPosition;
					const ox = config.gridOffsetX || 0;
					const oy = config.gridOffsetY || 0;
					const effectiveGridSz = getEffectiveGridSize();
					let ppx: number, ppy: number;
					if (config.gridType === 'hex-horizontal') {
						const horiz = effectiveGridSz;
						const size = (2/3) * horiz;
						const vert = Math.sqrt(3) * size;
						const colOffsetY = (hcPos.col & 1) ? vert / 2 : 0;
						ppx = hcPos.col * horiz + ox;
						ppy = hcPos.row * vert + colOffsetY + oy;
					} else {
						const vert = effectiveGridSz;
						const size = (2/3) * vert;
						const horiz = Math.sqrt(3) * size;
						const rowOffsetX = (hcPos.row & 1) ? horiz / 2 : 0;
						ppx = hcPos.col * horiz + rowOffsetX + ox;
						ppy = hcPos.row * vert + oy;
					}
					const hexSz = (2/3) * effectiveGridSz;
					const ir = hexSz * 0.55;

					// Outer glow
					ctx.save();
					ctx.globalAlpha = 1.0;
					const gmGlow = ctx.createRadialGradient(ppx, ppy, ir * 0.3, ppx, ppy, ir * 1.6);
					gmGlow.addColorStop(0, 'rgba(255, 180, 50, 0.6)');
					gmGlow.addColorStop(0.6, 'rgba(255, 140, 30, 0.2)');
					gmGlow.addColorStop(1, 'rgba(255, 180, 50, 0)');
					ctx.fillStyle = gmGlow;
					ctx.beginPath();
					ctx.arc(ppx, ppy, ir * 1.6, 0, Math.PI * 2);
					ctx.fill();
					ctx.restore();

					// Solid circle background
					ctx.save();
					ctx.globalAlpha = 1.0;
					ctx.fillStyle = 'rgba(40, 30, 15, 0.92)';
					ctx.beginPath();
					ctx.arc(ppx, ppy, ir, 0, Math.PI * 2);
					ctx.fill();
					ctx.strokeStyle = '#c8a85c';
					ctx.lineWidth = 3;
					ctx.stroke();
					ctx.restore();

					// Campfire emoji
					ctx.save();
					ctx.globalAlpha = 1.0;
					ctx.font = `${Math.round(ir * 1.3)}px sans-serif`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText('üèïÔ∏è', ppx, ppy);
					ctx.restore();
				}

				// Draw hexcrawl travel range overlay (when travel-to-hex tool is active)
				if (activeTool === 'hexcrawl-move' && config.hexcrawlState && config.hexcrawlState.enabled &&
					config.hexcrawlState.partyPosition &&
					(config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') &&
					(config.type === 'world' || config.type === 'regional')) {
					const hcState = config.hexcrawlState;
					const partyPos = hcState.partyPosition;
					const tracker = new HexcrawlTracker(hcState, config.hexTerrains || [], config.hexClimates || []);
					const remaining = tracker.getRemainingMovement();
					const ox = config.gridOffsetX || 0;
					const oy = config.gridOffsetY || 0;
					const effectiveGridSz = getEffectiveGridSize();

					// Helper to get hex pixel center
					const hexCenter = (col: number, row: number): { x: number; y: number } => {
						if (config.gridType === 'hex-horizontal') {
							const horiz = effectiveGridSz;
							const size = (2 / 3) * horiz;
							const vert = Math.sqrt(3) * size;
							const colOffsetY = (col & 1) ? vert / 2 : 0;
							return { x: col * horiz + ox, y: row * vert + colOffsetY + oy };
						} else {
							const vert = effectiveGridSz;
							const size = (2 / 3) * vert;
							const horiz = Math.sqrt(3) * size;
							const rowOffsetX = (row & 1) ? horiz / 2 : 0;
							return { x: col * horiz + rowOffsetX + ox, y: row * vert + oy };
						}
					};
					const hexSize = (2 / 3) * effectiveGridSz;

					// Draw green fill for adjacent reachable hexes (you can only move one hex at a time)
					ctx.save();
					for (let dc = -1; dc <= 1; dc++) {
						for (let dr = -1; dr <= 1; dr++) {
							const c = partyPos.col + dc;
							const r = partyPos.row + dr;
							if (c < 0 || r < 0) continue;
							if (c === partyPos.col && r === partyPos.row) continue;
							const dist = hexDistance(partyPos.col, partyPos.row, c, r);
							if (dist !== 1) continue;
							const hexCost = tracker.getMovementCostForHex(c, r);
							if (hexCost <= remaining) {
								// Adjacent + affordable: green tint
								const center = hexCenter(c, r);
								ctx.fillStyle = 'rgba(0, 200, 80, 0.18)';
								ctx.strokeStyle = 'rgba(0, 200, 80, 0.35)';
								ctx.lineWidth = 1.5;
								if (config.gridType === 'hex-horizontal') {
									this.drawFilledHexFlat(ctx, center.x, center.y, hexSize);
								} else {
									this.drawFilledHexPointy(ctx, center.x, center.y, hexSize);
								}
							}
						}
					}
					ctx.restore();

					// Draw hover highlight: green if adjacent + affordable, red if not
					if (hexcrawlMoveHoverHex) {
						const hCol = hexcrawlMoveHoverHex.col;
						const hRow = hexcrawlMoveHoverHex.row;
						if (!(hCol === partyPos.col && hRow === partyPos.row)) {
							const dist = hexDistance(partyPos.col, partyPos.row, hCol, hRow);
							const hexCost = tracker.getMovementCostForHex(hCol, hRow);
							const canMove = dist === 1 && hexCost <= remaining;
							const center = hexCenter(hCol, hRow);
							ctx.save();
							ctx.fillStyle = canMove ? 'rgba(0, 220, 80, 0.38)' : 'rgba(220, 40, 30, 0.35)';
							ctx.strokeStyle = canMove ? 'rgba(0, 220, 80, 0.7)' : 'rgba(220, 40, 30, 0.65)';
							ctx.lineWidth = 2.5;
							if (config.gridType === 'hex-horizontal') {
								this.drawFilledHexFlat(ctx, center.x, center.y, hexSize);
							} else {
								this.drawFilledHexPointy(ctx, center.x, center.y, hexSize);
							}
							ctx.restore();
						}
					}
				}

				// Draw marker drag ruler
				if (markerDragOrigin && draggingMarkerIndex >= 0) {
					const draggedMarker = config.markers[draggingMarkerIndex];
					const currentPos = draggedMarker.position;
					
					// Draw tunnel preview if marker is actively burrowing
					if (draggedMarker.elevation?.isBurrowing && draggedMarker.elevation?.leaveTunnel && config.tunnels) {
						const activeTunnel = config.tunnels.find((t: any) => 
							t.creatorMarkerId === draggedMarker.id && t.active
						);
						if (activeTunnel && activeTunnel.path.length > 0) {
							const CREATURE_SIZE_SQUARES: Record<string, number> = {
								'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
							};
							const mDef = draggedMarker.markerId ? this.markerLibrary.getMarker(draggedMarker.markerId) : null;
							const squares = mDef?.creatureSize ? CREATURE_SIZE_SQUARES[mDef.creatureSize] || 1 : 1;
							const tunnelWidth = (squares * config.gridSize) / 2;
							
							ctx.save();
							ctx.globalAlpha = 0.6;
							ctx.strokeStyle = '#8B4513';
							ctx.lineWidth = tunnelWidth + 4;
							ctx.lineCap = 'round';
							ctx.lineJoin = 'round';
							ctx.setLineDash([10, 5]);
							
							// Draw preview line from last path point to current position
							const lastPoint = activeTunnel.path[activeTunnel.path.length - 1];
							ctx.beginPath();
							ctx.moveTo(lastPoint.x, lastPoint.y);
							ctx.lineTo(currentPos.x, currentPos.y);
							ctx.stroke();
							
							ctx.restore();
						}
					}
					
					ctx.strokeStyle = '#ffff00';
					ctx.lineWidth = 4;
					ctx.setLineDash([8, 4]);
					ctx.beginPath();
					ctx.moveTo(markerDragOrigin.x, markerDragOrigin.y);
					ctx.lineTo(currentPos.x, currentPos.y);
					ctx.stroke();
					ctx.setLineDash([]);
					
					// Draw measurement with outline for visibility
					const distance = Math.sqrt(
						Math.pow(currentPos.x - markerDragOrigin.x, 2) + 
						Math.pow(currentPos.y - markerDragOrigin.y, 2)
					);
					const gridDistance = distance / config.gridSize;
					const realDistance = gridDistance * config.scale.value;
					const textX = (markerDragOrigin.x + currentPos.x) / 2;
					const textY = (markerDragOrigin.y + currentPos.y) / 2 - 10;
					const text = `${realDistance.toFixed(1)} ${config.scale.unit}`;
					
					ctx.font = 'bold 18px sans-serif';
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					
					// Draw text outline (black) for contrast
					ctx.strokeStyle = '#000000';
					ctx.lineWidth = 4;
					ctx.strokeText(text, textX, textY);
					
					// Draw text fill (yellow)
					ctx.fillStyle = '#ffff00';
					ctx.fillText(text, textX, textY);
				}
				
				// Draw active ruler
				if (rulerStart && rulerEnd) {
					ctx.strokeStyle = '#ffff00';
					ctx.lineWidth = 4;
					ctx.setLineDash([8, 4]);
					ctx.beginPath();
					ctx.moveTo(rulerStart.x, rulerStart.y);
					ctx.lineTo(rulerEnd.x, rulerEnd.y);
					ctx.stroke();
					ctx.setLineDash([]);
					
					// Draw measurement with outline for visibility
					const distance = Math.sqrt(
						Math.pow(rulerEnd.x - rulerStart.x, 2) + 
						Math.pow(rulerEnd.y - rulerStart.y, 2)
					);
					const gridDistance = distance / config.gridSize;
					const realDistance = gridDistance * config.scale.value;
					const textX = (rulerStart.x + rulerEnd.x) / 2;
					const textY = (rulerStart.y + rulerEnd.y) / 2 - 10;
					const text = `${realDistance.toFixed(1)} ${config.scale.unit}`;
					
					ctx.font = 'bold 18px sans-serif';
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					
					// Draw text outline (black) for contrast
					ctx.strokeStyle = '#000000';
					ctx.lineWidth = 4;
					ctx.strokeText(text, textX, textY);
					
					// Draw text fill (yellow)
					ctx.fillStyle = '#ffff00';
					ctx.fillText(text, textX, textY);
				}
				
				// Draw target distance measurement between two tokens
				if (targetDistOriginIdx >= 0 && config.markers[targetDistOriginIdx]) {
					const originMarker = config.markers[targetDistOriginIdx];
					const originPos = originMarker.position;
					
					// Draw origin token highlight ring
					const originDef = originMarker.markerId ? this.markerLibrary.getMarker(originMarker.markerId) : null;
					const originRadius = originDef ? getMarkerRadius(originDef) : 15;
					ctx.save();
					ctx.strokeStyle = '#00ffff';
					ctx.lineWidth = 3;
					ctx.setLineDash([6, 3]);
					ctx.beginPath();
					ctx.arc(originPos.x, originPos.y, originRadius + 4, 0, Math.PI * 2);
					ctx.stroke();
					ctx.setLineDash([]);
					ctx.restore();
					
					if (targetDistTargetIdx >= 0 && config.markers[targetDistTargetIdx]) {
						const targetMarker = config.markers[targetDistTargetIdx];
						const targetPos = targetMarker.position;
						
						// Draw target token highlight ring
						const targetDef = targetMarker.markerId ? this.markerLibrary.getMarker(targetMarker.markerId) : null;
						const targetRadius = targetDef ? getMarkerRadius(targetDef) : 15;
						ctx.save();
						ctx.strokeStyle = '#00ffff';
						ctx.lineWidth = 3;
						ctx.setLineDash([6, 3]);
						ctx.beginPath();
						ctx.arc(targetPos.x, targetPos.y, targetRadius + 4, 0, Math.PI * 2);
						ctx.stroke();
						ctx.setLineDash([]);
						ctx.restore();
						
						// Calculate D&D 5e RAW distance (5ft increments) with elevation
						const dx = targetPos.x - originPos.x;
						const dy = targetPos.y - originPos.y;
						const horizontalPixelDist = Math.sqrt(dx * dx + dy * dy);
						const horizontalGridDist = horizontalPixelDist / config.gridSize;
						const horizontalFeet = horizontalGridDist * config.scale.value;
						
						// Get elevation difference in feet
						const originElevation = originMarker.elevation;
						const targetElevation = targetMarker.elevation;
						const originHeight = (originElevation?.height || 0) - (originElevation?.depth || 0);
						const targetHeight = (targetElevation?.height || 0) - (targetElevation?.depth || 0);
						const verticalFeet = Math.abs(targetHeight - originHeight);
						
						// 3D distance using Pythagorean theorem, rounded to nearest 5ft (D&D 5e)
						const totalFeetRaw = Math.sqrt(horizontalFeet * horizontalFeet + verticalFeet * verticalFeet);
						const totalFeet = Math.max(config.scale.value, Math.round(totalFeetRaw / config.scale.value) * config.scale.value);
						
						// Draw measurement line (cyan, dashed)
						ctx.save();
						ctx.strokeStyle = '#00ffff';
						ctx.lineWidth = 4;
						ctx.setLineDash([10, 5]);
						ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
						ctx.shadowBlur = 6;
						ctx.beginPath();
						ctx.moveTo(originPos.x, originPos.y);
						ctx.lineTo(targetPos.x, targetPos.y);
						ctx.stroke();
						ctx.setLineDash([]);
						ctx.shadowBlur = 0;
						
						// Draw arrowhead at target end
						const angle = Math.atan2(dy, dx);
						const arrowLen = 12;
						ctx.fillStyle = '#00ffff';
						ctx.beginPath();
						ctx.moveTo(targetPos.x, targetPos.y);
						ctx.lineTo(targetPos.x - arrowLen * Math.cos(angle - Math.PI / 6), targetPos.y - arrowLen * Math.sin(angle - Math.PI / 6));
						ctx.lineTo(targetPos.x - arrowLen * Math.cos(angle + Math.PI / 6), targetPos.y - arrowLen * Math.sin(angle + Math.PI / 6));
						ctx.closePath();
						ctx.fill();
						
						// Draw distance label at midpoint
						const midX = (originPos.x + targetPos.x) / 2;
						const midY = (originPos.y + targetPos.y) / 2 - 14;
						let distText = `${totalFeet} ${config.scale.unit}`;
						if (verticalFeet > 0) {
							distText += ` (‚Üï${verticalFeet}ft)`;
						}
						
						// Background pill for readability
						ctx.font = 'bold 18px sans-serif';
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						const textWidth = ctx.measureText(distText).width;
						const pillPadX = 8;
						const pillPadY = 4;
						ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
						const pillX = midX - textWidth / 2 - pillPadX;
						const pillY = midY - 10 - pillPadY;
						const pillW = textWidth + pillPadX * 2;
						const pillH = 20 + pillPadY * 2;
						ctx.beginPath();
						ctx.roundRect(pillX, pillY, pillW, pillH, 6);
						ctx.fill();
						
						// Text outline (dark) for contrast
						ctx.strokeStyle = '#003333';
						ctx.lineWidth = 3;
						ctx.strokeText(distText, midX, midY);
						
						// Text fill (cyan)
						ctx.fillStyle = '#00ffff';
						ctx.fillText(distText, midX, midY);
						
						ctx.restore();
					}
				}
				
				// Draw calibration measurement line
				if (calibrationPoint1) {
					ctx.strokeStyle = '#ff9900';
					ctx.lineWidth = 4;
					ctx.setLineDash([10, 5]);
					ctx.beginPath();
					ctx.moveTo(calibrationPoint1.x, calibrationPoint1.y);
					
					if (calibrationPoint2) {
						ctx.lineTo(calibrationPoint2.x, calibrationPoint2.y);
						ctx.stroke();
						ctx.setLineDash([]);
						
						// Draw distance in pixels
						const distance = Math.sqrt(
							Math.pow(calibrationPoint2.x - calibrationPoint1.x, 2) + 
							Math.pow(calibrationPoint2.y - calibrationPoint1.y, 2)
						);
						
						ctx.fillStyle = '#ff9900';
						ctx.font = 'bold 18px sans-serif';
						ctx.fillText(
							`${Math.round(distance)} pixels`,
							(calibrationPoint1.x + calibrationPoint2.x) / 2,
							(calibrationPoint1.y + calibrationPoint2.y) / 2 - 15
						);
					} else {
						// Just draw the first point as a circle
						ctx.setLineDash([]);
						ctx.beginPath();
						ctx.arc(calibrationPoint1.x, calibrationPoint1.y, 8, 0, 2 * Math.PI);
						ctx.fillStyle = '#ff9900';
						ctx.fill();
						ctx.stroke();
					}
				}
			};

			// Function to draw a hex highlight
			const drawHighlight = (ctx: CanvasRenderingContext2D, highlight: any) => {
				// Apply transparency if not on active layer
				const itemLayer = highlight.layer || 'Player';
				const isActiveLayer = itemLayer === config.activeLayer;
				ctx.globalAlpha = isActiveLayer ? 1.0 : 0.3;
				
				ctx.fillStyle = highlight.color + '60'; // Add alpha
				ctx.strokeStyle = highlight.color;
				ctx.lineWidth = 2;
				const ox = config.gridOffsetX || 0;
				const oy = config.gridOffsetY || 0;
				
				if (config.gridType === 'hex-horizontal') {
					const effectiveSize = config.gridSize;
					const horiz = effectiveSize;
					const size = (2/3) * horiz;
					const vert = Math.sqrt(3) * size;
					const colOffsetY = (highlight.col & 1) ? vert / 2 : 0;
					const centerX = highlight.col * horiz + ox;
					const centerY = highlight.row * vert + colOffsetY + oy;
					this.drawFilledHexFlat(ctx, centerX, centerY, size);
				} else if (config.gridType === 'hex-vertical') {
					const effectiveSize = config.gridSize;
					const vert = effectiveSize;
					const size = (2/3) * vert;
					const horiz = Math.sqrt(3) * size;
					const rowOffsetX = (highlight.row & 1) ? horiz / 2 : 0;
					const centerX = highlight.col * horiz + rowOffsetX + ox;
					const centerY = highlight.row * vert + oy;
					this.drawFilledHexPointy(ctx, centerX, centerY, size);
				} else if (config.gridType === 'square') {
					ctx.fillRect(
						highlight.col * config.gridSize + ox,
						highlight.row * config.gridSize + oy,
						config.gridSize,
						config.gridSize
					);
					ctx.strokeRect(
						highlight.col * config.gridSize + ox,
						highlight.row * config.gridSize + oy,
						config.gridSize,
						config.gridSize
					);
				}
				
				// Reset globalAlpha
				ctx.globalAlpha = 1.0;
			};

			// Function to draw a PoI icon on a hex
			const drawPoiIcon = async (ctx: CanvasRenderingContext2D, poiRef: any) => {
				// For hexcrawl/exploration maps, PoI icons are GM-only hints at 70% opacity
				// For other map types, use layer-based transparency
				const isHexcrawlMap = (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && (config.type === 'world' || config.type === 'regional');
				let poiAlpha: number;
				if (isHexcrawlMap) {
					poiAlpha = 0.7;
				} else {
					const itemLayer = poiRef.layer || 'DM';
					const isActiveLayer = itemLayer === config.activeLayer;
					poiAlpha = isActiveLayer ? 0.8 : 0.2;
				}
				
				const ox = config.gridOffsetX || 0;
				const oy = config.gridOffsetY || 0;
				
				// Get hex size (fixed grid ‚Äî no pace scaling)
				const effectiveSize = config.gridSize;
				
				// Calculate hex center
				let centerX, centerY;
				if (config.gridType === 'hex-horizontal') {
					const horiz = effectiveSize;
					const size = (2/3) * horiz;
					const vert = Math.sqrt(3) * size;
					const colOffsetY = (poiRef.col & 1) ? vert / 2 : 0;
					centerX = poiRef.col * horiz + ox;
					centerY = poiRef.row * vert + colOffsetY + oy;
				} else {
					const vert = effectiveSize;
					const size = (2/3) * vert;
					const horiz = Math.sqrt(3) * size;
					const rowOffsetX = (poiRef.row & 1) ? horiz / 2 : 0;
					centerX = poiRef.col * horiz + rowOffsetX + ox;
					centerY = poiRef.row * vert + oy;
				}
				
				// Load icon from PoI file
				let icon = 'üìç'; // Default icon
				try {
					const fileCache = this.app.metadataCache.getCache(poiRef.poiFile);
					if (fileCache?.frontmatter?.icon) {
						icon = fileCache.frontmatter.icon;
					}
				} catch (error) {
					console.error('Error loading PoI icon:', error);
				}
				
				// Draw icon onto a temporary canvas first, then composite with alpha
				// (emoji fillText doesn't always respect globalAlpha in Electron)
				const tmpSize = 48;
				const tmpCanvas = document.createElement('canvas');
				tmpCanvas.width = tmpSize;
				tmpCanvas.height = tmpSize;
				const tmpCtx = tmpCanvas.getContext('2d');
				if (tmpCtx) {
					tmpCtx.font = '24px sans-serif';
					tmpCtx.textAlign = 'center';
					tmpCtx.textBaseline = 'middle';
					tmpCtx.fillText(icon, tmpSize / 2, tmpSize / 2);
				}
				
				ctx.save();
				ctx.globalAlpha = poiAlpha;
				ctx.drawImage(tmpCanvas, centerX - tmpSize / 2, centerY - tmpSize / 2);
				ctx.restore();
			};

			// Helper: get marker pixel radius for a given marker definition
			const getMarkerRadius = (markerDef: MarkerDefinition): number => {
				if (['player', 'npc', 'creature'].includes(markerDef.type) && markerDef.creatureSize && config.gridSize) {
					const squares = CREATURE_SIZE_SQUARES[markerDef.creatureSize] || 1;
					return (squares * config.gridSize) / 2;
				}
				return (markerDef.pixelSize || 30) / 2;
			};

			// Image cache for marker token images
			const markerImageCache: Map<string, HTMLImageElement> = new Map();
			const loadMarkerImage = (path: string): HTMLImageElement | null => {
				if (markerImageCache.has(path)) {
					const img2 = markerImageCache.get(path)!;
					return img2.complete && img2.naturalWidth > 0 ? img2 : null;
				}
				const img2 = new Image();
				markerImageCache.set(path, img2);
				try {
					img2.src = this.app.vault.adapter.getResourcePath(path);
					img2.onload = () => redrawAnnotations();
				} catch {
					// invalid path
				}
				return null;
			};

			// Function to draw a marker
			const drawMarker = (ctx: CanvasRenderingContext2D, marker: any) => {
				// Apply transparency if not on active layer
				const itemLayer = marker.layer || 'Player';
				const isActiveLayer = itemLayer === config.activeLayer;
				
				// Special transparency for burrowed tokens (underground)
				if (marker.elevation && marker.elevation.isBurrowing) {
					ctx.globalAlpha = 0.5; // Burrowed tokens are semi-transparent
				}
				// Special transparency for Elevated/Subterranean layers
				else if (itemLayer === 'Elevated' || itemLayer === 'Subterranean') {
					ctx.globalAlpha = 0.6; // Semi-transparent even when active
				} else {
					ctx.globalAlpha = isActiveLayer ? 1.0 : 0.3;
				}
				
				let markerDef: MarkerDefinition | null | undefined = null;
				let position = marker.position;
				
				// Check if this is a MarkerReference (new format) or old format
				if (marker.markerId) {
					markerDef = this.markerLibrary.getMarker(marker.markerId);
					if (!markerDef) {
						console.warn('Marker definition not found:', marker.markerId);
						return;
					}
				} else {
					// Old format: treat as poi with pixelSize
					markerDef = {
						id: marker.id || 'legacy',
						name: 'Legacy',
						type: 'poi',
						icon: marker.icon || '',
						backgroundColor: marker.color || '#ff0000',
						borderColor: '#ffffff',
						pixelSize: 30,
						createdAt: 0,
						updatedAt: 0
					};
				}
				
				const radius = getMarkerRadius(markerDef);
				const elevation = marker.elevation;
				
				ctx.save();
				
				// Draw drop shadow for flying tokens
				if (elevation && elevation.height && elevation.height > 0) {
					const shadowOffset = Math.min(10, elevation.height / 5);
					const shadowBlur = Math.min(15, elevation.height / 3);
					
					ctx.save();
					ctx.globalAlpha = 0.4;
					ctx.fillStyle = '#000000';
					ctx.shadowColor = '#000000';
					ctx.shadowBlur = shadowBlur;
					ctx.shadowOffsetX = shadowOffset;
					ctx.shadowOffsetY = shadowOffset;
					ctx.beginPath();
					ctx.arc(position.x, position.y, radius * 0.8, 0, Math.PI * 2);
					ctx.fill();
					ctx.restore();
					
					// Reset to main alpha
					if (itemLayer === 'Elevated') {
						ctx.globalAlpha = 0.6;
					} else {
						ctx.globalAlpha = isActiveLayer ? 1.0 : 0.3;
					}
				}
				
				// Add colored glow for elevated/subterranean
				if (itemLayer === 'Elevated' || itemLayer === 'Subterranean') {
					ctx.save();
					ctx.shadowColor = itemLayer === 'Elevated' ? '#4DA6FF' : '#8B4513';
					ctx.shadowBlur = 10;
					ctx.beginPath();
					ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
					ctx.strokeStyle = itemLayer === 'Elevated' ? '#4DA6FF' : '#8B4513';
					ctx.lineWidth = 3;
					ctx.stroke();
					ctx.restore();
				}
				
				// Clip to circle
				ctx.beginPath();
				ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
				ctx.closePath();
				
				// Try to draw image first
				let imageDrawn = false;
				if (markerDef.imageFile) {
					const cachedImg = loadMarkerImage(markerDef.imageFile);
					if (cachedImg) {
						ctx.clip();
						const fit = markerDef.imageFit || 'cover';
						const imgW = cachedImg.naturalWidth;
						const imgH = cachedImg.naturalHeight;
						const tokenSize = radius * 2;
						if (fit === 'contain') {
							// Show entire image inside the token, preserving aspect ratio
							ctx.fillStyle = markerDef.backgroundColor || '#333333';
							ctx.fill();
							const scale = Math.min(tokenSize / imgW, tokenSize / imgH);
							const drawW = imgW * scale;
							const drawH = imgH * scale;
							ctx.drawImage(cachedImg, position.x - drawW / 2, position.y - drawH / 2, drawW, drawH);
						} else {
							// Cover: fill the token, may crop edges, preserving aspect ratio
							const scale = Math.max(tokenSize / imgW, tokenSize / imgH);
							const drawW = imgW * scale;
							const drawH = imgH * scale;
							ctx.drawImage(cachedImg, position.x - drawW / 2, position.y - drawH / 2, drawW, drawH);
						}
						imageDrawn = true;
					}
				}
				
				// Fill background color only if no image was drawn
				if (!imageDrawn) {
					ctx.fillStyle = markerDef.backgroundColor;
					ctx.fill();
				}
				
				// Draw border (check marker instance first, then definition, then default to white)
				// Re-draw the arc path since clip consumed it
				const borderColor = (marker as any).borderColor || markerDef.borderColor || '#ffffff';
				ctx.restore();
				ctx.save();
				ctx.beginPath();
				ctx.arc(position.x, position.y, radius, 0, Math.PI * 2);
				ctx.strokeStyle = borderColor;
				ctx.lineWidth = Math.max(2, radius * 0.1);
				ctx.stroke();
				
				// Draw icon/label if present
				if (markerDef.icon) {
					ctx.fillStyle = '#ffffff';
					ctx.font = `${Math.max(10, radius * 1.2)}px sans-serif`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText(markerDef.icon, position.x, position.y);
				}
				
				ctx.restore();
				
				// Draw elevation badge
				if (elevation && (elevation.height || elevation.depth)) {
					ctx.save();
					ctx.globalAlpha = 1.0;
					
					const badgeSize = Math.max(16, radius * 0.5);
					const badgeX = position.x + radius - badgeSize / 2;
					const badgeY = position.y - radius + badgeSize / 2;
					
					// Badge background
					ctx.fillStyle = elevation.height ? '#4DA6FF' : '#8B4513';
					ctx.beginPath();
					ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
					ctx.fill();
					
					// Badge border
					ctx.strokeStyle = '#ffffff';
					ctx.lineWidth = 2;
					ctx.stroke();
					
					// Badge text
					const elevationValue = elevation.height || elevation.depth || 0;
					const elevationIcon = elevation.height ? '‚Üë' : '‚Üì';
					ctx.fillStyle = '#ffffff';
					ctx.font = `bold ${Math.max(10, badgeSize * 0.6)}px sans-serif`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText(elevationIcon, badgeX, badgeY - 1);
					
					// Show feet value if there's room
					if (radius > 25) {
						ctx.font = `${Math.max(8, badgeSize * 0.4)}px sans-serif`;
						ctx.fillText(`${elevationValue}`, badgeX, badgeY + badgeSize / 2 + 6);
					}
					
					ctx.restore();
				}
				
				// Draw tunnel mode badge
				if (marker.tunnelState) {
					ctx.save();
					ctx.globalAlpha = 1.0;
					
					const badgeSize = Math.max(16, radius * 0.5);
					const badgeX = position.x - radius + badgeSize / 2;  // Left side
					const badgeY = position.y - radius + badgeSize / 2;
					
					// Badge background (orange/amber for visibility)
					ctx.fillStyle = '#FF8C00';
					ctx.beginPath();
					ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
					ctx.fill();
					
					// Badge border
					ctx.strokeStyle = '#ffffff';
					ctx.lineWidth = 2;
					ctx.stroke();
					
					// Badge icon (flashlight/tunnel icon)
					ctx.fillStyle = '#ffffff';
					ctx.font = `bold ${Math.max(10, badgeSize * 0.6)}px sans-serif`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText('üî¶', badgeX, badgeY);
					
					ctx.restore();
					
					// Draw highlighted tunnel path
					const tunnel = config.tunnels?.find((t: any) => t.id === marker.tunnelState.tunnelId);
					if (tunnel && tunnel.path.length > 1) {
						ctx.save();
						ctx.globalAlpha = 0.8;
						
						const CREATURE_SIZE_SQUARES: Record<string, number> = {
							'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
						};
						const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
						const tunnelWidth = (squares * config.gridSize) / 2;
						
						// Draw path up to current position in bright color
						ctx.strokeStyle = '#FFD700';  // Gold
						ctx.lineWidth = tunnelWidth + 2;
						ctx.lineCap = 'round';
						ctx.lineJoin = 'round';
						ctx.beginPath();
						ctx.moveTo(tunnel.path[0].x, tunnel.path[0].y);
						for (let i = 1; i <= marker.tunnelState.pathIndex && i < tunnel.path.length; i++) {
							ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
						}
						ctx.stroke();
						
						// Draw remaining path in dimmer color
						if (marker.tunnelState.pathIndex < tunnel.path.length - 1) {
							ctx.strokeStyle = '#666666';
							ctx.lineWidth = tunnelWidth;
							ctx.beginPath();
							ctx.moveTo(tunnel.path[marker.tunnelState.pathIndex].x, tunnel.path[marker.tunnelState.pathIndex].y);
							for (let i = marker.tunnelState.pathIndex + 1; i < tunnel.path.length; i++) {
								ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
							}
							ctx.stroke();
						}
						
						ctx.restore();
					}
				}
				
				// Reset globalAlpha
				ctx.globalAlpha = 1.0;
			};

			// Function to draw a drawing
			const drawDrawing = (ctx: CanvasRenderingContext2D, drawing: any) => {
				if (drawing.points.length === 0) return;
				
				// Apply transparency if not on active layer
				const itemLayer = drawing.layer || 'Player';
				const isActiveLayer = itemLayer === config.activeLayer;
				ctx.globalAlpha = isActiveLayer ? 1.0 : 0.3;
				
				ctx.strokeStyle = drawing.color;
				ctx.lineWidth = drawing.strokeWidth || 2;
				
				if (drawing.type === 'freehand') {
					ctx.beginPath();
					ctx.moveTo(drawing.points[0].x, drawing.points[0].y);
					for (let i = 1; i < drawing.points.length; i++) {
						ctx.lineTo(drawing.points[i].x, drawing.points[i].y);
					}
					ctx.stroke();
				}
				
				// Reset globalAlpha
				ctx.globalAlpha = 1.0;
			};

			// Helper: snap a point to the nearest grid intersection
			const snapToGridIntersection = (x: number, y: number): { x: number; y: number } => {
				const ox = config.gridOffsetX || 0;
				const oy = config.gridOffsetY || 0;
				const gs = config.gridSize || 70;
				if (config.gridType === 'square') {
					const snappedX = Math.round((x - ox) / gs) * gs + ox;
					const snappedY = Math.round((y - oy) / gs) * gs + oy;
					return { x: snappedX, y: snappedY };
				}
				// For hex grids, snap to nearest cell center
				const hex = pixelToHex(x, y);
				if (config.gridType === 'hex-horizontal') {
					const horiz = gs;
					const size = (2 / 3) * horiz;
					const vert = Math.sqrt(3) * size;
					const colOffsetY = (hex.col & 1) ? vert / 2 : 0;
					return { x: hex.col * horiz + ox, y: hex.row * vert + colOffsetY + oy };
				} else if (config.gridType === 'hex-vertical') {
					const vert = gs;
					const size = (2 / 3) * vert;
					const horiz = Math.sqrt(3) * size;
					const rowOffsetX = (hex.row & 1) ? horiz / 2 : 0;
					return { x: hex.col * horiz + rowOffsetX + ox, y: hex.row * vert + oy };
				}
				return { x, y };
			};

			// Helper: snap distance to grid multiples
			const snapDistanceToGrid = (pixelDist: number): number => {
				const gs = config.gridSize || 70;
				return Math.max(gs, Math.round(pixelDist / gs) * gs);
			};

			// Draw an AoE shape (used for both preview and saved effects)
			const drawAoeShape = (ctx: CanvasRenderingContext2D, origin: { x: number; y: number }, end: { x: number; y: number }, shape: string, color: string, isPreview: boolean, centered: boolean = false) => {
				const gs = config.gridSize || 70;
				const dx = end.x - origin.x;
				const dy = end.y - origin.y;
				const rawDist = Math.sqrt(dx * dx + dy * dy);
				const snappedDist = snapDistanceToGrid(rawDist);
				const angle = Math.atan2(dy, dx);
				
				ctx.save();
				
				// Apply transparency for non-active layers
				const isActiveLayer = true; // AoE shapes drawn fresh are always on active layer context
				if (!isPreview) {
					ctx.globalAlpha = 0.5;
				} else {
					ctx.globalAlpha = 0.35;
				}
				
				ctx.fillStyle = color;
				ctx.strokeStyle = color;
				ctx.lineWidth = 3;
				
				if (shape === 'circle') {
					ctx.beginPath();
					ctx.arc(origin.x, origin.y, snappedDist, 0, Math.PI * 2);
					ctx.fill();
					ctx.globalAlpha = isPreview ? 0.7 : 0.8;
					ctx.stroke();
				} else if (shape === 'cone') {
					// 53-degree cone (standard D&D cone angle)
					const halfAngle = (53 / 2) * (Math.PI / 180);
					ctx.beginPath();
					ctx.moveTo(origin.x, origin.y);
					ctx.arc(origin.x, origin.y, snappedDist, angle - halfAngle, angle + halfAngle);
					ctx.closePath();
					ctx.fill();
					ctx.globalAlpha = isPreview ? 0.7 : 0.8;
					ctx.stroke();
				} else if (shape === 'square') {
					const half = snappedDist;
					ctx.save();
					ctx.translate(origin.x, origin.y);
					ctx.rotate(angle);
					if (centered) {
						// Token-centered: square centered on origin
						ctx.fillRect(-half, -half, half * 2, half * 2);
						ctx.globalAlpha = isPreview ? 0.7 : 0.8;
						ctx.strokeRect(-half, -half, half * 2, half * 2);
					} else {
						// Intersection-origin: square extends from origin outward
						ctx.fillRect(0, -half, half * 2, half * 2);
						ctx.globalAlpha = isPreview ? 0.7 : 0.8;
						ctx.strokeRect(0, -half, half * 2, half * 2);
					}
					ctx.restore();
				} else if (shape === 'line') {
					// Line: 5ft (1 grid cell) wide, snappedDist long
					const halfWidth = gs / 2;
					ctx.save();
					ctx.translate(origin.x, origin.y);
					ctx.rotate(angle);
					ctx.fillRect(0, -halfWidth, snappedDist, halfWidth * 2);
					ctx.globalAlpha = isPreview ? 0.7 : 0.8;
					ctx.strokeRect(0, -halfWidth, snappedDist, halfWidth * 2);
					ctx.restore();
				}
				
				// Draw size label
				ctx.globalAlpha = 1.0;
				const gridUnits = snappedDist / gs;
				const realSize = gridUnits * (config.scale?.value || 5);
				const unit = config.scale?.unit || 'feet';
				let labelText = '';
				if (shape === 'circle') {
					labelText = `${realSize.toFixed(0)} ${unit} radius`;
				} else if (shape === 'cone') {
					labelText = `${realSize.toFixed(0)} ${unit} cone`;
				} else if (shape === 'square') {
					labelText = `${(realSize * 2).toFixed(0)} ${unit} cube`;
				} else if (shape === 'line') {
					labelText = `${realSize.toFixed(0)} ${unit} line`;
				}
				
				// Position label
				let labelX: number, labelY: number;
				if (shape === 'circle') {
					labelX = origin.x;
					labelY = origin.y;
				} else {
					labelX = origin.x + Math.cos(angle) * snappedDist / 2;
					labelY = origin.y + Math.sin(angle) * snappedDist / 2;
				}
				
				ctx.font = 'bold 16px sans-serif';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.strokeStyle = '#000000';
				ctx.lineWidth = 3;
				ctx.strokeText(labelText, labelX, labelY - 12);
				ctx.fillStyle = '#ffffff';
				ctx.fillText(labelText, labelX, labelY - 12);
				
				ctx.restore();
			};

			// Draw a saved AoE effect
			const drawAoeEffect = (ctx: CanvasRenderingContext2D, aoe: any) => {
				// Apply transparency if not on active layer
				const itemLayer = aoe.layer || 'Player';
				const isActiveLayer = itemLayer === config.activeLayer;
				if (!isActiveLayer) {
					ctx.save();
					ctx.globalAlpha = 0.3;
				}
				drawAoeShape(ctx, aoe.origin, aoe.end, aoe.shape, aoe.color, false, !!aoe.anchorMarkerId);
				if (!isActiveLayer) {
					ctx.restore();
				}
			};

			// ============ Fog of War Rendering ============
			
			// Helper: clip a fog region into a canvas path
			const clipFogRegion = (ctx: CanvasRenderingContext2D, region: any) => {
				if (region.shape === 'rect') {
					ctx.rect(region.x, region.y, region.width, region.height);
				} else if (region.shape === 'circle') {
					ctx.arc(region.cx, region.cy, region.radius, 0, Math.PI * 2);
				} else if (region.shape === 'polygon' && region.points && region.points.length >= 3) {
					ctx.moveTo(region.points[0].x, region.points[0].y);
					for (let i = 1; i < region.points.length; i++) {
						ctx.lineTo(region.points[i].x, region.points[i].y);
					}
					ctx.closePath();
				}
			};

			// Draw fog of war using an offscreen canvas
			const drawFogOfWar = (ctx: CanvasRenderingContext2D, w: number, h: number, isPlayerView: boolean) => {
				const fogAlpha = isPlayerView ? 1.0 : 0.45;
				
				// Create offscreen fog canvas
				const fogCanvas = document.createElement('canvas');
				fogCanvas.width = w;
				fogCanvas.height = h;
				const fogCtx = fogCanvas.getContext('2d');
				if (!fogCtx) return;
				
				// Start fully black
				fogCtx.fillStyle = '#000000';
				fogCtx.fillRect(0, 0, w, h);
				
				// Process regions in order: reveal cuts holes, hide adds black
				config.fogOfWar.regions.forEach((region: any) => {
					if (region.type === 'reveal') {
						fogCtx.globalCompositeOperation = 'destination-out';
						fogCtx.fillStyle = '#ffffff';
					} else {
						fogCtx.globalCompositeOperation = 'source-over';
						fogCtx.fillStyle = '#000000';
					}
					fogCtx.beginPath();
					clipFogRegion(fogCtx, region);
					fogCtx.fill();
				});
				
				// Light sources reveal fog (only in player view)
				if (isPlayerView && config.lightSources && config.lightSources.length > 0) {
					// Calculate pixels per foot based on grid settings
					const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
					
					fogCtx.globalCompositeOperation = 'destination-out';
					fogCtx.fillStyle = '#ffffff';
					
					config.lightSources.forEach((light: any) => {
						// Convert feet to pixels
						const brightRadiusPx = light.bright * pixelsPerFoot;
						const totalRadiusPx = (light.bright + light.dim) * pixelsPerFoot;
						
						// Reveal area with gradient (bright + dim light)
						if (totalRadiusPx > 0) {
							const gradient = fogCtx.createRadialGradient(
								light.x, light.y, 0,
								light.x, light.y, totalRadiusPx
							);
							gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
							if (brightRadiusPx > 0) {
								gradient.addColorStop(brightRadiusPx / totalRadiusPx, 'rgba(255, 255, 255, 1.0)');
							}
							gradient.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
							
							fogCtx.fillStyle = gradient;
							fogCtx.beginPath();
							fogCtx.arc(light.x, light.y, totalRadiusPx, 0, Math.PI * 2);
							fogCtx.fill();
						}
					});
				}
				
				// Draw the fog canvas onto the main canvas
				ctx.save();
				ctx.globalAlpha = fogAlpha;
				ctx.drawImage(fogCanvas, 0, 0);
				ctx.restore();
			};

			// Draw fog preview while dragging
			const drawFogPreview = (ctx: CanvasRenderingContext2D) => {
				if (!fogDragStart || !fogDragEnd) return;
				ctx.save();
				ctx.globalAlpha = 0.3;
				ctx.fillStyle = fogMode === 'reveal' ? '#00ff00' : '#000000';
				ctx.strokeStyle = fogMode === 'reveal' ? '#00ff00' : '#ff0000';
				ctx.lineWidth = 2;
				ctx.setLineDash([6, 3]);
				
				if (selectedFogShape === 'brush' || selectedFogShape === 'rect') {
					const x = Math.min(fogDragStart.x, fogDragEnd.x);
					const y = Math.min(fogDragStart.y, fogDragEnd.y);
					const w = Math.abs(fogDragEnd.x - fogDragStart.x);
					const h = Math.abs(fogDragEnd.y - fogDragStart.y);
					ctx.fillRect(x, y, w, h);
					ctx.strokeRect(x, y, w, h);
				} else if (selectedFogShape === 'circle') {
					const dx = fogDragEnd.x - fogDragStart.x;
					const dy = fogDragEnd.y - fogDragStart.y;
					const r = Math.sqrt(dx * dx + dy * dy);
					ctx.beginPath();
					ctx.arc(fogDragStart.x, fogDragStart.y, r, 0, Math.PI * 2);
					ctx.fill();
					ctx.stroke();
				}
				
				ctx.restore();
			};

			// Draw polygon preview while placing points
			const drawFogPolygonPreview = (ctx: CanvasRenderingContext2D) => {
				if (fogPolygonPoints.length === 0) return;
				ctx.save();
				ctx.globalAlpha = 0.3;
				ctx.fillStyle = fogMode === 'reveal' ? '#00ff00' : '#000000';
				ctx.strokeStyle = fogMode === 'reveal' ? '#00ff00' : '#ff0000';
				ctx.lineWidth = 2;
				ctx.setLineDash([6, 3]);
				
				ctx.beginPath();
				ctx.moveTo(fogPolygonPoints[0]!.x, fogPolygonPoints[0]!.y);
				for (let i = 1; i < fogPolygonPoints.length; i++) {
					ctx.lineTo(fogPolygonPoints[i]!.x, fogPolygonPoints[i]!.y);
				}
				ctx.closePath();
				ctx.fill();
				ctx.stroke();
				
				// Draw dots at each point
				ctx.globalAlpha = 0.8;
				ctx.fillStyle = fogMode === 'reveal' ? '#00ff00' : '#ff0000';
				fogPolygonPoints.forEach(pt => {
					ctx.beginPath();
					ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
					ctx.fill();
				});
				
				ctx.restore();
			};

			// Tool switching function
			const setActiveTool = (tool: typeof activeTool) => {
				console.log('setActiveTool called with:', tool);
				activeTool = tool;
				console.log('activeTool is now:', activeTool);
				[panBtn, selectBtn, highlightBtn, poiBtn, markerBtn, drawBtn, eraserBtn, rulerBtn, targetDistBtn, aoeBtn, viewBtn, fogBtn, wallsBtn, lightsBtn, moveGridBtn, terrainPaintBtn, climatePaintBtn, setStartHexBtn, hexDescBtn].forEach(btn => btn.removeClass('active'));
				
				// Cancel calibration when switching tools
				if (isCalibrating) {
					isCalibrating = false;
					calibrationPoint1 = null;
					calibrationPoint2 = null;
					calibrateBtn.removeClass('active');
				}

				// Cancel AoE placement when switching away
				if (tool !== 'aoe') {
					aoeOrigin = null;
					aoePreviewEnd = null;
				}

				// Cancel target distance measurement when switching away
				if (tool !== 'target-distance') {
					targetDistOriginIdx = -1;
					targetDistTargetIdx = -1;
					targetDistState = 'selecting-origin';
				}

				// Cancel fog placement when switching away
				if (tool !== 'fog') {
					fogDragStart = null;
					fogDragEnd = null;
					fogPolygonPoints = [];
				}
				
				// Cancel wall drawing when switching away
				if (tool !== 'walls') {
					wallPoints = [];
					wallPreviewPos = null;
				}
				
				// Show/hide color picker based on tool (with animation)
				const showColorPicker = tool === 'highlight' || tool === 'draw' || tool === 'aoe';
				colorPicker.toggleClass('hidden', !showColorPicker);
				colorSeparator.toggleClass('hidden', !showColorPicker);

				// Show/hide AoE shape picker
				aoePicker.toggleClass('hidden', tool !== 'aoe');
				// Show/hide Fog shape picker
				fogPicker.toggleClass('hidden', tool !== 'fog');
				// Show/hide Walls type picker
				wallsPicker.toggleClass('hidden', tool !== 'walls');
				// Show/hide Lights picker
				lightsPicker.toggleClass('hidden', tool !== 'lights');
				// Show/hide Player View controls picker
				pvPicker.toggleClass('hidden', tool !== 'player-view');
				// Show/hide Terrain picker
				terrainPicker.toggleClass('hidden', tool !== 'terrain-paint');
				// Show/hide Climate picker
				climatePicker.toggleClass('hidden', tool !== 'climate-paint');


				
				if (tool === 'pan') {
					panBtn.addClass('active');
					viewport.style.cursor = 'grab';
				} else if (tool === 'select') {
					selectBtn.addClass('active');
					viewport.style.cursor = 'default';
				} else if (tool === 'highlight') {
					highlightBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
			} else if (tool === 'marker') {
				markerBtn.addClass('active');
				viewport.style.cursor = 'crosshair';
				} else if (tool === 'ruler') {
					rulerBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
				} else if (tool === 'target-distance') {
					targetDistBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
					new Notice('Token Distance: Click origin token, then target token', 3000);
				} else if (tool === 'move-grid') {
					moveGridBtn.addClass('active');
					viewport.style.cursor = 'move';
        } else if (tool === 'aoe') {
					aoeBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
        } else if (tool === 'player-view') {
          viewBtn.addClass('active');
          viewport.style.cursor = 'crosshair';
          viewport.focus(); // Focus viewport so keyboard events work
          new Notice('Player View Mode: Drag to position, Q/E or [/] to rotate 90¬∞', 4000);
        } else if (tool === 'fog') {
					fogBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
				} else if (tool === 'walls') {
					wallsBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
					viewport.focus();
					new Notice('Walls Mode: Click to add points, Double-click to finish, Escape to cancel', 4000);
				} else if (tool === 'lights') {
					lightsBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
					viewport.focus();
					new Notice('Lights Mode: Click to place light source, use picker to select type', 4000);
				} else if (tool === 'poi') {
					poiBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
				} else if (tool === 'terrain-paint') {
					terrainPaintBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
				} else if (tool === 'climate-paint') {
					climatePaintBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
				} else if (tool === 'hexcrawl-move') {
					viewport.style.cursor = 'crosshair';
					hexcrawlMoveHoverHex = null; // Reset hover on tool activation
					redrawAnnotations();
					if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
					new Notice(hLoc(hcLang, 'clickHexTravel'), 3000);
				} else if (tool === 'set-start-hex') {
					setStartHexBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
					new Notice(hLoc(hcLang, 'clickHexSetStart'), 3000);
				} else if (tool === 'hex-desc') {
					hexDescBtn.addClass('active');
					viewport.style.cursor = 'crosshair';
					new Notice(hLoc(hcLang, 'clickHexEditDesc'), 3000);
				}
			
				// Clear ruler when switching tools
				if (tool !== 'ruler' && tool !== 'poi' && annotationCanvas) {
					rulerStart = null;
					rulerEnd = null;
					rulerComplete = false;
					redrawAnnotations();
				}

				// Clear target distance when switching tools
				if (tool !== 'target-distance' && annotationCanvas) {
					if (targetDistOriginIdx >= 0 || targetDistTargetIdx >= 0) {
						targetDistOriginIdx = -1;
						targetDistTargetIdx = -1;
						targetDistState = 'selecting-origin';
						redrawAnnotations();
						if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
					}
				}

				// Clear hexcrawl move overlay when switching away
				if (tool !== 'hexcrawl-move' && hexcrawlMoveHoverHex !== null) {
					hexcrawlMoveHoverHex = null;
					redrawAnnotations();
					if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
				}
			};

			// Patch the hexcrawl bridge with the real setActiveTool now that it's defined
			if (this._hexcrawlBridge) {
				this._hexcrawlBridge.setActiveTool = (tool: string) => setActiveTool(tool as any);
			}

			// Wire up tool button handlers
			panBtn.addEventListener('click', () => {
				console.log('Pan button clicked');
				setActiveTool('pan');
			});
			selectBtn.addEventListener('click', () => {
				console.log('Select button clicked');
				setActiveTool('select');
			});
			highlightBtn.addEventListener('click', () => {
				console.log('Highlight button clicked');
				setActiveTool('highlight');
			});
			poiBtn.addEventListener('click', () => {
				console.log('PoI button clicked');
				setActiveTool('poi');
			});
			markerBtn.addEventListener('click', async () => {
				console.log('Marker button clicked');
				// Show marker picker to select or create marker
				const { MarkerPickerModal } = await import('./marker/MarkerPickerModal');
				new MarkerPickerModal(this.app, this.markerLibrary, (markerId: string) => {
					selectedMarkerId = markerId;
					setActiveTool('marker');
				}).open();
			});
			drawBtn.addEventListener('click', () => {
				console.log('Draw button clicked');
				setActiveTool('draw');
			});
			rulerBtn.addEventListener('click', () => {
				console.log('Ruler button clicked');
				setActiveTool('ruler');
			});
			targetDistBtn.addEventListener('click', () => {
				console.log('Target Distance button clicked');
				setActiveTool('target-distance');
			});
			aoeBtn.addEventListener('click', () => {
				console.log('AoE button clicked');
				setActiveTool('aoe');
			});
			eraserBtn.addEventListener('click', () => {
				console.log('Eraser button clicked');
				setActiveTool('eraser');
			});
			fogBtn.addEventListener('click', () => {
				console.log('Fog button clicked');
				setActiveTool('fog');
			});
			wallsBtn.addEventListener('click', () => {
				console.log('Walls button clicked');
				setActiveTool('walls');
			});
			lightsBtn.addEventListener('click', () => {
				console.log('Lights button clicked');
				setActiveTool('lights');
			});
			moveGridBtn.addEventListener('click', () => {
				console.log('Move Grid button clicked');
				setActiveTool('move-grid');
			});
			terrainPaintBtn.addEventListener('click', () => {
				console.log('Terrain Paint button clicked');
				if (activeTool === 'terrain-paint') {
					terrainPicker.toggleClass('hidden', !terrainPicker.hasClass('hidden'));
				} else {
					setActiveTool('terrain-paint');
				}
			});
			climatePaintBtn.addEventListener('click', () => {
				console.log('Climate Paint button clicked');
				if (activeTool === 'climate-paint') {
					climatePicker.toggleClass('hidden', !climatePicker.hasClass('hidden'));
				} else {
					setActiveTool('climate-paint');
				}
			});
			setStartHexBtn.addEventListener('click', () => {
				console.log('Set Starting Hex button clicked');
				setActiveTool('set-start-hex');
			});
			hexDescBtn.addEventListener('click', () => {
				console.log('Hex Description button clicked');
				setActiveTool('hex-desc');
			});

		viewBtn.addEventListener('click', () => {
			console.log('Player View button clicked');
			setActiveTool('player-view');
		});
			// Hide move-grid if no grid
			if (!hasGrid) moveGridBtn.addClass('hidden');

			// Add grid overlay when media is ready
			// For images, use 'load'; for videos, use 'loadeddata' (first frame available)
			const onMediaReady = () => {
				if (config.gridType && config.gridType !== 'none' && config.gridSize) {
					redrawGridOverlays();
				}
				
				// Create terrain/climate background canvas (sits between grid overlays and annotations)
				terrainCanvas = document.createElement('canvas');
				terrainCanvas.classList.add('dnd-map-terrain-layer');
				terrainCanvas.width = img.naturalWidth;
				terrainCanvas.height = img.naturalHeight;
				terrainCanvas.style.position = 'absolute';
				terrainCanvas.style.top = '0';
				terrainCanvas.style.left = '0';
				terrainCanvas.style.width = `${img.width}px`;
				terrainCanvas.style.height = `${img.height}px`;
				terrainCanvas.style.pointerEvents = 'none';
				// Terrain/climate is Background-layer content: dim when not on Background
				terrainCanvas.style.opacity = config.activeLayer === 'Background' ? '1' : '0.25';
				mapWrapper.appendChild(terrainCanvas);

				// Create annotation canvas
				annotationCanvas = document.createElement('canvas');
				annotationCanvas.classList.add('dnd-map-annotation-layer');
				annotationCanvas.width = img.naturalWidth;
				annotationCanvas.height = img.naturalHeight;
				annotationCanvas.style.position = 'absolute';
				annotationCanvas.style.top = '0';
				annotationCanvas.style.left = '0';
				annotationCanvas.style.width = `${img.width}px`;
				annotationCanvas.style.height = `${img.height}px`;
				mapWrapper.appendChild(annotationCanvas);

				redrawTerrainLayer();
				redrawAnnotations();
				
				// Add ResizeObserver to update canvas dimensions when img resizes
				// This prevents grid distortion when window resizes
				const resizeObserver = new ResizeObserver(() => {
					// Update terrain canvas display size
					if (terrainCanvas) {
						terrainCanvas.style.width = `${img.width}px`;
						terrainCanvas.style.height = `${img.height}px`;
						redrawTerrainLayer();
					}
					// Update annotation canvas display size
					if (annotationCanvas) {
						annotationCanvas.style.width = `${img.width}px`;
						annotationCanvas.style.height = `${img.height}px`;
						redrawAnnotations();
					}
					
					// Update grid overlay display size
					if (gridCanvas) {
						gridCanvas.style.width = `${img.width}px`;
						gridCanvas.style.height = `${img.height}px`;
					}
				});
				resizeObserver.observe(img);
			};
			// Attach the handler to the appropriate event
			if (config.isVideo) {
				img.addEventListener('loadeddata', onMediaReady, { once: true });
				// If already loaded (e.g., cached), fire immediately
				if ((img as any).readyState >= 2) onMediaReady();
			} else {
				(img as HTMLImageElement).onload = onMediaReady;
			}

			// Mouse wheel zoom (always active)
			viewport.addEventListener('wheel', (e: WheelEvent) => {
				e.preventDefault();
				
				const rect = viewport.getBoundingClientRect();
				const mouseX = e.clientX - rect.left;
				const mouseY = e.clientY - rect.top;
				
				// Calculate position in the map before zoom
				const pointX = (mouseX - translateX) / scale;
				const pointY = (mouseY - translateY) / scale;
				
				// Update scale
				const delta = e.deltaY > 0 ? 0.9 : 1.1;
				scale = Math.max(0.25, Math.min(5, scale * delta));
				
				// Adjust translation to keep the point under the mouse
				translateX = mouseX - pointX * scale;
				translateY = mouseY - pointY * scale;
				
				updateTransform();
				zoomReset.textContent = `${Math.round(scale * 100)}%`;
			});

      // Helper: get axis-aligned bounding box size of a rotated rect (image-space)
      // Used to compute scale that fits the rotated rectangle into the player viewport
			// Tool-aware mouse handlers
			viewport.addEventListener('mousedown', (e: MouseEvent) => {
				// Ignore clicks on UI panels (toolbar, layer menu, player view button, controls)
				const target = e.target as Node;
				if (toolbarWrapper.contains(target) || playerViewBtn.contains(target) || controls.contains(target)) {
					return;
				}
				
				// Middle mouse button - temporary pan mode
				if (e.button === 1) {
					e.preventDefault();
					if (activeTool !== 'pan') {
						previousToolBeforePan = activeTool;
						isTemporaryPan = true;
					}
					isDragging = true;
					startX = e.clientX - translateX;
					startY = e.clientY - translateY;
					viewport.style.cursor = 'grabbing';
					return;
				}
				
				console.log('Mousedown event fired, activeTool:', activeTool);
				if (e.button !== 0) return; // Only left mouse button
				
				const mapPos = screenToMap(e.clientX, e.clientY);
				console.log('Map position:', mapPos);
				
				// Handle calibration mode
				if (isCalibrating) {
					if (!calibrationPoint1) {
						calibrationPoint1 = { x: mapPos.x, y: mapPos.y };
						new Notice('Click second point to complete measurement');
						redrawAnnotations();
					} else {
						calibrationPoint2 = { x: mapPos.x, y: mapPos.y };
						
						// Calculate pixel distance
						const pixelDistance = Math.sqrt(
							Math.pow(calibrationPoint2.x - calibrationPoint1.x, 2) +
							Math.pow(calibrationPoint2.y - calibrationPoint1.y, 2)
						);
						
						// Show modal to select travel pace
						new CalibrationModal(this.app, pixelDistance, async (miles: number) => {
							// Update grid size and scale
							config.gridSize = Math.round(pixelDistance);
							config.scale = {
								value: miles,
								unit: 'miles'
							};
							
							// Redraw grid with new size
							redrawGridOverlays();
							
							// Save configuration to JSON file
							await this.saveMapAnnotations(config, el);
							
							new Notice(`Grid calibrated: ${miles} miles per hex`);
							
							// Reset calibration state
							isCalibrating = false;
							calibrationPoint1 = null;
							calibrationPoint2 = null;
							calibrateBtn.removeClass('active');
							setActiveTool('pan');
							redrawAnnotations();
						}).open();
					}
					e.preventDefault();
					return;
				}
				
				if (activeTool === 'pan') {
					isDragging = true;
					startX = e.clientX - translateX;
					startY = e.clientY - translateY;
					viewport.style.cursor = 'grabbing';
				} else if (activeTool === 'move-grid') {
					isDragging = true;
					startX = e.clientX;
					startY = e.clientY;
					viewport.style.cursor = 'grabbing';
				} else if (activeTool === 'select') {
					// Check if clicking on a PoI icon (hexcrawl maps)
					if ((config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && config.poiReferences && config.poiReferences.length > 0) {
						const hex = pixelToHex(mapPos.x, mapPos.y);
						
						// Find PoI at this hex
						const poiRef = config.poiReferences.find((ref: any) => 
							ref.col === hex.col && ref.row === hex.row
						);
						
						if (poiRef) {
							// Open PoI note in new tab
							this.app.workspace.openLinkText(poiRef.poiFile, '', true);
							return; // Don't check for markers/lights/walls
						}
					}
					
					// Check if clicking on a marker for drag
					let foundMarker = false;
					for (let i = config.markers.length - 1; i >= 0; i--) {
						const m = config.markers[i];
						const mDef = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
						const r = mDef ? getMarkerRadius(mDef) : 15;
						const dist = Math.sqrt(Math.pow(m.position.x - mapPos.x, 2) + Math.pow(m.position.y - mapPos.y, 2));
						if (dist <= r) {
							saveToHistory();
							draggingMarkerIndex = i;
							dragOffsetX = m.position.x - mapPos.x;
							dragOffsetY = m.position.y - mapPos.y;
							markerDragOrigin = { x: m.position.x, y: m.position.y };
							viewport.style.cursor = 'grabbing';
							foundMarker = true;
							break;
						}
					}
					// Check if clicking on a light for drag (only if no marker found)
					if (!foundMarker && config.lightSources && config.lightSources.length > 0) {
						const lightClickRadius = 15; // Radius for detecting light clicks
						for (let i = config.lightSources.length - 1; i >= 0; i--) {
							const light = config.lightSources[i];
							const dist = Math.sqrt(Math.pow(light.x - mapPos.x, 2) + Math.pow(light.y - mapPos.y, 2));
							if (dist <= lightClickRadius) {
								saveToHistory();
								draggingLightIndex = i;
								lightDragOffsetX = light.x - mapPos.x;
								lightDragOffsetY = light.y - mapPos.y;
								lightDragOrigin = { x: light.x, y: light.y };
								viewport.style.cursor = 'grabbing';
								redrawAnnotations();
								break;
							}
						}
					}
					// Check if clicking on a wall/door/window for drag (only if no marker or light found)
					if (!foundMarker && draggingLightIndex < 0 && config.walls && config.walls.length > 0) {
						const wallClickRadius = 12; // Radius for detecting wall clicks
						for (let i = config.walls.length - 1; i >= 0; i--) {
							const wall = config.walls[i];
							// Check distance from point to center of wall segment
							const midX = (wall.start.x + wall.end.x) / 2;
							const midY = (wall.start.y + wall.end.y) / 2;
							const dist = Math.sqrt(Math.pow(midX - mapPos.x, 2) + Math.pow(midY - mapPos.y, 2));
							
							// Also check if click is on the line segment itself
							const dx = wall.end.x - wall.start.x;
							const dy = wall.end.y - wall.start.y;
							const lengthSq = dx * dx + dy * dy;
							let t = 0;
							if (lengthSq > 0) {
								t = Math.max(0, Math.min(1, ((mapPos.x - wall.start.x) * dx + (mapPos.y - wall.start.y) * dy) / lengthSq));
							}
							const nearestX = wall.start.x + t * dx;
							const nearestY = wall.start.y + t * dy;
							const lineDist = Math.sqrt(Math.pow(mapPos.x - nearestX, 2) + Math.pow(mapPos.y - nearestY, 2));
							
							if (dist <= wallClickRadius || lineDist <= wallClickRadius) {
								saveToHistory();
								draggingWallIndex = i;
								wallDragOffsetStartX = wall.start.x - mapPos.x;
								wallDragOffsetStartY = wall.start.y - mapPos.y;
								wallDragOffsetEndX = wall.end.x - mapPos.x;
								wallDragOffsetEndY = wall.end.y - mapPos.y;
								viewport.style.cursor = 'grabbing';
								redrawAnnotations();
								break;
							}
						}
					}
				} else if (activeTool === 'highlight') {
					// Toggle grid highlight on clicked tile
					const hex = pixelToHex(mapPos.x, mapPos.y);
					const existingIndex = config.highlights.findIndex(
						(h: any) => h.col === hex.col && h.row === hex.row
					);
					saveToHistory();
					if (existingIndex >= 0) {
						config.highlights.splice(existingIndex, 1);
					} else {
						const highlight: any = {
							id: `highlight_${Date.now()}`,
							col: hex.col,
							row: hex.row,
							color: selectedColor,
							layer: config.activeLayer || 'Player'
						};
						config.highlights.push(highlight);
					}
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					updateGridToolsVisibility();
				} else if (activeTool === 'poi') {
					// Assign PoI to clicked hex
					const hex = pixelToHex(mapPos.x, mapPos.y);
					
					// Extract campaign folder (prioritize note path, fallback to map path)
					let campaignFolder = null;
					
					// Try to extract from note path first
					if (notePath) {
						const notePathParts = notePath.split('/');
						const ttrpgsIdx = notePathParts.indexOf('ttrpgs');
						if (ttrpgsIdx !== -1 && ttrpgsIdx + 1 < notePathParts.length) {
							campaignFolder = `ttrpgs/${notePathParts[ttrpgsIdx + 1]}`;
						}
					}
					
					// Fallback to map image path
					if (!campaignFolder && config.imageFile) {
						const mapPathParts = config.imageFile.split('/');
						const ttrpgsIdx = mapPathParts.indexOf('ttrpgs');
						if (ttrpgsIdx !== -1 && ttrpgsIdx + 1 < mapPathParts.length) {
							campaignFolder = `ttrpgs/${mapPathParts[ttrpgsIdx + 1]}`;
						}
					}
					
					if (!campaignFolder) {
						new Notice('‚ö†Ô∏è Unable to determine campaign folder. Note or map must be in ttrpgs/[campaign-name]/ structure.');
						return;
					}
					
					// Open PoI picker modal
					import('./poi/PoiModals').then(({ PoiPickerModal }) => {
						new PoiPickerModal(
							this.app,
							campaignFolder,
							hex,
							(poiFile: string) => {
								// Add PoI reference to map
								if (!config.poiReferences) {
									config.poiReferences = [];
								}
								
								// Check if PoI already assigned to this hex
								const existingIndex = config.poiReferences.findIndex(
									(ref: any) => ref.col === hex.col && ref.row === hex.row
								);
								
								if (existingIndex >= 0) {
									// Update existing reference
									config.poiReferences[existingIndex].poiFile = poiFile;
									config.poiReferences[existingIndex].addedAt = Date.now();
								} else {
									// Add new reference
									config.poiReferences.push({
										id: `poi_ref_${Date.now()}`,
										poiFile,
										col: hex.col,
										row: hex.row,
										layer: config.activeLayer || 'DM',
										addedAt: Date.now()
									});
								}
								
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								new Notice(hLoc(hcLang, 'poiAssigned'));
							}
						).open();
					});
					
				} else if (activeTool === 'draw') {
					console.log('Draw tool: starting path');
					isDrawing = true;
					currentPath = [{ x: mapPos.x, y: mapPos.y }];
					console.log('isDrawing set to:', isDrawing, 'currentPath:', currentPath);
				} else if (activeTool === 'ruler') {
					console.log('Ruler tool: rulerStart is', rulerStart);
					if (!rulerStart) {
						rulerStart = { x: mapPos.x, y: mapPos.y };
						rulerComplete = false;
						console.log('Set rulerStart to:', rulerStart);
					} else if (!rulerComplete) {
						rulerEnd = { x: mapPos.x, y: mapPos.y };
						rulerComplete = true;
						console.log('Set rulerEnd to:', rulerEnd);
						redrawAnnotations();
            // Sync ruler to player view
            if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();					
          } else {
						// Third click - clear ruler
						rulerStart = null;
						rulerEnd = null;
						rulerComplete = false;
						redrawAnnotations();
            // Sync cleared ruler to player view
            if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();				
					}
        } else if (activeTool === 'target-distance') {
					// Token-to-token distance measurement tool
					if (targetDistState === 'selecting-origin') {
						// Find marker at click position
						let foundIdx = -1;
						for (let i = config.markers.length - 1; i >= 0; i--) {
							const m = config.markers[i];
							const mDef2 = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
							const r = mDef2 ? getMarkerRadius(mDef2) : 15;
							const dist = Math.sqrt(Math.pow(m.position.x - mapPos.x, 2) + Math.pow(m.position.y - mapPos.y, 2));
							if (dist <= r) {
								foundIdx = i;
								break;
							}
						}
						if (foundIdx >= 0) {
							targetDistOriginIdx = foundIdx;
							targetDistState = 'selecting-target';
							new Notice('Now click the target token', 2000);
							redrawAnnotations();
						} else {
							new Notice('Click on a token to set as origin', 2000);
						}
					} else if (targetDistState === 'selecting-target') {
						// Find marker at click position (different from origin)
						let foundIdx = -1;
						for (let i = config.markers.length - 1; i >= 0; i--) {
							if (i === targetDistOriginIdx) continue;
							const m = config.markers[i];
							const mDef2 = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
							const r = mDef2 ? getMarkerRadius(mDef2) : 15;
							const dist = Math.sqrt(Math.pow(m.position.x - mapPos.x, 2) + Math.pow(m.position.y - mapPos.y, 2));
							if (dist <= r) {
								foundIdx = i;
								break;
							}
						}
						if (foundIdx >= 0) {
							targetDistTargetIdx = foundIdx;
							targetDistState = 'showing';
							redrawAnnotations();
							if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
						} else {
							// Clicked empty space ‚Äî clear measurement
							targetDistOriginIdx = -1;
							targetDistTargetIdx = -1;
							targetDistState = 'selecting-origin';
							redrawAnnotations();
							if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
						}
					} else if (targetDistState === 'showing') {
						// Third click ‚Äî clear measurement
						targetDistOriginIdx = -1;
						targetDistTargetIdx = -1;
						targetDistState = 'selecting-origin';
						redrawAnnotations();
						if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
					}
        } else if (activeTool === 'marker') {
					console.log('Marker tool: placing marker');
					if (!selectedMarkerId) {
						new Notice('Please select a marker first');
						return;
					}
					
					// Snap position to grid center for creature-type markers
					let placeX = mapPos.x;
					let placeY = mapPos.y;
					const mDef = this.markerLibrary.getMarker(selectedMarkerId);
					if (mDef && ['player', 'npc', 'creature'].includes(mDef.type) && config.gridSize) {
						const ox = config.gridOffsetX || 0;
						const oy = config.gridOffsetY || 0;
						const gs = config.gridSize;
						const squares = CREATURE_SIZE_SQUARES[mDef.creatureSize || 'medium'] || 1;
						// Round to nearest grid cell so the token snaps where it has most coverage
						const halfToken = (squares * gs) / 2;
						const col = Math.round((mapPos.x - ox - halfToken) / gs);
						const row = Math.round((mapPos.y - oy - halfToken) / gs);
						placeX = ox + col * gs + halfToken;
						placeY = oy + row * gs + halfToken;
					}
					
					// Create a marker reference
					const markerRef: MarkerReference = {
						id: `marker_inst_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
						markerId: selectedMarkerId,
						position: { x: placeX, y: placeY },
						placedAt: Date.now(),
						layer: config.activeLayer || 'Player'
					};
					
					// Auto-apply darkvision from marker definition if it exists
					if (mDef && mDef.darkvision && mDef.darkvision > 0) {
						(markerRef as any).darkvision = mDef.darkvision;
					}
					
					saveToHistory();
					config.markers.push(markerRef);
					console.log('Placed marker:', markerRef);
					redrawAnnotations();
					if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
					this.saveMapAnnotations(config, el);
					updateGridToolsVisibility();
					refreshVisionSelector();
					new Notice('Marker placed');
				} else if (activeTool === 'aoe') {
					if (!aoeOrigin) {
						// First click: set origin snapped to grid intersection
						aoeOrigin = snapToGridIntersection(mapPos.x, mapPos.y);
						aoePreviewEnd = aoeOrigin;
					} else {
						// Second click: place the AoE effect
						const end = { x: mapPos.x, y: mapPos.y };
						const aoeEffect: any = {
							id: `aoe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
							shape: selectedAoeShape,
							origin: { x: aoeOrigin.x, y: aoeOrigin.y },
							end: { x: end.x, y: end.y },
							color: selectedColor,
							layer: config.activeLayer || 'Player'
						};
						// If this AoE was cast from a token, anchor it so it moves with the token
						if (pendingAoeAnchorMarkerId) {
							aoeEffect.anchorMarkerId = pendingAoeAnchorMarkerId;
							pendingAoeAnchorMarkerId = null;
						}
						config.aoeEffects.push(aoeEffect);
						aoeOrigin = null;
						aoePreviewEnd = null;
						redrawAnnotations();
						this.saveMapAnnotations(config, el);
						updateGridToolsVisibility();
						new Notice('AoE effect placed');
					}
				} else if (activeTool === 'eraser') {
					console.log('Eraser tool: looking for annotations to remove');
					let removed = false;

					// Try to erase an AoE effect near the click point
					if (!removed && config.aoeEffects && config.aoeEffects.length > 0) {
						for (let i = config.aoeEffects.length - 1; i >= 0; i--) {
							const aoe = config.aoeEffects[i];
							// Check if click is near the origin
							const dist = Math.sqrt(
								Math.pow(aoe.origin.x - mapPos.x, 2) +
								Math.pow(aoe.origin.y - mapPos.y, 2)
							);
							if (dist < (config.gridSize || 70)) {
								saveToHistory();
								config.aoeEffects.splice(i, 1);
								console.log('Removed AoE effect');
								removed = true;
								break;
							}
						}
					}
					
					// Try to erase a highlight at the clicked hex
					if (!removed) {
						const hex = pixelToHex(mapPos.x, mapPos.y);
						const highlightIndex = config.highlights.findIndex(
							(h: any) => h.col === hex.col && h.row === hex.row
						);
						if (highlightIndex >= 0) {
							saveToHistory();
							config.highlights.splice(highlightIndex, 1);
							console.log('Removed highlight at', hex);
							removed = true;
						}
					}
					
					// Try to erase a PoI reference at the clicked hex
					if (!removed && (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && config.poiReferences && config.poiReferences.length > 0) {
						const hex = pixelToHex(mapPos.x, mapPos.y);
						const poiIndex = config.poiReferences.findIndex(
							(ref: any) => ref.col === hex.col && ref.row === hex.row
						);
						if (poiIndex >= 0) {
							saveToHistory();
							const poiName = config.poiReferences[poiIndex].poiFile.split('/').pop()?.replace('.md', '') || 'PoI';
							config.poiReferences.splice(poiIndex, 1);
							console.log('Removed PoI reference at', hex);
							redrawAnnotations();
							this.saveMapAnnotations(config, el);
							updateGridToolsVisibility();
							new Notice(hLoc(hcLang, 'poiRemoved', { name: poiName }));
							return; // Skip generic notice
						}
					}
					
					// Try to erase a drawing near the click point
					if (!removed && config.drawings.length > 0) {
						const eraserRadius = 20; // pixels
						for (let i = config.drawings.length - 1; i >= 0; i--) {
							const drawing = config.drawings[i];
							for (const point of drawing.points) {
								const dist = Math.sqrt(
									Math.pow(point.x - mapPos.x, 2) + 
									Math.pow(point.y - mapPos.y, 2)
								);
								if (dist < eraserRadius) {
									config.drawings.splice(i, 1);
									console.log('Removed drawing');
									removed = true;
									break;
								}
							}
							if (removed) break;
						}
					}
					
					// Try to erase a wall near the click point
					if (!removed && config.walls && config.walls.length > 0) {
						const eraserRadius = 20; // pixels
						for (let i = config.walls.length - 1; i >= 0; i--) {
							const wall = config.walls[i];
							// Check distance from click to wall line segment
							const dist = distanceToLineSegment(
								mapPos.x, mapPos.y,
								wall.start.x, wall.start.y,
								wall.end.x, wall.end.y
							);
							if (dist < eraserRadius) {
								config.walls.splice(i, 1);
								console.log('Removed wall');
								removed = true;
								break;
							}
						}
					}
					
					// Try to erase a light source near the click point
					if (!removed && config.lightSources && config.lightSources.length > 0) {
						const eraserRadius = 20; // pixels
						for (let i = config.lightSources.length - 1; i >= 0; i--) {
							const light = config.lightSources[i];
							const dist = Math.sqrt(
								Math.pow(light.x - mapPos.x, 2) +
								Math.pow(light.y - mapPos.y, 2)
							);
							if (dist < eraserRadius) {
								config.lightSources.splice(i, 1);
								console.log('Removed light source');
								removed = true;
								break;
							}
						}
					}
					
					// Try to erase a marker near the click point
					if (!removed && config.markers.length > 0) {
						for (let i = config.markers.length - 1; i >= 0; i--) {
							const marker = config.markers[i];
							const mDef = marker.markerId ? this.markerLibrary.getMarker(marker.markerId) : null;
							const mRadius = mDef ? getMarkerRadius(mDef) : 15;
							const dist = Math.sqrt(
								Math.pow(marker.position.x - mapPos.x, 2) + 
								Math.pow(marker.position.y - mapPos.y, 2)
							);
							if (dist < mRadius) {
								config.markers.splice(i, 1);
								console.log('Removed marker');
								removed = true;
								refreshVisionSelector();
								break;
							}
						}
					}
					
					if (removed) {
						redrawAnnotations();
						this.saveMapAnnotations(config, el);
						updateGridToolsVisibility();
						new Notice('Annotation removed');
					}
				} else if (activeTool === 'fog') {
					if (selectedFogShape === 'polygon') {
						// Polygon: accumulate points, double-click to finish
						fogPolygonPoints.push({ x: mapPos.x, y: mapPos.y });
						redrawAnnotations();
					} else if (selectedFogShape === 'brush' || selectedFogShape === 'rect' || selectedFogShape === 'circle') {
						// Start drag
						fogDragStart = { x: mapPos.x, y: mapPos.y };
						fogDragEnd = { x: mapPos.x, y: mapPos.y };
					}
				} else if (activeTool === 'walls') {
					// Add point to wall chain
					wallPoints.push({ x: mapPos.x, y: mapPos.y });
					wallPreviewPos = { x: mapPos.x, y: mapPos.y };
					redrawAnnotations();
				} else if (activeTool === 'lights') {
					// Place light source at clicked position
					if (selectedLightSource) {
						const light = {
							x: mapPos.x,
							y: mapPos.y,
							type: selectedLightSource,
							...LIGHT_SOURCES[selectedLightSource as LightSourceType]
						};
						saveToHistory();
						config.lightSources.push(light);
						redrawAnnotations();
						this.saveMapAnnotations(config, el);
						
						// Sync to player views
						if ((viewport as any)._syncPlayerView) {
							(viewport as any)._syncPlayerView();
						}
						
						new Notice(`${light.name} placed`);
					} else {
						new Notice('Please select a light source type first');
					}
				} else if (activeTool === 'terrain-paint') {
					// Paint terrain type onto clicked hex
					console.log('[Terrain Paint] Click detected, selectedTerrainType:', selectedTerrainType);
					const hex = pixelToHex(mapPos.x, mapPos.y);
					console.log('[Terrain Paint] Hex coords:', hex.col, hex.row);
					if (!config.hexTerrains) config.hexTerrains = [];
					const idx = config.hexTerrains.findIndex((ht: HexTerrain) => ht.col === hex.col && ht.row === hex.row);
					saveToHistory();
					if (idx >= 0) {
						if (config.hexTerrains[idx].terrain === selectedTerrainType) {
							// Clicking same terrain again removes it
							config.hexTerrains.splice(idx, 1);
						} else {
							config.hexTerrains[idx].terrain = selectedTerrainType;
						}
					} else {
						config.hexTerrains.push({ col: hex.col, row: hex.row, terrain: selectedTerrainType });
					}
					redrawTerrainLayer();
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					this.refreshHexcrawlView();
				} else if (activeTool === 'climate-paint') {
					// Paint climate zone onto clicked hex
					const hex = pixelToHex(mapPos.x, mapPos.y);
					if (!config.hexClimates) config.hexClimates = [];
					const idx = config.hexClimates.findIndex((hc: any) => hc.col === hex.col && hc.row === hex.row);
					saveToHistory();
					if (idx >= 0) {
						if (config.hexClimates[idx].climate === selectedClimateType) {
							// Clicking same climate again removes it
							config.hexClimates.splice(idx, 1);
						} else {
							config.hexClimates[idx].climate = selectedClimateType;
						}
					} else {
						config.hexClimates.push({ col: hex.col, row: hex.row, climate: selectedClimateType });
					}
					redrawTerrainLayer();
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					this.refreshHexcrawlView();
				} else if (activeTool === 'set-start-hex') {
					// Set the party's starting hex position
					const hex = pixelToHex(mapPos.x, mapPos.y);
					if (!config.hexcrawlState) {
						config.hexcrawlState = createDefaultHexcrawlState(config.mapId);
					}
					config.hexcrawlState.partyPosition = { col: hex.col, row: hex.row };
					this.saveMapAnnotations(config, el);
					redrawAnnotations();
					this.refreshHexcrawlView();
					const terrain = getTerrainDefinition(
						new HexcrawlTracker(config.hexcrawlState, config.hexTerrains || [], config.hexClimates || []).getTerrainAt(hex.col, hex.row)
					);
					new Notice(hLoc(hcLang, 'startPositionSet', { col: hex.col, row: hex.row, icon: terrain.icon, name: hLoc(hcLang, `terrain.${terrain.id}`) }));
					// Switch back to pan after placing
					setActiveTool('pan');
				} else if (activeTool === 'hex-desc') {
					// Edit per-tile custom description
					const hex = pixelToHex(mapPos.x, mapPos.y);
					if (!config.hexTerrains) config.hexTerrains = [];
					const existing = config.hexTerrains.find((ht: HexTerrain) => ht.col === hex.col && ht.row === hex.row);
					const terrainDef = getTerrainDefinition(existing?.terrain || 'plains');
					const currentDesc = existing?.customDescription;
					new HexDescriptionEditModal(
						this.app,
						hex.col,
						hex.row,
						`${terrainDef.icon} ${hLoc(hcLang, `terrain.${terrainDef.id}`)}`,
						currentDesc,
						(newDesc) => {
							if (!config.hexTerrains) config.hexTerrains = [];
							const idx = config.hexTerrains.findIndex((ht: HexTerrain) => ht.col === hex.col && ht.row === hex.row);
							if (idx >= 0) {
								if (newDesc) {
									config.hexTerrains[idx].customDescription = newDesc;
								} else {
									delete config.hexTerrains[idx].customDescription;
								}
							} else if (newDesc) {
								// No terrain entry yet ‚Äî create one with default 'plains'
								config.hexTerrains.push({ col: hex.col, row: hex.row, terrain: 'plains', customDescription: newDesc });
							}
							this.saveMapAnnotations(config, el);
							redrawTerrainLayer();
							new Notice(newDesc ? hLoc(hcLang, 'descSaved', { col: hex.col, row: hex.row }) : hLoc(hcLang, 'descCleared', { col: hex.col, row: hex.row }));
						},
						hcLang,
					).open();
				} else if (activeTool === 'hexcrawl-move') {
					// Travel to clicked hex using per-hex procedure
					const hex = pixelToHex(mapPos.x, mapPos.y);
					const hcState = config.hexcrawlState;
					if (!hcState || !hcState.enabled) {
						new Notice(hLoc(hcLang, 'enableHexcrawlFirst'));
						return;
					}
					// Only allow moving to an adjacent hex (distance === 1)
					if (hcState.partyPosition) {
						const dist = hexDistance(hcState.partyPosition.col, hcState.partyPosition.row, hex.col, hex.row);
						if (dist !== 1) {
							new Notice(hLoc(hcLang, 'mustMoveAdjacent'));
							return;
						}
					}
					// Capture party position BEFORE travel for animation
					const prevPartyPos = hcState.partyPosition ? { col: hcState.partyPosition.col, row: hcState.partyPosition.row } : null;
					const tracker = new HexcrawlTracker(hcState, config.hexTerrains || [], config.hexClimates || []);
					if (!tracker.canMoveToday()) {
						new Notice(hLoc(hcLang, 'noMovementBudget'));
						return;
					}
					openHexProcedureModal(this.app, this, tracker, hex.col, hex.row, config.customTerrainDescriptions).then((result) => {
						if (!result || !result.completed) return; // User cancelled
						// State is already mutated inside tracker by the modal
						config.hexcrawlState = tracker.toJSON();
						// Set pending travel animation for player view
						if (prevPartyPos) {
							(viewport as any)._pendingHexcrawlTravel = {
								fromCol: prevPartyPos.col, fromRow: prevPartyPos.row,
								toCol: hex.col, toRow: hex.row
							};
						}
						this.saveMapAnnotations(config, el);
						this.refreshHexcrawlView();
						redrawAnnotations();
						(viewport as any)._syncPlayerView();
						new Notice(hLoc(hcLang, 'traveledToHex', { col: hex.col, row: hex.row }));

						// Encounter battlemap creation is now handled via button in the travel log
					});
				}
        else if (activeTool === 'player-view') {
          // Check if clicking inside existing rect to move it (accounting for rotation)
          const existingRect = (this as any)._gmViewRect || (viewport as any)._gmViewRect;
          isMovingGmRect = false;
          if (existingRect && existingRect.w && existingRect.h) {
            // Transform click point to rect's local coordinate system
            const rotation = existingRect.rotation || 0;
            const centerX = existingRect.x + existingRect.w / 2;
            const centerY = existingRect.y + existingRect.h / 2;

            // Translate click to be relative to center
            const relX = mapPos.x - centerX;
            const relY = mapPos.y - centerY;

            // Rotate click point by negative rotation to get local coords
            const rad = (-rotation * Math.PI) / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const localX = relX * cos - relY * sin;
            const localY = relX * sin + relY * cos;

            // Check if local coords are inside rect bounds
            if (Math.abs(localX) <= existingRect.w / 2 && Math.abs(localY) <= existingRect.h / 2) {
              // Move existing rect - store offset in WORLD space (center-based)
              isMovingGmRect = true;
              // Keep gmDragCurrent for consistency
              gmDragCurrent = { x: mapPos.x, y: mapPos.y };
              isDraggingGmRect = true;
              viewport.style.cursor = 'grabbing';
              // Store world-space offset from mouse to rect center so movement is rotation-independent
              const centerX = existingRect.x + existingRect.w / 2;
              const centerY = existingRect.y + existingRect.h / 2;
              (this as any)._gmRectDragOffsetWorld = { x: mapPos.x - centerX, y: mapPos.y - centerY };
              try { console.log('[GM] Drag offset calculated', { mousePos: mapPos, rectCenter: { x: centerX, y: centerY }, offset: (this as any)._gmRectDragOffsetWorld, rotation: existingRect.rotation }); } catch (e) { }
            }
          }

          if (!isMovingGmRect) {
            // Start GM view-rect drag (create new rect)
            gmDragStart = { x: mapPos.x, y: mapPos.y };
            gmDragCurrent = { x: mapPos.x, y: mapPos.y };
            isDraggingGmRect = true;
            viewport.style.cursor = 'grabbing';
            // Reset any stored drag offsets
            (this as any)._gmRectDragOffset = null;
            (this as any)._gmRectDragOffsetWorld = null;

            // Calculate rect size and position as an unrotated footprint + rotation
            let rectW = Math.round(img.naturalWidth * 0.3);
            let rectH = Math.round(img.naturalHeight * 0.3);
            let currentRotation = 0;
            let targetScale = 1.0; // Default scale, may be updated by calibration
            // Center the rect where the user clicked
            const centerX = mapPos.x;
            const centerY = mapPos.y;
            try {
              if ((this as any)._playerMapViews && (this as any)._playerMapViews.size > 0) {
                const firstView = Array.from((this as any)._playerMapViews)[0] as any;
                if (firstView && firstView.mapContainer) {
                  const viewRect = firstView.mapContainer.getBoundingClientRect();
                  
                  // Use calibrated scale if available, otherwise use a reasonable default
                  const cal = this.settings?.tabletopCalibration;
                  
                  if (cal && cal.pixelsPerMm && config.gridSize > 0) {
                    // Calculate scale that makes grid match calibrated miniature size
                    const miniBaseMm = cal.miniBaseMm || 25;
                    targetScale = (cal.pixelsPerMm * miniBaseMm) / config.gridSize;
                    console.log('[GM] Using calibrated scale for rectangle', { targetScale, pixelsPerMm: cal.pixelsPerMm, miniBaseMm, gridSize: config.gridSize });
                  } else {
                    console.log('[GM] No calibration, using default scale 1.0');
                  }
                  
                  // Rectangle dimensions: viewport size divided by target scale
                  // This ensures the rectangle fits exactly what the player will see
                  rectW = Math.max(100, Math.round(viewRect.width / targetScale));
                  rectH = Math.max(100, Math.round(viewRect.height / targetScale));
                  currentRotation = 0; // Always start at 0¬∞, GM can rotate with Q/E keys
                  
                  console.log('[GM] Created rectangle', { rectW, rectH, viewportW: viewRect.width, viewportH: viewRect.height, targetScale });
                }
              }
            } catch (e) { console.error('[GM] rect size calculation error', e); }

            const rect = {
              x: Math.round(centerX - rectW / 2),
              y: Math.round(centerY - rectH / 2),
              w: rectW,
              h: rectH,
              rotation: currentRotation,
              targetScale: targetScale  // Store the calibrated scale for consistent zoom across rotations
            };
            try { (viewport as any)._gmViewRect = rect; } catch (e) { }
            try { (this as any)._gmViewRect = rect; } catch (e) { }
            redrawAnnotations();

            // Broadcast to player views (center-based approach)
            try {
              if ((this as any)._playerMapViews) {
                const mapId = config.mapId || resourcePath;
                (this as any)._playerMapViews.forEach((pv: any) => {
                  if ((pv as any).mapId !== mapId) return; // Only update views for this map
                  try {
                    // Use stored targetScale from rectangle (calibrated scale that should remain constant)
                    try {
                      const desiredScale = (rect as any).targetScale || 1.0;
                      try { console.log('[GM] setPVScale DEBUG', { 
                        site: 'initial-sync', 
                        scale: desiredScale,
                        rectDims: { w: rect.w, h: rect.h, rot: rect.rotation },
                        usingStoredScale: true
                      }); } catch (e) {}
                      if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
                      else (pv as any).tabletopScale = desiredScale;
                    } catch (e) { console.error('[GM] scale set error', e); }

                    // Send rectangle center to player view (center-based approach)
                    const centerX = rect.x + rect.w / 2;
                    const centerY = rect.y + rect.h / 2;
                    try { console.log('[GM] broadcastPan', { centerX, centerY, site: 'initial-sync' }); } catch (e) { }
                    if (typeof pv.setTabletopRotation === 'function') pv.setTabletopRotation(rect.rotation);
                    if (typeof pv.setTabletopPanFromImageCoords === 'function') pv.setTabletopPanFromImageCoords(centerX, centerY);
                  } catch (e) { }
                });
              }
            } catch (e) { }
          }
        }

				e.preventDefault();
			});

			viewport.addEventListener('mousemove', (e: MouseEvent) => {
				const mapPos = screenToMap(e.clientX, e.clientY);
				
				// Handle temporary pan from middle mouse button
				if (isTemporaryPan && isDragging) {
					translateX = e.clientX - startX;
					translateY = e.clientY - startY;
					updateTransform();
					return;
				}
				
				if (activeTool === 'pan' && isDragging) {
					translateX = e.clientX - startX;
					translateY = e.clientY - startY;
					updateTransform();
				} else if (activeTool === 'move-grid' && isDragging) {
					// Calculate delta in image-space pixels
					const rect = viewport.getBoundingClientRect();
					const scaleX = img.naturalWidth / img.width;
					const dx = ((e.clientX - startX) / scale) * scaleX;
					const dy = ((e.clientY - startY) / scale) * scaleX;
					config.gridOffsetX = (config.gridOffsetX || 0) + dx;
					config.gridOffsetY = (config.gridOffsetY || 0) + dy;
					startX = e.clientX;
					startY = e.clientY;
					// Redraw grid with new offset
					redrawGridOverlays();
					redrawAnnotations();
				} else if (activeTool === 'select' && draggingMarkerIndex >= 0) {
					// Dragging a marker
					const draggedMarker = config.markers[draggingMarkerIndex];
					const prevX = draggedMarker.position.x;
					const prevY = draggedMarker.position.y;
					
					// Check if marker is in a tunnel (traversing)
					if (draggedMarker.tunnelState && config.tunnels) {
						const tunnel = config.tunnels.find((t: any) => t.id === draggedMarker.tunnelState.tunnelId);
						if (tunnel && tunnel.path && tunnel.path.length > 0) {
							// Constrain movement to tunnel path
							// Find closest point on the tunnel path to the desired position
							const desiredPos = {
								x: mapPos.x + dragOffsetX,
								y: mapPos.y + dragOffsetY
							};
							
							let closestIndex = draggedMarker.tunnelState.pathIndex;
							let closestDistance = Infinity;
							
							// Search entire tunnel path since grid-snapped points may be far apart
							const startIdx = 0;
							const endIdx = tunnel.path.length - 1;
							
							for (let i = startIdx; i <= endIdx; i++) {
								const pathPoint = tunnel.path[i];
								const dx = desiredPos.x - pathPoint.x;
								const dy = desiredPos.y - pathPoint.y;
								const dist = Math.sqrt(dx * dx + dy * dy);
								
								if (dist < closestDistance) {
									closestDistance = dist;
									closestIndex = i;
								}
							}
							
							// Update pathIndex and snap to that point
							draggedMarker.tunnelState.pathIndex = closestIndex;
							draggedMarker.position = {
								x: tunnel.path[closestIndex].x,
								y: tunnel.path[closestIndex].y
							};
							// Update elevation to match tunnel path at this point
							const pathElevation = tunnel.path[closestIndex].elevation;
							if (pathElevation !== undefined) {
								if (!draggedMarker.elevation) draggedMarker.elevation = {};
								draggedMarker.elevation.depth = pathElevation;
							}
						} else {
							// Tunnel not found, allow free movement
							draggedMarker.position = {
								x: mapPos.x + dragOffsetX,
								y: mapPos.y + dragOffsetY
							};
						}
					} else {
						// Normal free movement
						draggedMarker.position = {
							x: mapPos.x + dragOffsetX,
							y: mapPos.y + dragOffsetY
						};
					}
					
					// Track tunnel path if marker is actively burrowing (creating a tunnel)
					if (draggedMarker.elevation?.isBurrowing && draggedMarker.elevation?.leaveTunnel && config.tunnels) {
						const activeTunnel = config.tunnels.find((t: any) => 
							t.creatorMarkerId === draggedMarker.id && t.active
						);
						if (activeTunnel && activeTunnel.path.length > 0) {
							// Snap path points to grid tile centers (every tile the token walks on)
							const gridSize = config.gridSize || 70;
							const ox = config.gridOffsetX || 0;
							const oy = config.gridOffsetY || 0;
							
							// Get creature size for proper grid snapping
							const markerDef = draggedMarker.markerId ? this.markerLibrary.getMarker(draggedMarker.markerId) : null;
							const CREATURE_SIZE_SQUARES: Record<string, number> = {
								'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
							};
							const sizeInSquares = markerDef?.creatureSize ? CREATURE_SIZE_SQUARES[markerDef.creatureSize] || 1 : 1;
							
							// Snap to grid tile center (every tile the token walks on)
							const halfToken = (sizeInSquares * gridSize) / 2;
							const col = Math.round((draggedMarker.position.x - ox - halfToken) / gridSize);
							const row = Math.round((draggedMarker.position.y - oy - halfToken) / gridSize);
							const snappedX = ox + col * gridSize + halfToken;
							const snappedY = oy + row * gridSize + halfToken;
							
							const lastPoint = activeTunnel.path[activeTunnel.path.length - 1];
							
							// Only add if we moved to a different grid cell
							if (snappedX !== lastPoint.x || snappedY !== lastPoint.y) {
								let shouldAdd = true;
								
								// Check for zig-zag (direction reversal)
								if (activeTunnel.path.length >= 2) {
									const prevPoint = activeTunnel.path[activeTunnel.path.length - 2];
									const prevDx = lastPoint.x - prevPoint.x;
									const prevDy = lastPoint.y - prevPoint.y;
									const newDx = snappedX - lastPoint.x;
									const newDy = snappedY - lastPoint.y;
									
									// Dot product < 0 means moving backwards (angle > 90¬∞)
									const dotProduct = prevDx * newDx + prevDy * newDy;
									if (dotProduct < 0) {
										// Moving backwards - update last point instead
										lastPoint.x = snappedX;
										lastPoint.y = snappedY;
										lastPoint.elevation = draggedMarker.elevation?.depth;
										shouldAdd = false;
										
										// Regenerate tunnel walls after updating last point
										if (activeTunnel.path.length >= 2) {
										const tunnelWidth = activeTunnel.tunnelWidth || (sizeInSquares + 0.5) * gridSize;
										activeTunnel.walls = generateTunnelWalls(activeTunnel.path, tunnelWidth);
									}
								}
							}
							
							if (shouldAdd) {
								activeTunnel.path.push({ 
									x: snappedX, 
									y: snappedY,
									elevation: draggedMarker.elevation?.depth
								});
							}
							
							// Regenerate tunnel walls after path update
							if (activeTunnel.path.length >= 2) {
								const tunnelWidth = activeTunnel.tunnelWidth || (sizeInSquares + 0.5) * gridSize;
								activeTunnel.walls = generateTunnelWalls(activeTunnel.path, tunnelWidth);
								console.log('[Tunnel Debug] Regenerated tunnel walls, count:', activeTunnel.walls.length);
							}
						}
					}
				}
				
				// Move anchored AoE effects with the marker
				const dxAoe = draggedMarker.position.x - prevX;
				const dyAoe = draggedMarker.position.y - prevY;
					if (dxAoe !== 0 || dyAoe !== 0) {
						config.aoeEffects.forEach((aoe: any) => {
							if (aoe.anchorMarkerId === draggedMarker.id) {
								aoe.origin.x += dxAoe;
								aoe.origin.y += dyAoe;
								aoe.end.x += dxAoe;
								aoe.end.y += dyAoe;
							}
						});
					}
					redrawAnnotations();
				} else if (activeTool === 'select' && draggingLightIndex >= 0) {
					// Dragging a light
					const draggedLight = config.lightSources[draggingLightIndex];
					draggedLight.x = mapPos.x + lightDragOffsetX;
					draggedLight.y = mapPos.y + lightDragOffsetY;
					redrawAnnotations();
				} else if (activeTool === 'select' && draggingWallIndex >= 0) {
					// Dragging a wall/door/window
					const draggedWall = config.walls[draggingWallIndex];
					draggedWall.start.x = mapPos.x + wallDragOffsetStartX;
					draggedWall.start.y = mapPos.y + wallDragOffsetStartY;
					draggedWall.end.x = mapPos.x + wallDragOffsetEndX;
					draggedWall.end.y = mapPos.y + wallDragOffsetEndY;
					redrawAnnotations();
				} else if (activeTool === 'draw' && isDrawing) {
					currentPath.push({ x: mapPos.x, y: mapPos.y });
					redrawAnnotations();
					
					// Draw temporary path
					if (annotationCanvas && currentPath.length > 1) {
						const ctx = annotationCanvas.getContext('2d');
						if (ctx) {
							const last = currentPath[currentPath.length - 1];
							const prev = currentPath[currentPath.length - 2];
							if (last && prev) {
								ctx.strokeStyle = selectedColor;
								ctx.lineWidth = 3;
								ctx.beginPath();
								ctx.moveTo(prev.x, prev.y);
								ctx.lineTo(last.x, last.y);
								ctx.stroke();
							}
						}
					}
				} else if (activeTool === 'ruler' && rulerStart && !rulerComplete) {
					// Show temporary ruler line (preview)
					rulerEnd = { x: mapPos.x, y: mapPos.y };
					redrawAnnotations();
				} else if (activeTool === 'aoe' && aoeOrigin) {
					// Update AoE preview
					aoePreviewEnd = { x: mapPos.x, y: mapPos.y };
					redrawAnnotations();
				} else if (activeTool === 'fog' && fogDragStart) {
					// Update fog drag preview
					fogDragEnd = { x: mapPos.x, y: mapPos.y };
					redrawAnnotations();
				} else if (activeTool === 'walls' && wallPoints.length > 0) {
					// Update wall preview position
					wallPreviewPos = { x: mapPos.x, y: mapPos.y };
					redrawAnnotations();
        } else if (activeTool === 'hexcrawl-move') {
					// Track hovered hex for travel range overlay
					const hex = pixelToHex(mapPos.x, mapPos.y);
					if (!hexcrawlMoveHoverHex || hexcrawlMoveHoverHex.col !== hex.col || hexcrawlMoveHoverHex.row !== hex.row) {
						hexcrawlMoveHoverHex = hex;
						redrawAnnotations();
						if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
					}
        } else if (activeTool === 'player-view' && isDraggingGmRect && gmDragStart) {
          // Update GM view rect as mouse moves
          gmDragCurrent = { x: mapPos.x, y: mapPos.y };
          const existingRect = (this as any)._gmViewRect || (viewport as any)._gmViewRect;
          let rect: any;
          
          // Check if we're moving an existing rect or creating a new one
          if (isMovingGmRect && existingRect) {
            // Moving existing rect: use WORLD-space offset so movement does not depend on rect rotation
            const off = (this as any)._gmRectDragOffsetWorld || { x: 0, y: 0 };
            // Rect center follows mouse minus stored world offset
            const centerX = mapPos.x - off.x;
            const centerY = mapPos.y - off.y;
            try { console.log('[GM] rect drag', { mousePos: mapPos, offset: off, newCenter: { x: centerX, y: centerY }, existingRect: { x: existingRect.x, y: existingRect.y, w: existingRect.w, h: existingRect.h } }); } catch (e) { }
            rect = {
              x: centerX - existingRect.w / 2,
              y: centerY - existingRect.h / 2,
              w: existingRect.w,
              h: existingRect.h,
              rotation: existingRect.rotation || 0,
              targetScale: existingRect.targetScale // Preserve calibrated scale during drag
            };
            try { console.log('[GM] new rect created', { rect: { x: rect.x, y: rect.y, w: rect.w, h: rect.h }, calculatedCenter: { x: rect.x + rect.w / 2, y: rect.y + rect.h / 2 } }); } catch (e) { }
          } else {
            // Creating new rect by dragging corners
            const x1 = Math.min(gmDragStart.x, gmDragCurrent.x);
            const y1 = Math.min(gmDragStart.y, gmDragCurrent.y);
            const x2 = Math.max(gmDragStart.x, gmDragCurrent.x);
            const y2 = Math.max(gmDragStart.y, gmDragCurrent.y);
            rect = {
              x: Math.round(x1),
              y: Math.round(y1),
              w: Math.max(1, Math.round(x2 - x1)),
              h: Math.max(1, Math.round(y2 - y1)),
              rotation: existingRect?.rotation || 0
            };
          }
          
          try { (viewport as any)._gmViewRect = rect; } catch (e) { }
          try { (this as any)._gmViewRect = rect; } catch (e) { }
          redrawAnnotations();
          // Broadcast to player views (center-based approach)
          try {
            if ((this as any)._playerMapViews) {
              const mapId = config.mapId || resourcePath;
              (this as any)._playerMapViews.forEach((pv: any) => {
                if ((pv as any).mapId !== mapId) return; // Only update views for this map
                try {
                  // Use stored targetScale from rectangle (remains constant during drag)
                  try {
                    const desiredScale = (rect as any).targetScale || 1.0;
                    try { console.log('[GM] setPVScale', { site: 'gm-rect-mousemove', scale: desiredScale, usingStoredScale: true }); } catch (e) {}
                    if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
                    else (pv as any).tabletopScale = desiredScale;
                  } catch (e) { }

                  // Send rectangle center to player view
                  const centerX = rect.x + rect.w / 2;
                  const centerY = rect.y + rect.h / 2;
                  try { console.log('[GM] broadcastPan', { centerX, centerY, site: 'gm-rect-mousemove' }); } catch (e) { }
                  try { if (typeof pv.setTabletopPanFromImageCoords === 'function') pv.setTabletopPanFromImageCoords(centerX, centerY); } catch (e) { }
                } catch (e) { }
              });
            }
          } catch (e) { }
				}
			});

// Double-click to finish polygon fog region or wall chain
		viewport.addEventListener('dblclick', (e: MouseEvent) => {
			// Ignore double-clicks on UI panels
			const target = e.target as Node;
			if (toolbarWrapper.contains(target) || playerViewBtn.contains(target) || controls.contains(target)) {
				return;
			}
			if (activeTool === 'fog' && selectedFogShape === 'polygon' && fogPolygonPoints.length >= 3) {
				const region = {
					id: `fog_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
					shape: 'polygon' as const,
					type: fogMode,
					points: [...fogPolygonPoints]
				};
				config.fogOfWar.enabled = true;
				config.fogOfWar.regions.push(region);
				fogPolygonPoints = [];
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
				new Notice(`Fog polygon ${fogMode === 'reveal' ? 'revealed' : 'hidden'}`);
				e.preventDefault();
				e.stopPropagation();
			} else if (activeTool === 'walls' && wallPoints.length >= 2) {
				// Finish wall chain - create wall segments
				saveToHistory();
				const wallDef = WALL_TYPES[selectedWallType];
				for (let i = 0; i < wallPoints.length - 1; i++) {
					const wall = {
						id: `wall_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
						type: selectedWallType,
						name: wallDef.name,
						start: { x: wallPoints[i]!.x, y: wallPoints[i]!.y },
						end: { x: wallPoints[i + 1]!.x, y: wallPoints[i + 1]!.y },
						open: false // For doors - starts closed
					};
					config.walls.push(wall);
				}
				wallPoints = [];
				wallPreviewPos = null;
				redrawAnnotations();
				this.saveMapAnnotations(config, el);
				new Notice(`${wallDef.name} chain saved (${config.walls.length} total segments)`);
					e.preventDefault();
					e.stopPropagation();
				}
			});

			viewport.addEventListener('mouseup', (e: MouseEvent) => {
				// Handle middle mouse button release - restore previous tool
				if (e.button === 1 && isTemporaryPan) {
					isDragging = false;
					isTemporaryPan = false;
					if (previousToolBeforePan) {
						setActiveTool(previousToolBeforePan);
						previousToolBeforePan = null;
					}
					return;
				}
				
				if (activeTool === 'pan' && isDragging) {
					isDragging = false;
					viewport.style.cursor = 'grab';
				} else if (activeTool === 'fog' && fogDragStart && fogDragEnd) {
					// Finalize fog region from drag
					const dx = fogDragEnd.x - fogDragStart.x;
					const dy = fogDragEnd.y - fogDragStart.y;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist > 5) {
						let region: any;
						if (selectedFogShape === 'brush' || selectedFogShape === 'rect') {
							region = {
								id: `fog_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
								shape: 'rect',
								type: fogMode,
								x: Math.min(fogDragStart.x, fogDragEnd.x),
								y: Math.min(fogDragStart.y, fogDragEnd.y),
								width: Math.abs(fogDragEnd.x - fogDragStart.x),
								height: Math.abs(fogDragEnd.y - fogDragStart.y)
							};
						} else if (selectedFogShape === 'circle') {
							region = {
								id: `fog_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
								shape: 'circle',
								type: fogMode,
								cx: fogDragStart.x,
								cy: fogDragStart.y,
								radius: dist
							};
						}
						if (region) {
							saveToHistory();
							config.fogOfWar.enabled = true;
							config.fogOfWar.regions.push(region);
							redrawAnnotations();
							this.saveMapAnnotations(config, el);
							new Notice(`Fog region ${fogMode === 'reveal' ? 'revealed' : 'hidden'}`);
						}
					}
					fogDragStart = null;
					fogDragEnd = null;
				} else if (activeTool === 'select' && draggingMarkerIndex >= 0) {
					// Drop marker: snap creature types to grid
					const m = config.markers[draggingMarkerIndex];
					const mDef = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
					
					// First snap the token to grid (if applicable)
					if (mDef && ['player', 'npc', 'creature'].includes(mDef.type) && config.gridSize) {
						const ox = config.gridOffsetX || 0;
						const oy = config.gridOffsetY || 0;
						const gs = config.gridSize;
						const squares = CREATURE_SIZE_SQUARES[mDef.creatureSize || 'medium'] || 1;
						const halfToken = (squares * gs) / 2;
						const col = Math.round((m.position.x - ox - halfToken) / gs);
						const row = Math.round((m.position.y - oy - halfToken) / gs);
						const snapDx = (ox + col * gs + halfToken) - m.position.x;
						const snapDy = (oy + row * gs + halfToken) - m.position.y;
						m.position.x = ox + col * gs + halfToken;
						m.position.y = oy + row * gs + halfToken;
						
						// Update anchored AoE effects with snap delta
						if (snapDx !== 0 || snapDy !== 0) {
							config.aoeEffects.forEach((aoe: any) => {
								if (aoe.anchorMarkerId === m.id) {
									aoe.origin.x += snapDx;
									aoe.origin.y += snapDy;
									aoe.end.x += snapDx;
									aoe.end.y += snapDy;
								}
							});
						}
					}
					
					// THEN finalize tunnel path AFTER token is snapped
					if (m.elevation?.isBurrowing && m.elevation?.leaveTunnel && config.tunnels) {
						const activeTunnel = config.tunnels.find((t: any) => 
							t.creatorMarkerId === m.id && t.active
						);
						if (activeTunnel && activeTunnel.path.length > 0) {
							// Snap final position to grid tile center (same logic as during movement)
							const gridSize = config.gridSize || 70;
							const ox = config.gridOffsetX || 0;
							const oy = config.gridOffsetY || 0;
							const CREATURE_SIZE_SQUARES: Record<string, number> = {
								'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
							};
							const sizeInSquares = mDef?.creatureSize ? CREATURE_SIZE_SQUARES[mDef.creatureSize] || 1 : 1;
							const halfToken = (sizeInSquares * gridSize) / 2;
							const col = Math.round((m.position.x - ox - halfToken) / gridSize);
							const row = Math.round((m.position.y - oy - halfToken) / gridSize);
							const snappedX = ox + col * gridSize + halfToken;
							const snappedY = oy + row * gridSize + halfToken;
							
							const lastPoint = activeTunnel.path[activeTunnel.path.length - 1];
							
							// Check if adding this point would create a zig-zag (direction reversal)
							if (snappedX !== lastPoint.x || snappedY !== lastPoint.y) {
								let shouldAdd = true;
								
								if (activeTunnel.path.length >= 2) {
									const prevPoint = activeTunnel.path[activeTunnel.path.length - 2];
									// Calculate previous direction
									const prevDx = lastPoint.x - prevPoint.x;
									const prevDy = lastPoint.y - prevPoint.y;
									// Calculate new direction
									const newDx = snappedX - lastPoint.x;
									const newDy = snappedY - lastPoint.y;
									
									// Check for direction reversal (moving backwards)
									// Dot product < 0 means angle > 90¬∞, which is moving backwards
									const dotProduct = prevDx * newDx + prevDy * newDy;
									if (dotProduct < 0) {
										// This would create a zig-zag - update last point instead of adding
										lastPoint.x = snappedX;
										lastPoint.y = snappedY;
										lastPoint.elevation = m.elevation?.depth;
										shouldAdd = false;
									}
								}
								
								if (shouldAdd) {
									activeTunnel.path.push({ x: snappedX, y: snappedY, elevation: m.elevation?.depth });
								}
							}
						}
					}
					draggingMarkerIndex = -1;
					markerDragOrigin = null;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					// Sync to player views (includes tunnel path updates)
					if ((viewport as any)._syncPlayerView) {
						(viewport as any)._syncPlayerView();
					}
				} else if (activeTool === 'select' && draggingLightIndex >= 0) {
					// Drop light: save position
					draggingLightIndex = -1;
					lightDragOrigin = null;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					// Sync to player views
					if ((viewport as any)._syncPlayerView) {
						(viewport as any)._syncPlayerView();
					}
				} else if (activeTool === 'select' && draggingWallIndex >= 0) {
					// Drop wall/door/window: save position
					draggingWallIndex = -1;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					// Sync to player views
					if ((viewport as any)._syncPlayerView) {
						(viewport as any)._syncPlayerView();
					}
				} else if (activeTool === 'move-grid' && isDragging) {
					isDragging = false;
					viewport.style.cursor = 'move';
					// Save offset
					this.saveMapAnnotations(config, el);
        } else if (activeTool === 'player-view' && isDraggingGmRect) {
          // Finish GM rect drag
          isDraggingGmRect = false;
          isMovingGmRect = false;
          viewport.style.cursor = 'crosshair';
          // Ensure rect exists on plugin + viewport
          const rect = (viewport as any)._gmViewRect || (this as any)._gmViewRect || null;
          if (rect) {
            try { (this as any)._gmViewRect = rect; } catch (e) { }
            try { (viewport as any)._gmViewRect = rect; } catch (e) { }
            // Broadcast to player views (center-based approach)
            try {
              if ((this as any)._playerMapViews) {
                const mapId = config.mapId || resourcePath;
                (this as any)._playerMapViews.forEach((pv: any) => {
                  if ((pv as any).mapId !== mapId) return; // Only update views for this map
                  try {
                    // Send rectangle center to player view (center-based approach)
                    const centerX = rect.x + rect.w / 2;
                    const centerY = rect.y + rect.h / 2;
                    try { console.log('[GM] broadcastPan', { centerX, centerY, site: 'open-player-view' }); } catch (e) { }
                    if (typeof pv.setTabletopRotation === 'function') pv.setTabletopRotation(rect.rotation);
                    if (typeof pv.setTabletopPanFromImageCoords === 'function') pv.setTabletopPanFromImageCoords(centerX, centerY);
                  } catch (e) { }
                });
              }
            } catch (e) { }
          }
				} else if (activeTool === 'draw' && isDrawing) {
					isDrawing = false;
					if (currentPath.length > 2) {
						saveToHistory();
						config.drawings.push({
							id: `drawing_${Date.now()}`,
							type: 'freehand',
							points: currentPath,
							color: selectedColor,
							strokeWidth: 3,
							layer: config.activeLayer || 'Player'
						});
						this.saveMapAnnotations(config, el);
						updateGridToolsVisibility();
					}
					currentPath = [];
					redrawAnnotations();
				}
			});

			viewport.addEventListener('mouseleave', () => {
				if (activeTool === 'pan' && isDragging) {
					isDragging = false;
					viewport.style.cursor = 'grab';
				} else if (activeTool === 'select' && draggingMarkerIndex >= 0) {
					draggingMarkerIndex = -1;
					markerDragOrigin = null;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
				} else if (activeTool === 'select' && draggingLightIndex >= 0) {
					draggingLightIndex = -1;
					lightDragOrigin = null;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
				} else if (activeTool === 'select' && draggingWallIndex >= 0) {
					draggingWallIndex = -1;
					viewport.style.cursor = 'default';
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
				} else if (activeTool === 'move-grid' && isDragging) {
					isDragging = false;
					viewport.style.cursor = 'move';
					this.saveMapAnnotations(config, el);
				} else if (activeTool === 'draw' && isDrawing) {
					isDrawing = false;
					currentPath = [];
					redrawAnnotations();
				} else if (activeTool === 'ruler') {
					// Clear preview line on mouseup if ruler not complete
					if (rulerStart && !rulerComplete) {
						rulerEnd = null;
						redrawAnnotations();
					}
				}
			});

			// Listen for player view rect updates from player window panning
			viewport.addEventListener('gm-rect-updated', () => {
				redrawAnnotations();
			});

			// Keyboard shortcuts for player-view rotation
			viewport.addEventListener('keydown', (e: KeyboardEvent) => {
				// Tunnel traversal with arrow keys
				if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
					const selectedMarkerIdx = config.markers.findIndex((m: any) => m.tunnelState);
					if (selectedMarkerIdx >= 0) {
						const marker = config.markers[selectedMarkerIdx];
						const tunnel = config.tunnels?.find((t: any) => t.id === marker.tunnelState.tunnelId);
						
						if (tunnel && tunnel.path.length > 0) {
							e.preventDefault();
							saveToHistory();
							
							let newIndex = marker.tunnelState.pathIndex;
							
							// Arrow keys move forward/backward along path
							if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
								// Move forward in tunnel
								newIndex = Math.min(tunnel.path.length - 1, newIndex + 1);
							} else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
								// Move backward in tunnel
								newIndex = Math.max(0, newIndex - 1);
							}
							
							// Update position and path index
							if (newIndex !== marker.tunnelState.pathIndex) {
								marker.tunnelState.pathIndex = newIndex;
								const newPos = tunnel.path[newIndex];
								marker.position.x = newPos.x;
								marker.position.y = newPos.y;
								// Update elevation to match tunnel path at this point
								if (newPos.elevation !== undefined) {
									if (!marker.elevation) marker.elevation = {};
									marker.elevation.depth = newPos.elevation;
								}
								const progress = Math.round((newIndex / (tunnel.path.length - 1)) * 100);
								new Notice(`Tunnel progress: ${progress}%`, 1000);
							} else if (newIndex === tunnel.path.length - 1 && (e.key === 'ArrowUp' || e.key === 'ArrowRight')) {
								// Reached end of tunnel
								new Notice('Reached tunnel exit - right-click to exit tunnel');
							} else if (newIndex === 0 && (e.key === 'ArrowDown' || e.key === 'ArrowLeft')) {
								// Reached start of tunnel
								new Notice('Reached tunnel entrance - right-click to exit tunnel');
							}
						}
					}
				}
				
				// Walls tool: Enter to finish, Escape to cancel
				if (activeTool === 'walls') {
					if (e.key === 'Enter' && wallPoints.length >= 2) {
						// Finish wall chain - create wall segments
						e.preventDefault();
						saveToHistory();
						const wallDef = WALL_TYPES[selectedWallType];
						for (let i = 0; i < wallPoints.length - 1; i++) {
							const wall = {
								id: `wall_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
								type: selectedWallType,
								name: wallDef.name,
								start: { x: wallPoints[i]!.x, y: wallPoints[i]!.y },
								end: { x: wallPoints[i + 1]!.x, y: wallPoints[i + 1]!.y },
								open: false
							};
							config.walls.push(wall);
						}
						wallPoints = [];
						wallPreviewPos = null;
						redrawAnnotations();
						this.saveMapAnnotations(config, el);
						new Notice(`${wallDef.name} chain added (${config.walls.length} segments total)`);
					} else if (e.key === 'Escape') {
						// Cancel wall drawing
						e.preventDefault();
						wallPoints = [];
						wallPreviewPos = null;
						redrawAnnotations();
						new Notice('Wall drawing cancelled');
					}
				}
				
				if (activeTool === 'player-view') {
					const gmRect = (this as any)._gmViewRect || (viewport as any)._gmViewRect;
					if (!gmRect) return;
					
					if (e.key === 'q' || e.key === 'Q' || e.key === '[') {
						// Rotate counterclockwise 90 degrees - keep center fixed
						e.preventDefault();
						
						// Calculate current center
						const oldCenterX = gmRect.x + gmRect.w / 2;
						const oldCenterY = gmRect.y + gmRect.h / 2;
						
						// Update rotation (w/h stay the same, canvas rotation handles visual)
						gmRect.rotation = ((gmRect.rotation || 0) - 90 + 360) % 360;
						
						// Keep center fixed, recalculate top-left (w/h unchanged)
						gmRect.x = Math.round(oldCenterX - gmRect.w / 2);
						gmRect.y = Math.round(oldCenterY - gmRect.h / 2);
						
						// Clear drag offset so it gets recalculated on next click
						(this as any)._gmRectDragOffsetWorld = null;
						try { console.log('[GM] Rotation CCW, offset cleared', { rotation: gmRect.rotation }); } catch (e) { }
						
						redrawAnnotations();
						
						// Broadcast rotation and position to player views
						try {
							if ((this as any)._playerMapViews) {
                                const mapId = config.mapId || resourcePath;
                                const centerX = gmRect.x + gmRect.w / 2;
                                const centerY = gmRect.y + gmRect.h / 2;
                (this as any)._playerMapViews.forEach((pv: any) => {
                  if ((pv as any).mapId !== mapId) return; // Only update views for this map
                  try {
                    // set PV scale to project GM rect into PV viewport
                    try {
                      const bounds = getRotatedRectBoundingSize(gmRect);
                      const wrap = pv?.mapContainer as HTMLElement | undefined;
                      if (wrap && bounds.w > 0 && bounds.h > 0) {
                        const r = wrap.getBoundingClientRect();
                        const desiredScale = Math.max(0.001, Math.min(100, Math.min(r.width / bounds.w, r.height / bounds.h)));
                        try { console.log('[GM] setPVScale DEBUG', { site: 'rotate-ccw', scale: desiredScale, rectDims: { w: gmRect.w, h: gmRect.h, rot: gmRect.rotation }, bounds, viewportDims: { w: r.width, h: r.height } }); } catch (e) {}
                        if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
                        else (pv as any).tabletopScale = desiredScale;
                      }
                    } catch (e) { }

                    try { console.log('[GM] broadcastPan', { centerX, centerY, site: 'rotate-ccw' }); } catch (e) { }
                    if (typeof pv.setTabletopRotation === 'function') {
                      pv.setTabletopRotation(gmRect.rotation);
                    }
                    if (typeof pv.setTabletopPanFromImageCoords === 'function') {
                      pv.setTabletopPanFromImageCoords(centerX, centerY);
                    }
                  } catch (e) { }
                });
							}
						} catch (e) { }
					} else if (e.key === 'e' || e.key === 'E' || e.key === ']') {
						// Rotate clockwise 90 degrees - keep center fixed
						e.preventDefault();
						
						// Calculate current center
						const oldCenterX = gmRect.x + gmRect.w / 2;
						const oldCenterY = gmRect.y + gmRect.h / 2;
						
						// Update rotation (w/h stay the same, canvas rotation handles visual)
						gmRect.rotation = ((gmRect.rotation || 0) + 90) % 360;
						
						// Keep center fixed, recalculate top-left (w/h unchanged)
						gmRect.x = Math.round(oldCenterX - gmRect.w / 2);
						gmRect.y = Math.round(oldCenterY - gmRect.h / 2);
						
						// Clear drag offset so it gets recalculated on next click
						(this as any)._gmRectDragOffsetWorld = null;
						try { console.log('[GM] Rotation CW, offset cleared', { rotation: gmRect.rotation }); } catch (e) { }
						
						redrawAnnotations();
						
						// Broadcast rotation and position to player views
						try {
							if ((this as any)._playerMapViews) {
                                const mapId = config.mapId || resourcePath;
                                const centerX = gmRect.x + gmRect.w / 2;
                                const centerY = gmRect.y + gmRect.h / 2;
                (this as any)._playerMapViews.forEach((pv: any) => {
                  if ((pv as any).mapId !== mapId) return; // Only update views for this map
                  try {
                    // Use stored targetScale instead of recalculating from rotated bounds
                    // The scale represents image-pixels-per-screen-pixel and should remain constant across rotations
                    try {
                      const desiredScale = (gmRect as any).targetScale || 1.0;
                      try { console.log('[GM] setPVScale DEBUG', { site: 'rotate-cw', scale: desiredScale, rectDims: { w: gmRect.w, h: gmRect.h, rot: gmRect.rotation }, usingStoredScale: true }); } catch (e) {}
                      if (typeof pv.setTabletopScale === 'function') pv.setTabletopScale(desiredScale as number);
                      else (pv as any).tabletopScale = desiredScale;
                    } catch (e) { }

                    try { console.log('[GM] broadcastPan', { centerX, centerY, site: 'rotate-cw' }); } catch (e) { }
                    if (typeof pv.setTabletopRotation === 'function') {
                      pv.setTabletopRotation(gmRect.rotation);
                    }
                    if (typeof pv.setTabletopPanFromImageCoords === 'function') {
                      pv.setTabletopPanFromImageCoords(centerX, centerY);
                    }
                  } catch (e) { }
                });
							}
						} catch (e) { }
					}
				}
			});

			// Right-click for marker context menu
			viewport.addEventListener('contextmenu', (e: MouseEvent) => {
				// Ignore right-clicks on UI panels
				const target = e.target as Node;
				if (toolbarWrapper.contains(target) || playerViewBtn.contains(target) || controls.contains(target)) {
					return;
				}
				const mapPos = screenToMap(e.clientX, e.clientY);
				
				// Helper functions for tunnel detection
				const isNearTunnelEntrance = (position: { x: number; y: number }, gridSize: number): { tunnel: any; distance: number } | null => {
					if (!config.tunnels || config.tunnels.length === 0) return null;
					
					const threshold = gridSize * 1.5; // Proximity threshold
					let nearest: { tunnel: any; distance: number } | null = null;
					
					for (const tunnel of config.tunnels) {
						const entrance = tunnel.entrancePosition;
						const dist = Math.sqrt(Math.pow(position.x - entrance.x, 2) + Math.pow(position.y - entrance.y, 2));
						if (dist <= threshold) {
							if (!nearest || dist < nearest.distance) {
								nearest = { tunnel, distance: dist };
							}
						}
					}
					return nearest;
				};
				
				const isNearTunnelExit = (position: { x: number; y: number }, gridSize: number): { tunnel: any; distance: number } | null => {
					if (!config.tunnels || config.tunnels.length === 0) return null;
					
					const threshold = gridSize * 1.5; // Proximity threshold
					let nearest: { tunnel: any; distance: number } | null = null;
					
					for (const tunnel of config.tunnels) {
						if (tunnel.path.length > 0) {
							const exit = tunnel.path[tunnel.path.length - 1];
							const dist = Math.sqrt(Math.pow(position.x - exit.x, 2) + Math.pow(position.y - exit.y, 2));
							if (dist <= threshold) {
								if (!nearest || dist < nearest.distance) {
									nearest = { tunnel, distance: dist };
								}
							}
						}
					}
					return nearest;
				};
				
				for (let i = config.markers.length - 1; i >= 0; i--) {
					const m = config.markers[i];
					const mDef = m.markerId ? this.markerLibrary.getMarker(m.markerId) : null;
					const r = mDef ? getMarkerRadius(mDef) : 15;
					const dist = Math.sqrt(Math.pow(m.position.x - mapPos.x, 2) + Math.pow(m.position.y - mapPos.y, 2));
					if (dist <= r) {
						e.preventDefault();
						
						// Create context menu
						const contextMenu = document.createElement('div');
						contextMenu.addClass('dnd-map-context-menu');
						contextMenu.style.position = 'fixed';
						contextMenu.style.left = `${e.clientX}px`;
						contextMenu.style.top = `${e.clientY}px`;
						
						// Layer submenu header
						const layerHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
						layerHeader.textContent = 'Move to Layer:';
						
						// Layer options
						const layers: Layer[] = ['Player', 'Elevated', 'Subterranean', 'DM', 'Background'];
						const currentLayer = m.layer || 'Player';
						layers.forEach(layer => {
							const option = contextMenu.createDiv({ 
								cls: 'dnd-map-context-menu-item' + (layer === currentLayer ? ' active' : '')
							});
							const layerIcons: Record<Layer, string> = { 
								'Player': 'üë•', 
								'Elevated': 'ü¶Ö',
								'Subterranean': 'üï≥Ô∏è',
								'DM': 'üé≤', 
								'Background': 'üó∫Ô∏è'
							};
							option.innerHTML = `<span class="layer-icon">${layerIcons[layer]}</span> ${layer}`;
							option.addEventListener('click', () => {
								m.layer = layer;
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								document.body.removeChild(contextMenu);
								new Notice(`Marker moved to ${layer} layer`);
							});
						});
						
						// Separator
						contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
						
						// Show to Players toggle (for non-player tokens)
						if (mDef && mDef.type !== 'player') {
							const visibilityRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							visibilityRow.style.cursor = 'pointer';
							const visibilityLabel = visibilityRow.createEl('span', { 
								cls: 'dnd-map-context-aoe-label', 
								text: 'Show to Players:' 
							});
							const visibilityToggle = visibilityRow.createEl('input', {
								type: 'checkbox',
								cls: 'dnd-map-visibility-checkbox'
							});
							visibilityToggle.checked = m.visibleToPlayers || false;
							visibilityToggle.addEventListener('change', (e) => {
								e.stopPropagation();
								saveToHistory();
								m.visibleToPlayers = visibilityToggle.checked;
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								new Notice(m.visibleToPlayers ? 'Token visible to players' : 'Token hidden from players');
							});
							visibilityRow.addEventListener('click', (e) => {
								if (e.target !== visibilityToggle) {
									visibilityToggle.checked = !visibilityToggle.checked;
									visibilityToggle.dispatchEvent(new Event('change'));
								}
							});
						}
						
						// AoE compact picker for player/creature/npc tokens
						if (mDef && ['player', 'npc', 'creature'].includes(mDef.type)) {
							const aoeRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							const aoeLabel = aoeRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'AoE:' });
							// Find existing anchored AoE for this token
							const existingAoeIdx = config.aoeEffects.findIndex((a: any) => a.anchorMarkerId === m.id);
							const existingAoeShape = existingAoeIdx >= 0 ? config.aoeEffects[existingAoeIdx].shape : null;
							const aoeOptions: { shape: 'circle' | 'cone' | 'square' | 'line'; icon: string; label: string }[] = [
								{ shape: 'circle', icon: '‚≠ï', label: 'Circle' },
								{ shape: 'cone', icon: 'üî∫', label: 'Cone' },
								{ shape: 'square', icon: '‚¨ú', label: 'Square' },
								{ shape: 'line', icon: '‚ûñ', label: 'Line' },
							];
							aoeOptions.forEach(({ shape, icon, label }) => {
								const btn = aoeRow.createEl('button', {
									cls: 'dnd-map-aoe-shape-btn' + (shape === existingAoeShape ? ' active' : ''),
									attr: { title: label }
								});
								btn.createEl('span', { text: icon });
								btn.addEventListener('click', () => {
									// Remove any existing anchored AoE for this token
									const oldIdx = config.aoeEffects.findIndex((a: any) => a.anchorMarkerId === m.id);
									if (oldIdx >= 0) {
										saveToHistory();
										const oldShape = config.aoeEffects[oldIdx].shape;
										config.aoeEffects.splice(oldIdx, 1);
										// If same shape clicked, just remove (toggle off)
										if (oldShape === shape) {
											redrawAnnotations();
											this.saveMapAnnotations(config, el);
											updateGridToolsVisibility();
											document.body.removeChild(contextMenu);
											new Notice('AoE effect removed');
											return;
										}
									}
									// Start new AoE placement
									selectedAoeShape = shape;
									aoeShapeButtons.forEach((b) => b.removeClass('active'));
									const shapeBtn = aoeShapeButtons.get(shape);
									if (shapeBtn) shapeBtn.addClass('active');
									aoeOrigin = { x: m.position.x, y: m.position.y };
									aoePreviewEnd = aoeOrigin;
									pendingAoeAnchorMarkerId = m.id;
									setActiveTool('aoe');
									document.body.removeChild(contextMenu);
									new Notice(`Place ${label}: move mouse to set size, click to confirm`);
								});
							});
							
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
						}
						
						// Light source picker for player/creature/npc tokens
						if (mDef && ['player', 'npc', 'creature'].includes(mDef.type)) {
							const lightRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							lightRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'Light:' });
							
							// Check if marker has an attached light
							const currentLight = m.light?.type || null;
							
							// Common light options for quick access
							const lightOptions: { type: LightSourceType; icon: string; label: string }[] = [
								{ type: 'candle', icon: 'üïØÔ∏è', label: 'Candle (5ft)' },
								{ type: 'torch', icon: 'üî•', label: 'Torch (20ft)' },
								{ type: 'lantern', icon: 'üèÆ', label: 'Lantern (30ft)' },
								{ type: 'light', icon: '‚ú®', label: 'Light Spell (20ft)' },
								{ type: 'daylight', icon: '‚òÄÔ∏è', label: 'Daylight (60ft)' },
							];
							
							// Add "Off" button
							const offBtn = lightRow.createEl('button', {
								cls: 'dnd-map-aoe-shape-btn' + (currentLight === null ? ' active' : ''),
								attr: { title: 'No Light' }
							});
							offBtn.createEl('span', { text: '‚ùå' });
							offBtn.addEventListener('click', () => {
								saveToHistory();
								delete m.light;
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								refreshVisionSelector();
								document.body.removeChild(contextMenu);
								new Notice('Light removed from token');
							});
							
							lightOptions.forEach(({ type, icon, label }) => {
								const btn = lightRow.createEl('button', {
									cls: 'dnd-map-aoe-shape-btn' + (type === currentLight ? ' active' : ''),
									attr: { title: label }
								});
								btn.createEl('span', { text: icon });
								btn.addEventListener('click', () => {
									saveToHistory();
									// Attach light to marker
									const lightDef = LIGHT_SOURCES[type];
									m.light = {
										type: type,
										bright: lightDef.bright,
										dim: lightDef.dim,
										name: lightDef.name
									};
									redrawAnnotations();
									this.saveMapAnnotations(config, el);
									if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									refreshVisionSelector();
									document.body.removeChild(contextMenu);
									new Notice(`${lightDef.name} attached to token`);
								});
							});
							
							// Darkvision input
							const darkRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							darkRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'Darkvision:' });
							const darkInput = darkRow.createEl('input', {
								cls: 'dnd-map-darkvision-input',
								attr: { 
									type: 'number', 
									min: '0', 
									max: '300',
									step: '5',
									placeholder: '0',
									value: m.darkvision || ''
								}
							});
							darkRow.createEl('span', { text: 'ft' });
							
							darkInput.addEventListener('change', () => {
								saveToHistory();
								const value = parseInt(darkInput.value) || 0;
								if (value > 0) {
									m.darkvision = value;
								} else {
									delete m.darkvision;
								}
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								refreshVisionSelector();
								new Notice(value > 0 ? `Darkvision set to ${value} ft` : 'Darkvision removed');
							});
							
							darkInput.addEventListener('click', (e) => e.stopPropagation());
							darkInput.addEventListener('keydown', (e) => {
								if (e.key === 'Enter') {
									darkInput.blur();
								}
							});
							
							// Border Color control
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							const borderHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							borderHeader.innerHTML = 'üé® Appearance';
							
							const borderRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							borderRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'Border Color:' });
							
							const borderColorPicker = borderRow.createEl('input', {
								cls: 'dnd-map-border-color-picker',
								attr: {
									type: 'color',
									value: (m as any).borderColor || mDef?.borderColor || '#ffffff'
								}
							});
							borderColorPicker.style.width = '60px';
							borderColorPicker.style.height = '30px';
							borderColorPicker.style.border = 'none';
							borderColorPicker.style.cursor = 'pointer';
							
							borderColorPicker.addEventListener('change', () => {
								saveToHistory();
								(m as any).borderColor = borderColorPicker.value;
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								new Notice('Border color updated');
							});
							
							borderColorPicker.addEventListener('click', (e) => e.stopPropagation());
							
							const borderResetBtn = borderRow.createEl('button', {
								cls: 'dnd-map-context-reset-btn',
								text: 'Reset'
							});
							borderResetBtn.style.marginLeft = '8px';
							borderResetBtn.style.padding = '4px 8px';
							borderResetBtn.style.fontSize = '11px';
							borderResetBtn.addEventListener('click', () => {
								saveToHistory();
								delete (m as any).borderColor;
								borderColorPicker.value = mDef?.borderColor || '#ffffff';
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								new Notice('Border color reset to default');
							});
							
							// Elevation controls (height and depth)
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							const elevationHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							elevationHeader.innerHTML = '‚ÜïÔ∏è Elevation';
							
							console.log('[Elevation Debug] Context menu opened. Marker:', m.id, 'Elevation:', JSON.stringify(m.elevation, null, 2), 'mDef:', mDef?.name);
							
							// Helper function to update token layer based on elevation
							const updateTokenLayer = (marker: any) => {
								const elevation = marker.elevation;
								
								if (!elevation || (!elevation.height && !elevation.depth)) {
									marker.layer = 'Player';
								} else if (elevation.depth && elevation.depth > 0) {
									if (elevation.isBurrowing) {
										marker.layer = 'DM';  // Hidden from players
									} else {
										marker.layer = 'Subterranean';  // Visible but marked
									}
								} else if (elevation.height && elevation.height > 0) {
									marker.layer = 'Elevated';  // Visible with indicator
								}
							};
							
							// Height input (flying)
							const heightRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							heightRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'Height:' });
							const heightInput = heightRow.createEl('input', {
								cls: 'dnd-map-darkvision-input',
								attr: { 
									type: 'number', 
									min: '0', 
									max: '500',
									step: '5',
									placeholder: '0',
									value: m.elevation?.height || ''
								}
							});
							heightRow.createEl('span', { text: 'ft' });
							
							heightInput.addEventListener('change', () => {
								saveToHistory();
								const value = parseInt(heightInput.value) || 0;
								if (!m.elevation) m.elevation = {};
								
								if (value > 0) {
									m.elevation.height = value;
									// Clear depth when setting height
									delete m.elevation.depth;
									delete m.elevation.isBurrowing;
									depthInput.value = '';
								} else {
									delete m.elevation.height;
								}
								
								// Auto-update layer based on elevation
								updateTokenLayer(m);
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								new Notice(value > 0 ? `Token flying at ${value} ft` : 'Token returned to ground');
							});
							
							heightInput.addEventListener('click', (e) => e.stopPropagation());
							heightInput.addEventListener('keydown', (e) => {
								if (e.key === 'Enter') {
									heightInput.blur();
								}
							});
							
							// Depth input (burrowing)
							const depthRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
							depthRow.createEl('span', { cls: 'dnd-map-context-aoe-label', text: 'Depth:' });
							const depthInput = depthRow.createEl('input', {
								cls: 'dnd-map-darkvision-input',
								attr: { 
									type: 'number', 
									min: '0', 
									max: '500',
									step: '5',
									placeholder: '0',
									value: m.elevation?.depth || ''
								}
							});
							depthRow.createEl('span', { text: 'ft' });
							
							depthInput.addEventListener('change', () => {
								saveToHistory();
								const value = parseInt(depthInput.value) || 0;
								if (!m.elevation) m.elevation = {};
								
								if (value > 0) {
									m.elevation.depth = value;
									m.elevation.isBurrowing = true; // Automatically burrow when depth is set
								m.elevation.leaveTunnel = true; // Enable tunnel path tracking during movement
								
								// Clear height when setting depth
								delete m.elevation.height;
								heightInput.value = '';
								
								// Automatically create tunnel entrance
								if (!config.tunnels) config.tunnels = [];
								console.log('[Tunnel Debug] Creating tunnel. Current tunnels:', config.tunnels.length, 'Marker:', m.id);
								
								// Check if tunnel already exists for this marker
								let tunnel = config.tunnels.find((t: any) => t.creatorMarkerId === m.id && t.active);
								if (!tunnel) {
									// Snap entrance to grid tile center (same as token placement)
									const gridSize = config.gridSize || 70;
									const ox = config.gridOffsetX || 0;
									const oy = config.gridOffsetY || 0;
									
									// Calculate tunnel width based on creature size (slightly larger than token)
									const CREATURE_SIZE_SQUARES: Record<string, number> = {
										'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
									};
									const creatureSize = mDef.creatureSize || 'medium';
									const sizeInSquares = CREATURE_SIZE_SQUARES[creatureSize] || 1;
									// Tunnel width = creature size + 0.5 grid squares (slightly larger)
									const tunnelWidth = (sizeInSquares + 0.5) * gridSize;
									
									// Snap to grid tile center (same as token snapping)
									const halfToken = (sizeInSquares * gridSize) / 2;
									const col = Math.round((m.position.x - ox - halfToken) / gridSize);
									const row = Math.round((m.position.y - oy - halfToken) / gridSize);
									const snappedX = ox + col * gridSize + halfToken;
									const snappedY = oy + row * gridSize + halfToken;
									
									// Create new tunnel with entrance at snapped position
									tunnel = {
										id: `tunnel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
										creatorMarkerId: m.id,
										entrancePosition: { x: snappedX, y: snappedY },
										path: [{ x: snappedX, y: snappedY, elevation: value }],
										creatureSize: creatureSize,
										depth: value,
										createdAt: Date.now(),
										visible: true,
										active: true,
										tunnelWidth: tunnelWidth,
										walls: [] // Will be generated when path has multiple points
									};
									config.tunnels.push(tunnel);
									console.log('[Tunnel Debug] Created NEW tunnel with entrance at', tunnel.entrancePosition, 'width:', tunnelWidth, JSON.stringify(tunnel, null, 2));
								}
							} else {
								// Depth set to 0 - surface automatically and mark exit
								delete m.elevation.depth;
								delete m.elevation.isBurrowing;
								delete m.elevation.leaveTunnel;
								
								// Mark exit position and deactivate tunnel
								if (config.tunnels) {
									// Snap exit to grid tile center
									const gridSize = config.gridSize || 70;
									const ox = config.gridOffsetX || 0;
									const oy = config.gridOffsetY || 0;
									const CREATURE_SIZE_SQUARES: Record<string, number> = {
										'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
									};
									const sizeInSquares = mDef?.creatureSize ? CREATURE_SIZE_SQUARES[mDef.creatureSize] || 1 : 1;
									const halfToken = (sizeInSquares * gridSize) / 2;
									const col = Math.round((m.position.x - ox - halfToken) / gridSize);
									const row = Math.round((m.position.y - oy - halfToken) / gridSize);
									const snappedX = ox + col * gridSize + halfToken;
									const snappedY = oy + row * gridSize + halfToken;
									
									config.tunnels.forEach((t: any) => {
										if (t.creatorMarkerId === m.id && t.active) {
											// Add current position as exit if not already in path
											const lastPos = t.path[t.path.length - 1];
											if (!lastPos || lastPos.x !== snappedX || lastPos.y !== snappedY) {
												t.path.push({ x: snappedX, y: snappedY, elevation: 0 }); // Exit is at surface
											}
											t.active = false;
											console.log('[Tunnel Debug] Tunnel exit marked at', { x: snappedX, y: snappedY }, 'Path length:', t.path.length);
										}
									});
								}
							}
							
							// Auto-update layer based on elevation
							updateTokenLayer(m);
							redrawAnnotations();
							this.saveMapAnnotations(config, el);
							if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
							new Notice(value > 0 ? `Token burrowed ${value} ft underground` : 'Token surfaced');
						});
							
							depthInput.addEventListener('click', (e) => e.stopPropagation());
							depthInput.addEventListener('keydown', (e) => {
								if (e.key === 'Enter') {
									depthInput.blur();
								}
							});
							
							// Tunnel Traversal section (for following existing tunnels)
							const nearEntrance = isNearTunnelEntrance(m.position, config.gridSize);
							const nearExit = isNearTunnelExit(m.position, config.gridSize);
							const isInTunnel = m.tunnelState !== undefined;
							const isNearTunnelAccess = nearEntrance || nearExit;
							
							// Only show tunnel traversal options if near a tunnel or in a tunnel
							if (isNearTunnelAccess || isInTunnel) {
								contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
								const tunnelTraverseHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
								tunnelTraverseHeader.innerHTML = 'üî¶ Tunnel Navigation';
								
								const tunnelActionsRow = contextMenu.createDiv({ cls: 'dnd-map-context-aoe-row' });
								
								if (!isInTunnel && isNearTunnelAccess) {
									// Show "Enter Tunnel" button
									const enterBtn = tunnelActionsRow.createEl('button', {
										cls: 'dnd-map-burrow-action-btn',
										text: 'üö™ Enter Tunnel'
									});
									
									enterBtn.addEventListener('click', () => {
										saveToHistory();
										const nearestTunnel = nearEntrance || nearExit;
										if (nearestTunnel) {
											// Check if token is small enough to enter tunnel
											const CREATURE_SIZE_SQUARES: Record<string, number> = {
												'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
											};
											const tokenSize = CREATURE_SIZE_SQUARES[mDef.creatureSize || 'medium'] || 1;
											const tunnelCreatureSize = nearestTunnel.tunnel.creatureSize || 'medium';
											const tunnelSize = CREATURE_SIZE_SQUARES[tunnelCreatureSize] || 1;
											
											// Token must be <= tunnel creator size to enter
											if (tokenSize > tunnelSize) {
												new Notice(`This tunnel is too small! Created by ${tunnelCreatureSize} creature, token is ${mDef.creatureSize || 'medium'}`);
												document.body.removeChild(contextMenu);
												return;
											}
											
											// Set tunnel state
											m.tunnelState = {
												tunnelId: nearestTunnel.tunnel.id,
												pathIndex: nearEntrance ? 0 : nearestTunnel.tunnel.path.length - 1,
												enteredAt: Date.now()
											};
											
											// Snap token to tunnel entrance/exit
											const snapPoint = nearEntrance 
												? nearestTunnel.tunnel.entrancePosition 
												: nearestTunnel.tunnel.path[nearestTunnel.tunnel.path.length - 1];
											m.position.x = snapPoint.x;
											m.position.y = snapPoint.y;
											
											// Set depth to match tunnel depth (inherit from tunnel creator)
											if (!m.elevation) m.elevation = {};
											// Mark that this depth was set by tunnel (so we can clear it on exit)
											m.elevation._tunnelDepth = nearestTunnel.tunnel.depth || 10; // Default 10ft if not specified
											m.elevation.depth = m.elevation._tunnelDepth;
											
											// Move to Subterranean layer (visible but marked as underground)
											m.layer = 'Subterranean';
											
											redrawAnnotations();
											this.saveMapAnnotations(config, el);
											if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
											document.body.removeChild(contextMenu);
											new Notice('Entered tunnel - use arrow keys to navigate');
										}
									});
								}
								
								if (isInTunnel) {
									// Check if token is at entrance or exit of the tunnel
									const tunnel = config.tunnels?.find((t: any) => t.id === m.tunnelState.tunnelId);
									const isAtEntranceOrExit = tunnel && (
										m.tunnelState.pathIndex === 0 || 
										m.tunnelState.pathIndex === tunnel.path.length - 1
									);
									
									if (isAtEntranceOrExit) {
										// Show "Exit Tunnel" button
										const exitBtn = tunnelActionsRow.createEl('button', {
											cls: 'dnd-map-burrow-action-btn active',
											text: 'üö™ Exit Tunnel'
										});
										
										exitBtn.addEventListener('click', () => {
											saveToHistory();
											delete m.tunnelState;
											
											// Clear tunnel-assigned depth (but keep manually set depth)
											if (m.elevation && m.elevation._tunnelDepth) {
												delete m.elevation.depth;
												delete m.elevation._tunnelDepth;
												// If no other elevation properties, remove elevation object
												if (!m.elevation.height && !m.elevation.isBurrowing) {
													delete m.elevation;
												}
											}
											
											m.layer = 'Player';
											
											redrawAnnotations();
											this.saveMapAnnotations(config, el);
											if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
											document.body.removeChild(contextMenu);
											new Notice('Exited tunnel');
										});
									} else {
										// Show disabled message
										const statusText = tunnelActionsRow.createEl('span', {
											cls: 'dnd-map-context-aoe-label',
											text: 'Move to entrance/exit to leave tunnel'
										});
										statusText.style.fontStyle = 'italic';
										statusText.style.color = '#888';
									}
								}
							}
							
							// Token Auras section
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							const auraHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							auraHeader.innerHTML = 'üîµ Token Auras';
							
							// Initialize auras array if needed
							if (!m.auras) m.auras = [];
							
							// Render existing auras
							const aurasContainer = contextMenu.createDiv({ cls: 'dnd-map-auras-container' });
							
							const renderAurasList = () => {
								aurasContainer.empty();
								m.auras.forEach((aura: any, auraIdx: number) => {
									const auraRow = aurasContainer.createDiv({ cls: 'dnd-map-aura-row' });
									
									// Radius input
									const radiusInput = auraRow.createEl('input', {
										cls: 'dnd-map-aura-radius',
										attr: { type: 'number', min: '5', max: '120', step: '5', value: aura.radius || '10', title: 'Radius (ft)' }
									});
									auraRow.createEl('span', { text: 'ft' });
									
									// Color picker
									const colorInput = auraRow.createEl('input', {
										cls: 'dnd-map-aura-color',
										attr: { type: 'color', value: aura.color || '#ffcc00', title: 'Aura color' }
									});
									
									// Delete button
									const deleteBtn = auraRow.createEl('button', { cls: 'dnd-map-aura-delete', attr: { title: 'Remove aura' } });
									deleteBtn.textContent = '‚úï';
									
									// Event handlers
									radiusInput.addEventListener('change', () => {
										saveToHistory();
										aura.radius = parseInt(radiusInput.value) || 10;
										redrawAnnotations();
										this.saveMapAnnotations(config, el);
										if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									});
									
									colorInput.addEventListener('change', () => {
										saveToHistory();
										aura.color = colorInput.value;
										redrawAnnotations();
										this.saveMapAnnotations(config, el);
										if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									});
									
									deleteBtn.addEventListener('click', (e) => {
										e.stopPropagation();
										saveToHistory();
										m.auras.splice(auraIdx, 1);
										renderAurasList();
										redrawAnnotations();
										this.saveMapAnnotations(config, el);
										if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									});
									
									// Prevent menu close on input click
									radiusInput.addEventListener('click', (e) => e.stopPropagation());
									colorInput.addEventListener('click', (e) => e.stopPropagation());
								});
							};
							renderAurasList();
							
							// Add aura button
							const addAuraBtn = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item' });
							addAuraBtn.innerHTML = '<span>‚ûï</span> Add Aura';
							addAuraBtn.addEventListener('click', (e) => {
								e.stopPropagation();
								saveToHistory();
								m.auras.push({ radius: 10, color: '#ffcc00', opacity: 0.25 });
								renderAurasList();
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
							});
							
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
						}
						
						// Delete option
						const deleteOption = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item delete' });
						deleteOption.innerHTML = `<span>üóëÔ∏è</span> Delete`;
						deleteOption.addEventListener('click', () => {
							saveToHistory();
							config.markers.splice(i, 1);
							redrawAnnotations();
							this.saveMapAnnotations(config, el);
							updateGridToolsVisibility();
							refreshVisionSelector();
							document.body.removeChild(contextMenu);
							new Notice('Marker removed');
						});
						
						// Add to body and remove on outside click
						document.body.appendChild(contextMenu);

						// Center on viewport after appending (so we know menu dimensions)
						const menuRect = contextMenu.getBoundingClientRect();
						const viewportWidth = window.innerWidth;
						const viewportHeight = window.innerHeight;
						const centerLeft = Math.max(10, (viewportWidth - menuRect.width) / 2);
						const centerTop = Math.max(10, (viewportHeight - menuRect.height) / 2);
						contextMenu.style.left = `${centerLeft}px`;
						contextMenu.style.top = `${centerTop}px`;

						const removeMenu = (event: MouseEvent) => {
							if (!contextMenu.contains(event.target as Node)) {
								document.body.removeChild(contextMenu);
								document.removeEventListener('click', removeMenu);
							}
						};
						setTimeout(() => document.addEventListener('click', removeMenu), 10);
						
						return;
					}
				}
				
				// Check if right-clicking on a light source
				if (config.lightSources && config.lightSources.length > 0) {
					const lightClickRadius = 15;
					for (let i = config.lightSources.length - 1; i >= 0; i--) {
						const light = config.lightSources[i];
						const dist = Math.sqrt(Math.pow(light.x - mapPos.x, 2) + Math.pow(light.y - mapPos.y, 2));
						if (dist <= lightClickRadius) {
							e.preventDefault();
							
							// Create light context menu
							const contextMenu = document.createElement('div');
							contextMenu.addClass('dnd-map-context-menu');
							contextMenu.style.position = 'fixed';
							contextMenu.style.left = `${e.clientX}px`;
							contextMenu.style.top = `${e.clientY}px`;
							
							// Light name header
							const header = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							header.textContent = light.name || 'Light Source';
							
							// Active/Inactive toggle
							const isActive = light.active !== false;
							const toggleOption = contextMenu.createDiv({ 
								cls: 'dnd-map-context-menu-item'
							});
							toggleOption.innerHTML = isActive 
								? `<span>üîÜ</span> Active (click to extinguish)`
								: `<span>üí°</span> Inactive (click to ignite)`;
							toggleOption.addEventListener('click', () => {
								light.active = !isActive;
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								document.body.removeChild(contextMenu);
								new Notice(light.active ? `${light.name || 'Light'} lit` : `${light.name || 'Light'} extinguished`);
							});
							
							// Separator
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							
							// Change light type header
							const typeHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							typeHeader.textContent = 'Change Type:';
							
							// Light type options
							const lightTypes: { type: LightSourceType; icon: string; name: string }[] = [
								{ type: 'candle', icon: 'üïØÔ∏è', name: 'Candle (5ft)' },
								{ type: 'torch', icon: 'üî•', name: 'Torch (20ft)' },
								{ type: 'lantern', icon: 'üèÆ', name: 'Lantern (30ft)' },
								{ type: 'bullseye', icon: 'üî¶', name: 'Bullseye (60ft)' },
								{ type: 'light', icon: '‚ú®', name: 'Light Spell (20ft)' },
								{ type: 'dancing', icon: 'üí´', name: 'Dancing Lights (10ft dim)' },
								{ type: 'daylight', icon: '‚òÄÔ∏è', name: 'Daylight (60ft)' },
							];
							
							lightTypes.forEach(({ type, icon, name }) => {
								const option = contextMenu.createDiv({ 
									cls: 'dnd-map-context-menu-item' + (light.type === type ? ' active' : '')
								});
								option.innerHTML = `<span>${icon}</span> ${name}`;
								option.addEventListener('click', () => {
									const lightDef = LIGHT_SOURCES[type];
									light.type = type;
									light.bright = lightDef.bright;
									light.dim = lightDef.dim;
									light.name = lightDef.name;
									light.cone = 'cone' in lightDef ? lightDef.cone : false;
									redrawAnnotations();
									this.saveMapAnnotations(config, el);
									if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									document.body.removeChild(contextMenu);
									new Notice(`Changed to ${lightDef.name}`);
								});
							});
							
							// Direction control for cone lights (bullseye lantern)
							if (light.cone) {
								contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
								
								const dirHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
								dirHeader.textContent = 'Aim Direction:';
								
								// Direction preset buttons (compass directions)
								const dirPresets = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item' });
								dirPresets.style.display = 'flex';
								dirPresets.style.justifyContent = 'space-around';
								dirPresets.style.padding = '8px 4px';
								
								const directions = [
									{ label: '‚Üë', angle: -90, title: 'North' },
									{ label: '‚Üí', angle: 0, title: 'East' },
									{ label: '‚Üì', angle: 90, title: 'South' },
									{ label: '‚Üê', angle: 180, title: 'West' },
								];
								
								directions.forEach(({ label, angle, title }) => {
									const btn = dirPresets.createEl('button', { text: label });
									btn.title = title;
									btn.style.width = '32px';
									btn.style.height = '32px';
									btn.style.fontSize = '16px';
									btn.style.cursor = 'pointer';
									btn.style.border = (light.direction || 0) === angle ? '2px solid var(--interactive-accent)' : '1px solid var(--background-modifier-border)';
									btn.style.borderRadius = '4px';
									btn.style.background = 'var(--background-secondary)';
									btn.addEventListener('click', (e) => {
										e.stopPropagation();
										light.direction = angle;
										redrawAnnotations();
										this.saveMapAnnotations(config, el);
										if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
										// Update button styles
										dirPresets.querySelectorAll('button').forEach((b: HTMLButtonElement) => {
											b.style.border = '1px solid var(--background-modifier-border)';
										});
										btn.style.border = '2px solid var(--interactive-accent)';
									});
								});
								
								// Fine rotation slider
								const sliderContainer = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item' });
								sliderContainer.style.display = 'flex';
								sliderContainer.style.alignItems = 'center';
								sliderContainer.style.gap = '8px';
								sliderContainer.style.padding = '8px';
								
								const sliderLabel = sliderContainer.createEl('span', { text: 'üîÑ' });
								sliderLabel.style.fontSize = '14px';
								
								const slider = sliderContainer.createEl('input');
								slider.type = 'range';
								slider.min = '-180';
								slider.max = '180';
								slider.value = String(light.direction || 0);
								slider.style.flex = '1';
								slider.style.cursor = 'pointer';
								
								const angleDisplay = sliderContainer.createEl('span', { text: `${light.direction || 0}¬∞` });
								angleDisplay.style.minWidth = '40px';
								angleDisplay.style.textAlign = 'right';
								angleDisplay.style.fontSize = '12px';
								
								slider.addEventListener('input', (e) => {
									const angle = parseInt((e.target as HTMLInputElement).value);
									light.direction = angle;
									angleDisplay.textContent = `${angle}¬∞`;
									redrawAnnotations();
								});
								
								slider.addEventListener('change', () => {
									this.saveMapAnnotations(config, el);
									if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								});
							}
							
							// Separator
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							
							// Delete option
							const deleteOption = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item delete' });
							deleteOption.innerHTML = `<span>üóëÔ∏è</span> Delete`;
							deleteOption.addEventListener('click', () => {
								saveToHistory();
								config.lightSources.splice(i, 1);
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								document.body.removeChild(contextMenu);
								new Notice('Light removed');
							});
							
							// Add to body and remove on outside click
							document.body.appendChild(contextMenu);

							// Center on viewport after appending (so we know menu dimensions)
							const menuRect = contextMenu.getBoundingClientRect();
							const viewportWidth = window.innerWidth;
							const viewportHeight = window.innerHeight;
							const centerLeft = Math.max(10, (viewportWidth - menuRect.width) / 2);
							const centerTop = Math.max(10, (viewportHeight - menuRect.height) / 2);
							contextMenu.style.left = `${centerLeft}px`;
							contextMenu.style.top = `${centerTop}px`;

							const removeMenu = (event: MouseEvent) => {
								if (!contextMenu.contains(event.target as Node)) {
									document.body.removeChild(contextMenu);
									document.removeEventListener('click', removeMenu);
								}
							};
							setTimeout(() => document.addEventListener('click', removeMenu), 10);
							
							return;
						}
					}
				}
				
				// Check if right-clicking on a wall segment
				if (config.walls && config.walls.length > 0) {
					const wallClickRadius = 10;
					for (let i = config.walls.length - 1; i >= 0; i--) {
						const wall = config.walls[i];
						// Check distance from point to line segment
						const dx = wall.end.x - wall.start.x;
						const dy = wall.end.y - wall.start.y;
						const lengthSq = dx * dx + dy * dy;
						
						let t = 0;
						if (lengthSq > 0) {
							t = Math.max(0, Math.min(1, ((mapPos.x - wall.start.x) * dx + (mapPos.y - wall.start.y) * dy) / lengthSq));
						}
						
						const nearestX = wall.start.x + t * dx;
						const nearestY = wall.start.y + t * dy;
						const dist = Math.sqrt(Math.pow(mapPos.x - nearestX, 2) + Math.pow(mapPos.y - nearestY, 2));
						
						if (dist <= wallClickRadius) {
							e.preventDefault();
							
							const wallType = wall.type || 'wall';
							const wallDef = WALL_TYPES[wallType as WallType] || WALL_TYPES.wall;
							
							// Create wall context menu
							const contextMenu = document.createElement('div');
							contextMenu.addClass('dnd-map-context-menu');
							contextMenu.style.position = 'fixed';
							contextMenu.style.left = `${e.clientX}px`;
							contextMenu.style.top = `${e.clientY}px`;
							
							// Wall name header
							const header = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							header.textContent = wall.name || wallDef.name;
							
							// Door open/close toggle (only for doors)
							if (wallType === 'door') {
								const isOpen = wall.open === true;
								const toggleOption = contextMenu.createDiv({ 
									cls: 'dnd-map-context-menu-item'
								});
								toggleOption.innerHTML = isOpen 
									? `<span>üö™</span> Close Door`
									: `<span>üö™</span> Open Door`;
								toggleOption.addEventListener('click', () => {
									saveToHistory();
									wall.open = !isOpen;
									redrawAnnotations();
									this.saveMapAnnotations(config, el);
									if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									document.body.removeChild(contextMenu);
									new Notice(wall.open ? 'Door opened' : 'Door closed');
								});
								
								contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							}
							
							// Change wall type header
							const typeHeader = contextMenu.createDiv({ cls: 'dnd-map-context-menu-header' });
							typeHeader.textContent = 'Change Type:';
							
							// Wall type options
							(Object.entries(WALL_TYPES) as [WallType, typeof WALL_TYPES[WallType]][]).forEach(([type, def]) => {
								const option = contextMenu.createDiv({ 
									cls: 'dnd-map-context-menu-item' + (wallType === type ? ' active' : '')
								});
								option.innerHTML = `<span>${def.icon}</span> ${def.name}`;
								option.addEventListener('click', () => {
									saveToHistory();
									wall.type = type;
									wall.name = def.name;
									// Reset open state when changing away from door
									if (type !== 'door') {
										wall.open = false;
									}
									redrawAnnotations();
									this.saveMapAnnotations(config, el);
									if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
									document.body.removeChild(contextMenu);
									new Notice(`Changed to ${def.name}`);
								});
							});
							
							// Separator
							contextMenu.createDiv({ cls: 'dnd-map-context-menu-separator' });
							
							// Delete option
							const deleteOption = contextMenu.createDiv({ cls: 'dnd-map-context-menu-item delete' });
							deleteOption.innerHTML = `<span>üóëÔ∏è</span> Delete`;
							deleteOption.addEventListener('click', () => {
								saveToHistory();
								config.walls.splice(i, 1);
								redrawAnnotations();
								this.saveMapAnnotations(config, el);
								if ((viewport as any)._syncPlayerView) (viewport as any)._syncPlayerView();
								document.body.removeChild(contextMenu);
								new Notice('Wall removed');
							});
							
							// Add to body and remove on outside click
							document.body.appendChild(contextMenu);

							// Center on viewport after appending (so we know menu dimensions)
							const menuRect = contextMenu.getBoundingClientRect();
							const viewportWidth = window.innerWidth;
							const viewportHeight = window.innerHeight;
							const centerLeft = Math.max(10, (viewportWidth - menuRect.width) / 2);
							const centerTop = Math.max(10, (viewportHeight - menuRect.height) / 2);
							contextMenu.style.left = `${centerLeft}px`;
							contextMenu.style.top = `${centerTop}px`;

							const removeMenu = (event: MouseEvent) => {
								if (!contextMenu.contains(event.target as Node)) {
									document.body.removeChild(contextMenu);
									document.removeEventListener('click', removeMenu);
								}
							};
							setTimeout(() => document.addEventListener('click', removeMenu), 10);
							
							return;
						}
					}
				}
			});

			// Add controls
			const controls = mapContainer.createDiv({ cls: 'dnd-map-controls' });
			
			// Zoom controls
			const zoomContainer = controls.createDiv({ cls: 'dnd-map-zoom-controls' });
			zoomContainer.createEl('span', { text: 'Zoom: ', cls: 'dnd-map-zoom-label' });
			
			const zoomOut = zoomContainer.createEl('button', { text: '‚àí', cls: 'dnd-map-zoom-btn' });
			const zoomReset = zoomContainer.createEl('button', { text: '100%', cls: 'dnd-map-zoom-btn' });
			const zoomIn = zoomContainer.createEl('button', { text: '+', cls: 'dnd-map-zoom-btn' });
			
			zoomIn.addEventListener('click', () => {
				scale = Math.min(scale * 1.25, 5);
				updateTransform();
				zoomReset.textContent = `${Math.round(scale * 100)}%`;
			});
			
			zoomOut.addEventListener('click', () => {
				scale = Math.max(scale * 0.8, 0.25);
				updateTransform();
				zoomReset.textContent = `${Math.round(scale * 100)}%`;
			});
			
			zoomReset.addEventListener('click', () => {
				scale = 1;
				translateX = 0;
				translateY = 0;
				updateTransform();
				zoomReset.textContent = '100%';
			});

			// Grid toggle
			if (config.gridType && config.gridType !== 'none') {
				const gridToggle = controls.createDiv({ cls: 'dnd-map-grid-toggle' });
				const toggleBtn = gridToggle.createEl('button', { 
					text: 'üî≤ Toggle Grid', 
					cls: 'dnd-map-toggle-btn' 
				});
				
				let gridVisible = true;
				toggleBtn.addEventListener('click', () => {
					gridVisible = !gridVisible;
					if (gridCanvas) {
						gridCanvas.style.display = gridVisible ? 'block' : 'none';
					}
				});
			}

			// Clear drawings button
			const clearBtn = controls.createEl('button', {
				text: 'üóëÔ∏è Clear Drawings',
				cls: 'dnd-map-toggle-btn'
			});
			clearBtn.addEventListener('click', () => {
				new ClearDrawingsConfirmModal(this.app, () => {
					config.drawings = [];
					redrawAnnotations();
					this.saveMapAnnotations(config, el);
					updateGridToolsVisibility();
					new Notice('Drawings cleared');
				}).open();
			});

			// Edit button
			const editButton = controls.createDiv({ cls: 'dnd-map-edit-btn-container' });
			const editBtn = editButton.createEl('button', {
				text: '‚öôÔ∏è Edit Map',
				cls: 'dnd-map-toggle-btn'
			});
			editBtn.addEventListener('click', () => {
				new MapCreationModal(this.app, this, this.mapManager, config, el).open();
			});

		} catch (error) {
			console.error('Error rendering dnd-map:', error);
			el.createEl('div', { 
				text: `‚ö†Ô∏è Error rendering map: ${error instanceof Error ? error.message : String(error)}`,
				cls: 'dnd-map-error'
			});
		}
	}

	/**
	 * Render encounter view from dnd-encounter code block
	 */
	async renderEncounterView(source: string, el: HTMLElement, ctx: any) {
		try {
			// Parse source - either a wikilink to encounter file, or empty to use current file
			const trimmedSource = source.trim();
			let encounterFile: TFile | null = null;
			
			if (trimmedSource) {
				// Source contains a path to encounter file
				// Handle wikilink format: [[path/to/encounter]] or plain path
				let filePath = trimmedSource;
				const wikiMatch = trimmedSource.match(/^\[\[(.+?)\]\]$/);
if (wikiMatch && wikiMatch[1]) {
			filePath = wikiMatch[1];
		}
		
		// Add .md extension if not present
		if (!filePath.endsWith('.md')) {
			filePath += '.md';
				}
				
				// Find the file
				encounterFile = this.app.vault.getAbstractFileByPath(filePath) as TFile;
				if (!encounterFile) {
					// Try to resolve as wikilink
					const resolved = this.app.metadataCache.getFirstLinkpathDest(filePath.replace('.md', ''), ctx.sourcePath);
					if (resolved instanceof TFile) {
						encounterFile = resolved;
					}
				}
			} else {
				// Use current file
				encounterFile = this.app.vault.getAbstractFileByPath(ctx.sourcePath) as TFile;
			}
			
			if (!encounterFile) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è Encounter file not found',
					cls: 'dnd-encounter-block-error'
				});
				return;
			}
			
			// Get frontmatter
			const cache = this.app.metadataCache.getFileCache(encounterFile);
			const fm = cache?.frontmatter;
			
			if (!fm || fm.type !== 'encounter') {
				el.createEl('div', { 
					text: '‚ö†Ô∏è Not a valid encounter note',
					cls: 'dnd-encounter-block-error'
				});
				return;
			}
			
			// Create container
			const container = el.createDiv({ cls: 'dnd-encounter-block' });
			
			// Header with name and link
			const header = container.createDiv({ cls: 'dnd-encounter-block-header' });
			const nameLink = header.createEl('a', { 
				text: `‚öîÔ∏è ${fm.name || encounterFile.basename}`,
				cls: 'dnd-encounter-block-name'
			});
			nameLink.addEventListener('click', (e) => {
				e.preventDefault();
				this.app.workspace.openLinkText(encounterFile!.path, ctx.sourcePath);
			});
			
			// Difficulty badge
			const diff = fm.difficulty;
			if (diff) {
				const badge = header.createEl('span', { 
					text: diff.rating,
					cls: 'dnd-difficulty-badge'
				});
				badge.style.backgroundColor = diff.color || '#888888';
			}
			
			// Stats row
			if (diff) {
				const statsRow = container.createDiv({ cls: 'dnd-encounter-block-stats' });
				
				// Party info
				statsRow.createEl('span', { 
					text: `üë• ${diff.party_count} PCs (Lvl ~${Math.round(diff.party_avg_level || 0)})`,
					cls: 'dnd-encounter-stat'
				});
				
				// Enemy info
				statsRow.createEl('span', { 
					text: `üëπ ${diff.enemy_count} enemies`,
					cls: 'dnd-encounter-stat'
				});
				
				// Rounds estimate
				statsRow.createEl('span', { 
					text: `‚è±Ô∏è ~${diff.rounds_to_defeat} rounds`,
					cls: 'dnd-encounter-stat'
				});
			}
			
			// Creature summary (collapsed by default)
			const creatures = fm.creatures || [];
			if (creatures.length > 0) {
				const creatureSection = container.createDiv({ cls: 'dnd-encounter-block-creatures' });
				const creatureList = creatures.map((c: any) => 
					`${c.count || 1}√ó ${c.name}${c.cr ? ` (CR ${c.cr})` : ''}`
				).join(', ');
				creatureSection.createEl('span', { 
					text: creatureList,
					cls: 'dnd-encounter-creature-list'
				});
			}
			
			// Action buttons
			const buttonRow = container.createDiv({ cls: 'dnd-encounter-block-actions' });
			
			// Load in Initiative Tracker button
			const loadBtn = buttonRow.createEl('button', { 
				text: '‚öîÔ∏è Load in Tracker',
				cls: 'dnd-encounter-btn mod-cta'
			});
			loadBtn.addEventListener('click', async () => {
				const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
				if (!initiativeTracker) {
					new Notice("Initiative Tracker plugin not found");
					return;
				}
				
				const encounterName = fm.name || encounterFile!.basename;
				const encounter = initiativeTracker.data?.encounters?.[encounterName];
				if (!encounter) {
					new Notice(`Encounter "${encounterName}" not found in Initiative Tracker. Try re-saving.`);
					return;
				}
				
				try {
					if (initiativeTracker.tracker?.new) {
						initiativeTracker.tracker.new(initiativeTracker, encounter);
						new Notice(`‚úÖ Loaded: ${encounterName}`);
					}
          (this.app as any).commands?.executeCommandById("initiative-tracker:open-tracker");				
        } catch (e) {
					new Notice(`‚ö†Ô∏è Could not load encounter: ${(e as Error).message}`);
				}
			});
			
			// Edit button
			const editBtn = buttonRow.createEl('button', { 
				text: '‚úèÔ∏è Edit',
				cls: 'dnd-encounter-btn'
			});
			editBtn.addEventListener('click', () => {
				this.editEncounter(encounterFile!.path);
			});
			
			// Open note button
			const openBtn = buttonRow.createEl('button', { 
				text: 'üìÑ Open',
				cls: 'dnd-encounter-btn'
			});
			openBtn.addEventListener('click', () => {
				this.app.workspace.openLinkText(encounterFile!.path, ctx.sourcePath);
			});
			
		} catch (error) {
			console.error('Error rendering encounter block:', error);
			el.createEl('div', { 
				text: `‚ö†Ô∏è Error: ${(error as Error).message}`,
				cls: 'dnd-encounter-block-error'
			});
		}
	}

	/**
	 * Render PoI view from dnd-poi code block
	 */
	async renderPoiView(source: string, el: HTMLElement, ctx: any) {
		try {
			// Parse source to extract PoI names (support multiple)
			const lines = source.trim().split('\n');
			const poiNames: string[] = [];
			
			for (const line of lines) {
				// Support "name: PoI Name" format
				const nameMatch = line.match(/^name:\s*["']?(.+?)["']?$/);
				if (nameMatch && nameMatch[1]) {
					poiNames.push(nameMatch[1].trim());
					continue;
				}
				
				// Support "- PoI Name" list format
				const listMatch = line.match(/^-\s+["']?(.+?)["']?$/);
				if (listMatch && listMatch[1]) {
					poiNames.push(listMatch[1].trim());
				}
			}
			
			if (poiNames.length === 0) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è No PoI names specified. Use:\nname: "PoI Name"\nor\n- PoI Name',
					cls: 'dnd-poi-block-error'
				});
				return;
			}
			
			// Search for all PoI files
			const allFiles = this.app.vault.getMarkdownFiles();
			const poiFiles: TFile[] = [];
			const notFoundNames: string[] = [];
			
			for (const poiName of poiNames) {
				let found = false;
				for (const file of allFiles) {
					if (file.path.includes('/locations/')) {
						const cache = this.app.metadataCache.getFileCache(file);
						const fm = cache?.frontmatter;
						
						if (fm?.type === 'point-of-interest' && fm.name === poiName) {
							poiFiles.push(file);
							found = true;
							break;
						}
					}
				}
				if (!found) {
					notFoundNames.push(poiName);
				}
			}
			
			// Show errors for not found PoIs
			if (notFoundNames.length > 0) {
				const errorDiv = el.createEl('div', { 
					text: `‚ö†Ô∏è PoI not found: ${notFoundNames.join(', ')}`,
					cls: 'dnd-poi-block-error'
				});
				errorDiv.style.marginBottom = '8px';
			}
			
			if (poiFiles.length === 0) {
				return; // All not found, error already shown
			}
			
			// Render each PoI
			for (const poiFile of poiFiles) {
				// Get frontmatter and content
				const cache = this.app.metadataCache.getFileCache(poiFile);
				const fm = cache?.frontmatter;
				
				if (!fm || fm.type !== 'point-of-interest') {
					el.createEl('div', { 
						text: `‚ö†Ô∏è ${poiFile.basename} is not a valid PoI note`,
						cls: 'dnd-poi-block-error'
					});
					continue;
				}
				
				// Create container
				const container = el.createDiv({ cls: 'dnd-poi-block' });
				
				// Header with icon, name, and type
				const header = container.createDiv({ cls: 'dnd-poi-block-header' });
				
				// Icon and name as clickable link
				const nameLink = header.createEl('a', { 
					text: `${fm.icon || 'üìç'} ${fm.name || poiFile.basename}`,
					cls: 'dnd-poi-block-name'
				});
				nameLink.addEventListener('click', (e) => {
					e.preventDefault();
					this.app.workspace.openLinkText(poiFile.path, ctx.sourcePath, true);
				});
				
				// Type badge
				const poiType = fm['poi-type'];
				if (poiType) {
					const typeColors: Record<string, string> = {
						'settlement': '#4a9eff',
						'dungeon': '#8b0000',
						'landmark': '#2e7d32',
						'danger': '#d32f2f',
						'quest': '#f57c00',
						'custom': '#757575'
					};
					const badge = header.createEl('span', { 
						text: poiType,
						cls: 'dnd-poi-type-badge'
					});
					badge.style.backgroundColor = typeColors[poiType] || '#888888';
				}
				
				// Info row with region and status
				const infoRow = container.createDiv({ cls: 'dnd-poi-block-info' });
				
				if (fm.region) {
					infoRow.createEl('span', { 
						text: `üìç ${fm.region}`,
						cls: 'dnd-poi-info-item'
					});
				}
				
				// Status indicator
				const visited = fm.visited || false;
				const discovered = fm.discovered || false;
				let statusText = 'Undiscovered';
				let statusIcon = '‚ùì';
				
				if (visited) {
					statusText = 'Visited';
					statusIcon = '‚úÖ';
				} else if (discovered) {
					statusText = 'Discovered';
					statusIcon = 'üëÅÔ∏è';
				}
				
				infoRow.createEl('span', { 
					text: `${statusIcon} ${statusText}`,
					cls: 'dnd-poi-info-item'
				});
				
				// Quest indicator
				if (fm['quest-related']) {
					infoRow.createEl('span', { 
						text: 'üìú Quest',
						cls: 'dnd-poi-info-item dnd-poi-quest'
					});
				}
				
				// Danger level
				if (fm['danger-level']) {
					infoRow.createEl('span', { 
						text: `‚ò†Ô∏è ${fm['danger-level']}`,
						cls: 'dnd-poi-info-item dnd-poi-danger'
					});
				}
				
				// Description excerpt (first paragraph)
				const content = await this.app.vault.read(poiFile);
				const contentMatch = content.match(/## Description\s*\n\s*([^\n]+)/);
				if (contentMatch && contentMatch[1]) {
					const description = container.createDiv({ cls: 'dnd-poi-block-description' });
					description.createEl('p', { text: contentMatch[1] });
				}
				
				// Action buttons
				const buttonRow = container.createDiv({ cls: 'dnd-poi-block-actions' });
				
				// Open button
				const openBtn = buttonRow.createEl('button', { 
					text: 'üìÑ Open',
					cls: 'dnd-poi-btn mod-cta'
				});
				openBtn.addEventListener('click', () => {
					this.app.workspace.openLinkText(poiFile.path, ctx.sourcePath, true);
				});
				
				// Edit button
				const editBtn = buttonRow.createEl('button', { 
					text: '‚úèÔ∏è Edit',
					cls: 'dnd-poi-btn'
				});
				editBtn.addEventListener('click', () => {
					import('./poi/PoiModals').then(({ PoiEditModal }) => {
						new PoiEditModal(this.app, poiFile.path).open();
					});
				});
			}
			
		} catch (error) {
			console.error('Error rendering PoI block:', error);
			el.createEl('div', { 
				text: `‚ö†Ô∏è Error: ${(error as Error).message}`,
				cls: 'dnd-poi-block-error'
			});
		}
	}

	/**
	 * Render party view from dnd-party code block
	 */
	async renderPartyView(source: string, el: HTMLElement, ctx: any) {
		try {
			// Get party members from Initiative Tracker plugin
			const initiativeTracker = (this.app as any).plugins?.plugins?.["initiative-tracker"];
			if (!initiativeTracker) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è Initiative Tracker plugin not found',
					cls: 'dnd-party-block-error'
				});
				return;
			}

			const allParties = initiativeTracker.data?.parties || [];
			if (allParties.length === 0) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è No parties found in Initiative Tracker',
					cls: 'dnd-party-block-error'
				});
				return;
			}

			// Parse source for party selection (optional)
			const trimmedSource = source.trim();
			let requestedPartyId: string | null = null;
			if (trimmedSource) {
				try {
					const config = JSON.parse(trimmedSource);
					requestedPartyId = config.partyId || config.party;
				} catch {
				// If not JSON, check for YAML-style "party: PartyName" format
				if (trimmedSource.startsWith('party:')) {
					requestedPartyId = trimmedSource.substring(6).trim();
				} else if (trimmedSource.startsWith('partyId:')) {
					requestedPartyId = trimmedSource.substring(8).trim();
				} else {
					// Plain party name
					requestedPartyId = trimmedSource;
				}
			}
		}

		// Resolve party using campaign context
		let party = null;
		
		if (requestedPartyId) {
			// Find party by ID or name
			party = allParties.find((p: any) => 
				p.id === requestedPartyId || p.name === requestedPartyId
			);
			
			if (!party) {
				// Party not found - show helpful error with available parties
				const errorDiv = el.createDiv({ cls: 'dnd-party-block-error' });
				errorDiv.createEl('div', { text: `‚ö†Ô∏è Party "${requestedPartyId}" not found` });
				errorDiv.createEl('div', { 
					text: 'Available parties:', 
					cls: 'dnd-party-error-hint' 
				});
				const partyList = errorDiv.createEl('ul', { cls: 'dnd-party-list' });
				allParties.forEach((p: any) => {
					partyList.createEl('li', { text: `‚Ä¢ ${p.name}` });
				});
				return;
			}
		} else {
			// No party specified - resolve from campaign context
			// Detect campaign from the note's folder path
			let campaignName = "";
			if (ctx.sourcePath) {
				// Parse path to find campaign folder under ttrpgs/
				// Example: "ttrpgs/Frozen Sick (SOLINA)/Sessions/note.md" -> "Frozen Sick (SOLINA)"
				const pathParts = ctx.sourcePath.split('/');
				const ttrpgsIndex = pathParts.indexOf('ttrpgs');
				if (ttrpgsIndex >= 0 && ttrpgsIndex < pathParts.length - 1) {
					campaignName = pathParts[ttrpgsIndex + 1];
					console.log(`[Party View] Detected campaign from path: "${campaignName}"`);
				}
			}

			// Try to find party matching campaign
			if (campaignName) {
				const partyName = `${campaignName} Party`;
				party = allParties.find((p: any) => p.name === partyName);
				
				if (!party) {
					console.log(`[Party View] Expected party "${partyName}" not found. Available:`, allParties.map((p: any) => p.name));
				} else {
					console.log(`[Party View] Found party: "${party.name}"`);
				}
			}

			// Fallback to default party or first available
			if (!party) {
				if (initiativeTracker.data?.defaultParty) {
					party = allParties.find((p: any) => p.id === initiativeTracker.data.defaultParty);
				}
				if (!party) {
					party = allParties[0];
				}
			}
		}

		if (!party) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è No party found',
					cls: 'dnd-party-block-error'
				});
				return;
			}

			// Get party members
			const members = [];
			if (party.players) {
				for (const playerName of party.players) {
					const player = initiativeTracker.data?.players?.find((p: any) => p.name === playerName);
					if (player) {
						members.push({
							name: player.display || player.name || "Unknown",
							level: player.level || 1,
							hp: player.currentHP ?? player.hp ?? player.currentMaxHP ?? 20,
							maxHp: player.currentMaxHP ?? player.hp ?? 20,
							ac: player.currentAC ?? player.ac ?? 14
						});
					}
				}
			}

			if (members.length === 0) {
				el.createEl('div', { 
					text: '‚ö†Ô∏è No party members found',
					cls: 'dnd-party-block-error'
				});
				return;
			}

// Create ultra-compact container
		const container = el.createDiv({ cls: 'dnd-party-block' });

		// Minimal header
		const header = container.createDiv({ cls: 'dnd-party-header' });
		header.createEl('span', { 
			text: `${party.name || "Party"} (${members.length})`,
			cls: 'dnd-party-title'
		});
		const refreshBtn = header.createEl('button', { 
			text: '‚ü≥',
			cls: 'dnd-party-refresh',
			attr: { 'aria-label': 'Refresh' }
		});
		refreshBtn.addEventListener('click', async () => {
			el.empty();
			await this.renderPartyView(source, el, ctx);
		});

		// Member rows with HP bars
		const membersList = container.createDiv({ cls: 'dnd-party-list' });

		for (const member of members) {
			const row = membersList.createDiv({ cls: 'dnd-party-member' });
			const hpPercentage = (member.hp / member.maxHp) * 100;
			
			// Name and Level
			const nameSection = row.createDiv({ cls: 'pc-name-section' });
			nameSection.createEl('span', { text: member.name, cls: 'pc-name' });
			const levelBadge = nameSection.createEl('span', { cls: 'pc-level-badge' });
			levelBadge.createEl('span', { text: '‚öî', cls: 'pc-level-icon' });
			levelBadge.createEl('span', { text: member.level.toString(), cls: 'pc-level-value' });
			
			// HP Bar with value
			const hpSection = row.createDiv({ cls: 'pc-hp-section' });
			const hpLabel = hpSection.createDiv({ cls: 'pc-hp-label' });
			hpLabel.createEl('span', { text: '‚ù§', cls: 'pc-hp-icon' });
			hpLabel.createEl('span', { text: `${member.hp}/${member.maxHp}`, cls: 'pc-hp-text' });
			
			const hpBarContainer = hpSection.createDiv({ cls: 'pc-hp-bar-container' });
			const hpBar = hpBarContainer.createDiv({ cls: 'pc-hp-bar' });
			hpBar.style.width = `${Math.max(0, Math.min(100, hpPercentage))}%`;
			
			// HP bar color
			if (hpPercentage > 66) {
				hpBar.classList.add('hp-healthy');
			} else if (hpPercentage > 33) {
				hpBar.classList.add('hp-wounded');
			} else {
				hpBar.classList.add('hp-critical');
			}
			
			// AC Badge
			const acBadge = row.createDiv({ cls: 'pc-ac-badge' });
			acBadge.createEl('span', { text: 'üõ°', cls: 'pc-ac-icon' });
			acBadge.createEl('span', { text: member.ac.toString(), cls: 'pc-ac-value' });
		}

	} catch (error) {
		console.error('Error rendering party block:', error);
		el.createEl('div', { 
			text: `‚ö†Ô∏è Error: ${(error as Error).message}`,
			cls: 'dnd-party-block-error'
		});
	}
}

/**
 * Save map annotations to dedicated file
 */
async saveMapAnnotations(config: any, el: HTMLElement) {
		try {
			console.warn('=== saveMapAnnotations CALLED ===', {
				mapId: config.mapId,
				hasHighlights: (config.highlights || []).length,
				hasMarkers: (config.markers || []).length,
				hasDrawings: (config.drawings || []).length,
				configDir: this.app.vault.configDir,
				manifestId: this.manifest.id
			});
			
			if (!config.mapId) {
				console.error('Cannot save annotations: mapId missing');
				return;
			}
			
			// Prepare annotation data (includes full config + annotations)
			const mapData = {
				// Map settings
				mapId: config.mapId,
				name: config.name || '',
				imageFile: config.imageFile,
				isVideo: config.isVideo || false,
				type: config.type || 'battlemap',
				dimensions: config.dimensions || {},
				gridType: config.gridType || 'none',
				gridSize: config.gridSize || 70,
				gridOffsetX: config.gridOffsetX || 0,
				gridOffsetY: config.gridOffsetY || 0,
				scale: config.scale || { value: 5, unit: 'feet' },
				// Layer settings
				activeLayer: config.activeLayer || 'Player',
				// Annotations
				highlights: config.highlights || [],
				markers: config.markers || [],
				drawings: config.drawings || [],
				aoeEffects: config.aoeEffects || [],
				tunnels: config.tunnels || [],
				poiReferences: config.poiReferences || [],
				hexTerrains: config.hexTerrains || [],
				hexClimates: config.hexClimates || [],
				customTerrainDescriptions: config.customTerrainDescriptions || {},
				hexcrawlState: config.hexcrawlState || null,
				fogOfWar: config.fogOfWar || { enabled: false, regions: [] },
				walls: config.walls || [],
				lightSources: config.lightSources || [],
				lastModified: new Date().toISOString()
			};
			
			// Ensure annotation directory exists
			const annotationDir = `${this.app.vault.configDir}/plugins/${this.manifest.id}/map-annotations`;
			const dirExists = await this.app.vault.adapter.exists(annotationDir);
			if (!dirExists) {
				await this.app.vault.adapter.mkdir(annotationDir);
			}
			
			console.log('Saving map data to:', annotationDir);
			console.log('MapId:', config.mapId);
			console.log('Highlights count:', mapData.highlights.length);
			console.log('Markers count:', mapData.markers.length);
			console.log('Drawings count:', mapData.drawings.length);
			console.log('Walls count:', mapData.walls.length);
			console.log('Light sources count:', mapData.lightSources.length);
			
			// Save to dedicated file using adapter for config directory files
			const annotationPath = this.getMapAnnotationPath(config.mapId);
			const annotationJson = JSON.stringify(mapData, null, 2);
			
			await this.app.vault.adapter.write(annotationPath, annotationJson);
			
			console.log('Map data saved to:', annotationPath);
			
			// Sync to player view if open
			const viewport = el.querySelector('.dnd-map-viewport') as any;
			if (viewport && viewport._syncPlayerView) {
				viewport._syncPlayerView();
			}
		} catch (error) {
			console.error('Error saving map annotations:', error);
		}
	}

	/**
	 * Get the file path for map annotations
	 */
	getMapAnnotationPath(mapId: string): string {
		return `${this.app.vault.configDir}/plugins/${this.manifest.id}/map-annotations/${mapId}.json`;
	}

	/**
	 * Load map annotations from dedicated file
	 */
	async loadMapAnnotations(mapId: string): Promise<any> {
		try {
			const annotationPath = this.getMapAnnotationPath(mapId);
			console.log('Loading annotations from:', annotationPath);
			
			// Check if annotation file exists
			if (await this.app.vault.adapter.exists(annotationPath)) {
				const data = await this.app.vault.adapter.read(annotationPath);
				const parsedData = JSON.parse(data);
				console.log('Loaded map data:', {
					mapId: parsedData.mapId,
					name: parsedData.name,
					highlightsCount: (parsedData.highlights || []).length,
					markersCount: (parsedData.markers || []).length,
					drawingsCount: (parsedData.drawings || []).length
				});
				return parsedData;
			} else {
				console.log('No saved annotations found for mapId:', mapId);
				return {};
			}
		} catch (error) {
			console.error('Error loading map annotations:', error);
			return {};
 		}
	}

	/**
	 * Draw grid overlay on the map
	 * Based on https://www.redblobgames.com/grids/hexagons/
	 * 
	 * gridSize represents the spacing between hex centers (horizontal for flat-top, vertical for pointy-top)
	 */
	drawGridOverlay(container: HTMLElement, img: MapMediaElement, config: any, offsetX: number = 0, offsetY: number = 0): HTMLCanvasElement {
		// Remove existing canvas if any
		const existingCanvas = container.querySelector('.dnd-map-grid-overlay');
		if (existingCanvas) {
			existingCanvas.remove();
		}

		// Create canvas for grid - same size as the image
		const canvas = document.createElement('canvas');
		canvas.classList.add('dnd-map-grid-overlay');
		canvas.width = img.naturalWidth;
		canvas.height = img.naturalHeight;
		canvas.style.position = 'absolute';
		canvas.style.top = '0';
		canvas.style.left = '0';
		canvas.style.width = `${img.width}px`;
		canvas.style.height = `${img.height}px`;
		canvas.style.pointerEvents = 'none';

		const ctx = canvas.getContext('2d');
		if (!ctx) return canvas;

		// Style for grid lines
		ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
		ctx.lineWidth = 2;

		if (config.gridType === 'square') {
			const size = config.gridSize;
			// Normalize offset to stay within one grid cell
			const normalizedOffsetX = ((offsetX % size) + size) % size;
			const normalizedOffsetY = ((offsetY % size) + size) % size;
			
			// Draw vertical lines
			for (let x = normalizedOffsetX; x <= canvas.width; x += size) {
				ctx.beginPath();
				ctx.moveTo(x, 0);
				ctx.lineTo(x, canvas.height);
				ctx.stroke();
			}

			// Draw horizontal lines
			for (let y = normalizedOffsetY; y <= canvas.height; y += size) {
				ctx.beginPath();
				ctx.moveTo(0, y);
				ctx.lineTo(canvas.width, y);
				ctx.stroke();
			}
		} else if (config.gridType === 'hex-horizontal') {
			// Flat-top hex grid (horizontal orientation)
			// gridSize = horizontal spacing between hex centers (horiz = 3/2 * size)
			const horiz = config.gridSize; // center-to-center X spacing
			const size = (2/3) * horiz; // radius (center -> corner)
			const vert = Math.sqrt(3) * size; // center-to-center Y spacing
			
			// Calculate range accounting for offset - need to cover entire canvas
			const startCol = Math.floor(-offsetX / horiz) - 2;
			const endCol = Math.ceil((canvas.width - offsetX) / horiz) + 2;
			const startRow = Math.floor(-offsetY / vert) - 2;
			const endRow = Math.ceil((canvas.height - offsetY) / vert) + 2;
			
			for (let row = startRow; row < endRow; row++) {
				for (let col = startCol; col < endCol; col++) {
					// ‚úÖ flat-top uses odd-q: offset odd columns in Y by half vertical spacing
					const colOffsetY = (col & 1) ? vert / 2 : 0;
					const centerX = col * horiz + offsetX;
					const centerY = row * vert + colOffsetY + offsetY;
					
					this.drawHexFlat(ctx, centerX, centerY, size);
				}
			}
		} else if (config.gridType === 'hex-vertical') {
			// Pointy-top hex grid (vertical orientation)
			// gridSize = vertical spacing between hex centers (vert = 3/2 * size)
			const vert = config.gridSize; // center-to-center Y spacing
			const size = (2/3) * vert; // radius (center -> corner)
			const horiz = Math.sqrt(3) * size; // center-to-center X spacing
			
			// Calculate range accounting for offset - need to cover entire canvas
			const startCol = Math.floor(-offsetX / horiz) - 2;
			const endCol = Math.ceil((canvas.width - offsetX) / horiz) + 2;
			const startRow = Math.floor(-offsetY / vert) - 2;
			const endRow = Math.ceil((canvas.height - offsetY) / vert) + 2;
			
			for (let row = startRow; row < endRow; row++) {
				for (let col = startCol; col < endCol; col++) {
					// ‚úÖ pointy-top uses odd-r: offset odd rows in X by half horizontal spacing
					const rowOffsetX = (row & 1) ? horiz / 2 : 0;
					const centerX = col * horiz + rowOffsetX + offsetX;
					const centerY = row * vert + offsetY;
					
					this.drawHexPointy(ctx, centerX, centerY, size);
				}
			}
		}

		// Append canvas to container
		container.appendChild(canvas);
		return canvas;
	}

	/**
	 * Draw a flat-top hexagon (horizontal orientation)
	 */
	drawHexFlat(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, radius: number) {
		ctx.beginPath();
		for (let i = 0; i < 6; i++) {
			const angle = (Math.PI / 3) * i; // 60 degree increments
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		ctx.closePath();
		ctx.stroke();
	}

	/**
	 * Draw a pointy-top hexagon (vertical orientation)
	 */
	drawHexPointy(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, radius: number) {
		ctx.beginPath();
		for (let i = 0; i < 6; i++) {
			const angle = (Math.PI / 6) + (Math.PI / 3) * i; // Start at 30 degrees, 60 degree increments
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		ctx.closePath();
		ctx.stroke();
	}

	/**
	 * Draw a filled flat-top hexagon (horizontal orientation)
	 */
	drawFilledHexFlat(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, radius: number) {
		ctx.beginPath();
		for (let i = 0; i < 6; i++) {
			const angle = (Math.PI / 3) * i;
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
	}

	/**
	 * Draw a filled pointy-top hexagon (vertical orientation)
	 */
	drawFilledHexPointy(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, radius: number) {
		ctx.beginPath();
		for (let i = 0; i < 6; i++) {
			const angle = (Math.PI / 6) + (Math.PI / 3) * i;
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
	}

	async createFaction() {
		// Open Faction creation modal
		new FactionCreationModal(this.app, this).open();
	}

	async importAllSRDData() {
		const categories = [
			{ key: "ability-scores", folder: "z_AbilityScores", name: "Ability Scores" },
			{ key: "classes", folder: "z_Classes", name: "Classes" },
			{ key: "conditions", folder: "z_Conditions", name: "Conditions" },
			{ key: "damage-types", folder: "z_DamageTypes", name: "Damage Types" },
			{ key: "equipment", folder: "z_Equipment", name: "Equipment" },
			{ key: "features", folder: "z_Features", name: "Features" },
			{ key: "languages", folder: "z_Languages", name: "Languages" },
			{ key: "magic-schools", folder: "z_MagicSchools", name: "Magic Schools" },
			{ key: "proficiencies", folder: "z_Proficiencies", name: "Proficiencies" },
			{ key: "races", folder: "z_Races", name: "Races" },
			{ key: "skills", folder: "z_Skills", name: "Skills" },
			{ key: "subclasses", folder: "z_Subclasses", name: "Subclasses" },
			{ key: "subraces", folder: "z_Subraces", name: "Subraces" },
			{ key: "traits", folder: "z_Traits", name: "Traits" },
			{ key: "weapon-properties", folder: "z_WeaponProperties", name: "Weapon Properties" }
		];

		let totalSuccess = 0;
		let totalErrors = 0;
		const startTime = Date.now();

		new Notice("Starting full SRD data import...");

		for (const category of categories) {
			const result = await this.importSRDCategory(category.key, category.folder, category.name, true);
			totalSuccess += result.success;
			totalErrors += result.errors;
		}

		const duration = Math.round((Date.now() - startTime) / 1000);
		new Notice(`‚úÖ SRD import complete! ${totalSuccess} items imported, ${totalErrors} errors. (${duration}s)`);
	}

	/**
	 * Import all SRD creatures as battlemap tokens with images.
	 * Fetches every monster from the D&D 5e SRD API, downloads its artwork,
	 * creates a creature note in z_Beastiarity, and registers a MarkerDefinition
	 * (creature-type token) in the marker library with the image attached.
	 * Already-existing creatures are overwritten.
	 */
	async importSRDCreatureTokens(): Promise<{ imported: number; errors: number }> {
		const SRD_BASE = "https://www.dnd5eapi.co";
		const API_BASE = `${SRD_BASE}/api/2014`;
		const BESTIARY_FOLDER = "z_Beastiarity";
		const IMAGE_FOLDER = "z_Beastiarity/images";
		const BATCH_SIZE = 8;

		let imported = 0;
		let errors = 0;

		new Notice("üêâ Starting SRD creature token import‚Ä¶");
		const startTime = Date.now();

		try {
			// Ensure folders exist
			await this.ensureFolderExists(BESTIARY_FOLDER);
			await this.ensureFolderExists(IMAGE_FOLDER);

			// 1. Fetch monster list
			const listResponse = await requestUrl({ url: `${API_BASE}/monsters` });
			const monsters: { index: string; name: string; url: string }[] = listResponse.json.results || [];

			if (monsters.length === 0) {
				new Notice("‚ö†Ô∏è No monsters returned from the SRD API.");
				return { imported: 0, errors: 0 };
			}

			new Notice(`üìã Found ${monsters.length} SRD creatures. Importing‚Ä¶`);

			// 2. Process in batches
			for (let i = 0; i < monsters.length; i += BATCH_SIZE) {
				const batch = monsters.slice(i, i + BATCH_SIZE);

				const batchResults = await Promise.allSettled(
					batch.map(async (entry) => {
						try {
							// Fetch full monster data
							const detailRes = await requestUrl({ url: `${SRD_BASE}${entry.url}` });
							const m = detailRes.json;

							// ‚îÄ‚îÄ Download image ‚îÄ‚îÄ
							let imagePath: string | undefined;
							if (m.image) {
								try {
									const imgUrl = `${SRD_BASE}${m.image}`;
									const imgRes = await requestUrl({ url: imgUrl });
									const ext = m.image.split(".").pop() || "png";
									imagePath = `${IMAGE_FOLDER}/${m.index}.${ext}`;

									// Write image (overwrite if exists)
									if (await this.app.vault.adapter.exists(imagePath)) {
										await this.app.vault.adapter.writeBinary(imagePath, imgRes.arrayBuffer);
									} else {
										await this.app.vault.createBinary(imagePath, imgRes.arrayBuffer);
									}
								} catch (imgErr) {
									console.warn(`[SRD Import] Image download failed for ${m.name}:`, imgErr);
									imagePath = undefined;
								}
							}

							// ‚îÄ‚îÄ Map creature size ‚îÄ‚îÄ
							const sizeMap: Record<string, CreatureSize> = {
								Tiny: "tiny", Small: "small", Medium: "medium",
								Large: "large", Huge: "huge", Gargantuan: "gargantuan"
							};
							const creatureSize: CreatureSize = sizeMap[m.size] || "medium";

							// ‚îÄ‚îÄ Parse darkvision ‚îÄ‚îÄ
							let darkvision = 0;
							if (m.senses?.darkvision) {
								const dvMatch = String(m.senses.darkvision).match(/(\d+)/);
								if (dvMatch && dvMatch[1]) darkvision = parseInt(dvMatch[1], 10);
							}

							// ‚îÄ‚îÄ Build / update MarkerDefinition (token) ‚îÄ‚îÄ
							// Check if a token for this creature already exists (by name + type)
							const existingMarkers = this.markerLibrary.getAllMarkers();
							let existingToken = existingMarkers.find(
								(mk) => mk.name === m.name && mk.type === "creature"
							);

							const now = Date.now();
							const tokenId = existingToken?.id || this.markerLibrary.generateId();

							const tokenDef: MarkerDefinition = {
								id: tokenId,
								name: m.name,
								type: "creature",
								icon: "",
								backgroundColor: "#8b0000",
								borderColor: "#ffffff",
								imageFile: imagePath,
								imageFit: "contain",
								creatureSize,
								darkvision: darkvision > 0 ? darkvision : undefined,
								createdAt: existingToken?.createdAt || now,
								updatedAt: now
							};
							await this.markerLibrary.setMarker(tokenDef);

							// ‚îÄ‚îÄ Build creature note ‚îÄ‚îÄ
							const noteContent = this.buildSRDCreatureNote(m, tokenId, imagePath);
							const filePath = `${BESTIARY_FOLDER}/${m.name}.md`;

							if (await this.app.vault.adapter.exists(filePath)) {
								const existingFile = this.app.vault.getAbstractFileByPath(filePath) as TFile;
								if (existingFile) {
									await this.app.vault.modify(existingFile, noteContent);
								}
							} else {
								await this.app.vault.create(filePath, noteContent);
							}

							imported++;
						} catch (err) {
							console.error(`[SRD Import] Failed to import ${entry.name}:`, err);
							errors++;
						}
					})
				);

				// Progress notice every 40 creatures
				if (i > 0 && i % 40 === 0) {
					new Notice(`üêâ Progress: ${i}/${monsters.length} creatures‚Ä¶`);
				}
			}

			const duration = Math.round((Date.now() - startTime) / 1000);
			new Notice(
				`‚úÖ SRD creature import complete! ${imported} tokens imported, ${errors} errors. (${duration}s)`
			);
		} catch (error) {
			console.error("[SRD Import] Fatal error during creature import:", error);
			new Notice("‚ùå SRD creature import failed. Check the console for details.");
		}

		return { imported, errors };
	}

	/**
	 * Build a creature note markdown from SRD API monster data.
	 * Creates the same frontmatter format as the Creature Creation Modal
	 * so the note is fully compatible with the plugin's creature system.
	 */
	private buildSRDCreatureNote(m: any, tokenId: string, imagePath?: string): string {
		// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
		const calcMod = (score: number) => Math.floor((score - 10) / 2);
		const esc = (s: string) => String(s || "").replace(/"/g, '\\"');

		// ‚îÄ‚îÄ Speed string ‚îÄ‚îÄ
		let speedParts: string[] = [];
		if (m.speed) {
			if (m.speed.walk) speedParts.push(m.speed.walk);
			if (m.speed.fly) speedParts.push(`fly ${m.speed.fly}`);
			if (m.speed.swim) speedParts.push(`swim ${m.speed.swim}`);
			if (m.speed.burrow) speedParts.push(`burrow ${m.speed.burrow}`);
			if (m.speed.climb) speedParts.push(`climb ${m.speed.climb}`);
			if (m.speed.hover) speedParts.push("hover");
		}
		const speedStr = speedParts.join(", ") || "30 ft.";

		// ‚îÄ‚îÄ Armor class ‚îÄ‚îÄ
		let acValue = 10;
		if (Array.isArray(m.armor_class) && m.armor_class.length > 0) {
			acValue = m.armor_class[0].value ?? 10;
		} else if (typeof m.armor_class === "number") {
			acValue = m.armor_class;
		}

		// ‚îÄ‚îÄ Ability scores ‚îÄ‚îÄ
		const str = m.strength ?? 10;
		const dex = m.dexterity ?? 10;
		const con = m.constitution ?? 10;
		const int = m.intelligence ?? 10;
		const wis = m.wisdom ?? 10;
		const cha = m.charisma ?? 10;
		const fage = [calcMod(str), calcMod(dex), calcMod(con), calcMod(int), calcMod(wis), calcMod(cha)];

		// ‚îÄ‚îÄ CR formatting ‚îÄ‚îÄ
		const formatCR = (cr: number) => {
			if (cr === 0.125) return "1/8";
			if (cr === 0.25) return "1/4";
			if (cr === 0.5) return "1/2";
			return String(cr);
		};

		// ‚îÄ‚îÄ Proficiencies ‚Üí saves & skills ‚îÄ‚îÄ
		let saves = "";
		let skillsaves = "";
		if (Array.isArray(m.proficiencies)) {
			const savesArr: string[] = [];
			const skillArr: string[] = [];
			for (const p of m.proficiencies) {
				const idx: string = p.proficiency?.index || "";
				const val: number = p.value ?? 0;
				if (idx.startsWith("saving-throw-")) {
					const ability = idx.replace("saving-throw-", "").substring(0, 3);
					savesArr.push(`\n  - ${ability}: ${val}`);
				} else if (idx.startsWith("skill-")) {
					const skill = idx.replace("skill-", "");
					skillArr.push(`\n  - ${skill}: ${val}`);
				}
			}
			if (savesArr.length > 0) saves = savesArr.join("");
			if (skillArr.length > 0) skillsaves = skillArr.join("");
		}

		// ‚îÄ‚îÄ Damage & condition fields ‚îÄ‚îÄ
		const join = (arr: any) => {
			if (!arr || !Array.isArray(arr)) return "";
			return arr.map((x: any) => (typeof x === "string" ? x : x?.name || x?.index || "")).join(", ");
		};
		const dmgVuln = join(m.damage_vulnerabilities);
		const dmgRes = join(m.damage_resistances);
		const dmgImm = join(m.damage_immunities);
		const condImm = join(m.condition_immunities);

		// ‚îÄ‚îÄ Senses & languages ‚îÄ‚îÄ
		let sensesStr = "";
		if (m.senses) {
			const parts: string[] = [];
			if (m.senses.darkvision) parts.push(`darkvision ${m.senses.darkvision}`);
			if (m.senses.blindsight) parts.push(`blindsight ${m.senses.blindsight}`);
			if (m.senses.truesight) parts.push(`truesight ${m.senses.truesight}`);
			if (m.senses.tremorsense) parts.push(`tremorsense ${m.senses.tremorsense}`);
			if (m.senses.passive_perception) parts.push(`passive Perception ${m.senses.passive_perception}`);
			sensesStr = parts.join(", ");
		}
		const languages = m.languages || "";

		// ‚îÄ‚îÄ Traits / actions / legendary / reactions ‚îÄ‚îÄ
		const fmtBlock = (items: any[] | undefined, key: string) => {
			if (!items || items.length === 0) return `\n${key}:`;
			let out = `\n${key}:`;
			for (const item of items) {
				if (item.name && item.desc) {
					out += `\n  - name: ${item.name}`;
					out += `\n    desc: "${esc(item.desc)}"`;
				}
			}
			return out;
		};

		// ‚îÄ‚îÄ Assemble frontmatter ‚îÄ‚îÄ
		let fm = `---
statblock: true
layout: Basic 5e Layout
name: ${m.name}
size: ${m.size || "Medium"}
type: ${m.type || "creature"}`;
		if (m.subtype) fm += `\nsubtype: ${m.subtype}`;
		fm += `\nalignment: ${m.alignment || "unaligned"}`;
		fm += `\nac: ${acValue}`;
		fm += `\nhp: ${m.hit_points ?? 1}`;
		fm += `\nhit_dice: ${m.hit_dice || ""}`;
		fm += `\nspeed: ${speedStr}`;
		fm += `\nstats:\n  - ${str}\n  - ${dex}\n  - ${con}\n  - ${int}\n  - ${wis}\n  - ${cha}`;
		fm += `\nfage_stats:\n  - ${fage[0]}\n  - ${fage[1]}\n  - ${fage[2]}\n  - ${fage[3]}\n  - ${fage[4]}\n  - ${fage[5]}`;
		fm += `\nsaves:${saves}`;
		fm += `\nskillsaves:${skillsaves}`;
		fm += `\ndamage_vulnerabilities: ${dmgVuln}`;
		fm += `\ndamage_resistances: ${dmgRes}`;
		fm += `\ndamage_immunities: ${dmgImm}`;
		fm += `\ncondition_immunities: ${condImm}`;
		fm += `\nsenses: ${sensesStr}`;
		fm += `\nlanguages: ${languages}`;
		fm += `\ncr: ${formatCR(m.challenge_rating ?? 0)}`;
		fm += `\nspells:`;
		fm += fmtBlock(m.special_abilities, "traits");
		fm += fmtBlock(m.actions, "actions");
		fm += fmtBlock(m.legendary_actions, "legendary_actions");
		fm += `\nbonus_actions:`;
		fm += fmtBlock(m.reactions, "reactions");
		fm += `\ntoken_id: ${tokenId}`;
		fm += `\nsource: D&D 5e SRD`;
		fm += `\n---\n\n`;

		// ‚îÄ‚îÄ Body ‚îÄ‚îÄ
		let body = "";
		if (imagePath) {
			body += `![[${imagePath}]]\n\n`;
		}
		body += `${m.name} creature imported from the D&D 5e SRD.\n`;

		body += `\n\`\`\`dataviewjs
// Action buttons for creature management
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Edit Creature button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit Creature",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-creature");
});

// Delete Creature button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete Creature",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-creature");
});
\`\`\`\n\n`;

		body += `\`\`\`statblock\ncreature: ${m.name}\n\`\`\`\n`;

		return fm + body;
	}

	async importSRDCategory(
		categoryKey: string, 
		folderName: string, 
		categoryName: string,
		isBulkImport: boolean = false
	): Promise<{success: number, errors: number}> {
		try {
			if (!isBulkImport) {
				new Notice(`Starting ${categoryName} import...`);
			}

			// Ensure folder exists
			await this.ensureFolderExists(folderName);

			// Fetch list of items
			const listResponse = await requestUrl({
				url: `https://www.dnd5eapi.co/api/2014/${categoryKey}`,
				method: "GET"
			});

			const items = listResponse.json.results || [];
			let successCount = 0;
			let errorCount = 0;

			for (let i = 0; i < items.length; i++) {
				try {
					const item = items[i];
					const filePath = `${folderName}/${item.name}.md`;

					// Check if file already exists
					const exists = await this.app.vault.adapter.exists(filePath);
					if (exists) {
						console.log(`Skipping ${item.name} - already exists`);
						successCount++;
						continue;
					}

					// Fetch detailed data
					const detailResponse = await requestUrl({
						url: `https://www.dnd5eapi.co${item.url}`,
						method: "GET"
					});

					const data = detailResponse.json;

					// Generate markdown content based on category
					const content = this.generateSRDMarkdown(categoryKey, data);

					await this.app.vault.create(filePath, content);
					successCount++;

					// Show progress every 20 items for bulk imports
					if (isBulkImport && i % 20 === 0 && i > 0) {
						console.log(`${categoryName}: ${i}/${items.length}`);
					}
				} catch (error) {
					errorCount++;
					console.error(`Failed to import ${items[i].name}:`, error);
				}
			}

			if (!isBulkImport) {
				new Notice(`‚úÖ ${categoryName} import complete! ${successCount} items imported, ${errorCount} errors.`);
			}

			return { success: successCount, errors: errorCount };
		} catch (error) {
			new Notice(`‚ùå Failed to import ${categoryName}: ${error instanceof Error ? error.message : String(error)}`);
			console.error(`${categoryName} import error:`, error);
			return { success: 0, errors: 0 };
		}
	}

	generateSRDMarkdown(categoryKey: string, data: any): string {
		const name = data.name || "Unknown";
		const index = data.index || "";

		// Common frontmatter
		let frontmatter = `---
type: srd-${categoryKey}
name: ${name}
index: ${index}
source: D&D 5e SRD
---

# ${name}

`;

		// Category-specific content
		switch (categoryKey) {
			case "ability-scores":
				frontmatter += this.generateAbilityScoreContent(data);
				break;
			case "classes":
				frontmatter += this.generateClassContent(data);
				break;
			case "conditions":
				frontmatter += this.generateConditionContent(data);
				break;
			case "damage-types":
				frontmatter += this.generateDamageTypeContent(data);
				break;
			case "equipment":
				frontmatter += this.generateEquipmentContent(data);
				break;
			case "features":
				frontmatter += this.generateFeatureContent(data);
				break;
			case "languages":
				frontmatter += this.generateLanguageContent(data);
				break;
			case "magic-schools":
				frontmatter += this.generateMagicSchoolContent(data);
				break;
			case "proficiencies":
				frontmatter += this.generateProficiencyContent(data);
				break;
			case "races":
				frontmatter += this.generateRaceContent(data);
				break;
			case "skills":
				frontmatter += this.generateSkillContent(data);
				break;
			case "subclasses":
				frontmatter += this.generateSubclassContent(data);
				break;
			case "subraces":
				frontmatter += this.generateSubraceContent(data);
				break;
			case "traits":
				frontmatter += this.generateTraitContent(data);
				break;
			case "weapon-properties":
				frontmatter += this.generateWeaponPropertyContent(data);
				break;
			default:
				frontmatter += this.generateGenericContent(data);
		}

		return frontmatter;
	}

	generateAbilityScoreContent(data: any): string {
		let content = `**Full Name:** ${data.full_name}\n\n`;
		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}
		if (data.skills && data.skills.length > 0) {
			content += `## Skills\n\n`;
			data.skills.forEach((skill: any) => {
				content += `- ${skill.name}\n`;
			});
		}
		return content;
	}

	generateClassContent(data: any): string {
		let content = `**Hit Die:** d${data.hit_die}\n\n`;
		
		if (data.proficiency_choices && data.proficiency_choices.length > 0) {
			content += `## Proficiency Choices\n\n`;
			data.proficiency_choices.forEach((choice: any) => {
				content += `**Choose ${choice.choose} from:**\n`;
				choice.from.options.forEach((opt: any) => {
					content += `- ${opt.item?.name || "Unknown"}\n`;
				});
				content += `\n`;
			});
		}

		if (data.proficiencies && data.proficiencies.length > 0) {
			content += `## Proficiencies\n\n`;
			data.proficiencies.forEach((prof: any) => {
				content += `- ${prof.name}\n`;
			});
			content += `\n`;
		}

		if (data.saving_throws && data.saving_throws.length > 0) {
			content += `## Saving Throws\n\n`;
			data.saving_throws.forEach((save: any) => {
				content += `- ${save.name}\n`;
			});
			content += `\n`;
		}

		if (data.starting_equipment && data.starting_equipment.length > 0) {
			content += `## Starting Equipment\n\n`;
			data.starting_equipment.forEach((eq: any) => {
				content += `- ${eq.quantity}x ${eq.equipment.name}\n`;
			});
			content += `\n`;
		}

		return content;
	}

	generateConditionContent(data: any): string {
		let content = "";
		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}
		return content;
	}

	generateDamageTypeContent(data: any): string {
		let content = "";
		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}
		return content;
	}

	generateEquipmentContent(data: any): string {
		let content = "";

		if (data.equipment_category) {
			content += `**Category:** ${data.equipment_category.name}\n`;
		}

		if (data.cost) {
			content += `**Cost:** ${data.cost.quantity} ${data.cost.unit}\n`;
		}

		if (data.weight) {
			content += `**Weight:** ${data.weight} lbs\n`;
		}

		content += `\n`;

		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}

		if (data.armor_category) {
			content += `## Armor Properties\n\n`;
			content += `- **Armor Category:** ${data.armor_category}\n`;
			if (data.armor_class) {
				content += `- **AC:** ${data.armor_class.base}`;
				if (data.armor_class.dex_bonus !== undefined) {
					content += ` + Dex ${data.armor_class.max_bonus !== null ? `(max ${data.armor_class.max_bonus})` : ""}`;
				}
				content += `\n`;
			}
			if (data.str_minimum) {
				content += `- **Str Minimum:** ${data.str_minimum}\n`;
			}
			if (data.stealth_disadvantage) {
				content += `- **Stealth Disadvantage:** Yes\n`;
			}
		}

		if (data.weapon_category) {
			content += `## Weapon Properties\n\n`;
			content += `- **Category:** ${data.weapon_category}\n`;
			if (data.weapon_range) {
				content += `- **Range:** ${data.weapon_range}\n`;
			}
			if (data.damage) {
				content += `- **Damage:** ${data.damage.damage_dice} ${data.damage.damage_type.name}\n`;
			}
			if (data.two_handed_damage) {
				content += `- **Two-Handed Damage:** ${data.two_handed_damage.damage_dice} ${data.two_handed_damage.damage_type.name}\n`;
			}
			if (data.range) {
				content += `- **Normal Range:** ${data.range.normal} ft\n`;
				if (data.range.long) {
					content += `- **Long Range:** ${data.range.long} ft\n`;
				}
			}
			if (data.properties && data.properties.length > 0) {
				content += `- **Properties:** ${data.properties.map((p: any) => p.name).join(", ")}\n`;
			}
		}

		return content;
	}

	generateFeatureContent(data: any): string {
		let content = "";

		if (data.level) {
			content += `**Level:** ${data.level}\n`;
		}

		if (data.class) {
			content += `**Class:** ${data.class.name}\n`;
		}

		if (data.subclass) {
			content += `**Subclass:** ${data.subclass.name}\n`;
		}

		content += `\n`;

		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}

		return content;
	}

	generateLanguageContent(data: any): string {
		let content = "";

		if (data.type) {
			content += `**Type:** ${data.type}\n\n`;
		}

		if (data.typical_speakers && data.typical_speakers.length > 0) {
			content += `**Typical Speakers:** ${data.typical_speakers.join(", ")}\n\n`;
		}

		if (data.script) {
			content += `**Script:** ${data.script}\n\n`;
		}

		if (data.desc) {
			content += `## Description\n\n${data.desc}\n\n`;
		}

		return content;
	}

	generateMagicSchoolContent(data: any): string {
		let content = "";
		if (data.desc) {
			content += `## Description\n\n${data.desc}\n\n`;
		}
		return content;
	}

	generateProficiencyContent(data: any): string {
		let content = "";

		if (data.type) {
			content += `**Type:** ${data.type}\n\n`;
		}

		if (data.classes && data.classes.length > 0) {
			content += `**Classes:** ${data.classes.map((c: any) => c.name).join(", ")}\n\n`;
		}

		if (data.races && data.races.length > 0) {
			content += `**Races:** ${data.races.map((r: any) => r.name).join(", ")}\n\n`;
		}

		if (data.reference) {
			content += `**Reference:** ${data.reference.name}\n\n`;
		}

		return content;
	}

	generateRaceContent(data: any): string {
		let content = "";

		if (data.speed) {
			content += `**Speed:** ${data.speed} ft\n`;
		}

		if (data.size) {
			content += `**Size:** ${data.size}\n`;
		}

		if (data.size_description) {
			content += `**Size Description:** ${data.size_description}\n`;
		}

		if (data.alignment) {
			content += `**Alignment:** ${data.alignment}\n`;
		}

		if (data.age) {
			content += `**Age:** ${data.age}\n`;
		}

		content += `\n`;

		if (data.ability_bonuses && data.ability_bonuses.length > 0) {
			content += `## Ability Score Increases\n\n`;
			data.ability_bonuses.forEach((bonus: any) => {
				content += `- **${bonus.ability_score.name}:** +${bonus.bonus}\n`;
			});
			content += `\n`;
		}

		if (data.starting_proficiencies && data.starting_proficiencies.length > 0) {
			content += `## Starting Proficiencies\n\n`;
			data.starting_proficiencies.forEach((prof: any) => {
				content += `- ${prof.name}\n`;
			});
			content += `\n`;
		}

		if (data.languages && data.languages.length > 0) {
			content += `## Languages\n\n`;
			data.languages.forEach((lang: any) => {
				content += `- ${lang.name}\n`;
			});
			content += `\n`;
		}

		if (data.traits && data.traits.length > 0) {
			content += `## Racial Traits\n\n`;
			data.traits.forEach((trait: any) => {
				content += `- ${trait.name}\n`;
			});
			content += `\n`;
		}

		if (data.subraces && data.subraces.length > 0) {
			content += `## Subraces\n\n`;
			data.subraces.forEach((subrace: any) => {
				content += `- ${subrace.name}\n`;
			});
			content += `\n`;
		}

		return content;
	}

	generateSkillContent(data: any): string {
		let content = "";

		if (data.ability_score) {
			content += `**Ability Score:** ${data.ability_score.name}\n\n`;
		}

		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}

		return content;
	}

	generateSubclassContent(data: any): string {
		let content = "";

		if (data.class) {
			content += `**Class:** ${data.class.name}\n`;
		}

		if (data.subclass_flavor) {
			content += `**Flavor:** ${data.subclass_flavor}\n`;
		}

		content += `\n`;

		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}

		if (data.spells && data.spells.length > 0) {
			content += `## Spells\n\n`;
			data.spells.forEach((spell: any) => {
				content += `- **Level ${spell.prerequisites[0]?.level || "N/A"}:** ${spell.spell.name}\n`;
			});
			content += `\n`;
		}

		return content;
	}

	generateSubraceContent(data: any): string {
		let content = "";

		if (data.race) {
			content += `**Race:** ${data.race.name}\n`;
		}

		content += `\n`;

		if (data.desc) {
			content += `## Description\n\n${data.desc}\n\n`;
		}

		if (data.ability_bonuses && data.ability_bonuses.length > 0) {
			content += `## Ability Score Increases\n\n`;
			data.ability_bonuses.forEach((bonus: any) => {
				content += `- **${bonus.ability_score.name}:** +${bonus.bonus}\n`;
			});
			content += `\n`;
		}

		if (data.starting_proficiencies && data.starting_proficiencies.length > 0) {
			content += `## Starting Proficiencies\n\n`;
			data.starting_proficiencies.forEach((prof: any) => {
				content += `- ${prof.name}\n`;
			});
			content += `\n`;
		}

		if (data.racial_traits && data.racial_traits.length > 0) {
			content += `## Racial Traits\n\n`;
			data.racial_traits.forEach((trait: any) => {
				content += `- ${trait.name}\n`;
			});
			content += `\n`;
		}

		return content;
	}

	generateTraitContent(data: any): string {
		let content = "";

		if (data.races && data.races.length > 0) {
			content += `**Races:** ${data.races.map((r: any) => r.name).join(", ")}\n\n`;
		}

		if (data.subraces && data.subraces.length > 0) {
			content += `**Subraces:** ${data.subraces.map((s: any) => s.name).join(", ")}\n\n`;
		}

		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}

		return content;
	}

	generateWeaponPropertyContent(data: any): string {
		let content = "";
		if (data.desc && data.desc.length > 0) {
			content += `## Description\n\n${data.desc.join("\n\n")}\n\n`;
		}
		return content;
	}

	generateGenericContent(data: any): string {
		let content = "## Data\n\n```json\n";
		content += JSON.stringify(data, null, 2);
		content += "\n```\n";
		return content;
	}

	async promptForName(type: string): Promise<string | null> {
		return new Promise((resolve) => {
			const modal = new NamePromptModal(this.app, type, resolve);
			modal.open();
		});
	}

	/**
	 * Roll on the encounter table of the currently active note.
	 * Reads frontmatter to verify the note is an encounter-table and picks a random entry.
	 */
	async rollRandomEncounter() {
		const activeFile = this.app.workspace.getActiveFile();
		if (!activeFile) {
			new Notice("Open an encounter table note first.");
			return;
		}

		const cache = this.app.metadataCache.getFileCache(activeFile);
		if (cache?.frontmatter?.type !== "encounter-table") {
			new Notice("‚ö†Ô∏è This is not an encounter table note.");
			return;
		}

		const entries = cache.frontmatter.entries || 6;
		const roll = Math.floor(Math.random() * entries) + 1;

		// Try to find the matching row in the table
		const content = await this.app.vault.read(activeFile);
		const tableRowRegex = new RegExp(`^\\|\\s*${roll}\\s*\\|(.+?)\\|(.+?)\\|(.+?)\\|`, "m");
		const match = content.match(tableRowRegex);

		if (match) {
			const encounter = match[1]?.trim() ?? "Unknown";
			const difficulty = match[2]?.trim() ?? "";
			new Notice(`üé≤ Rolled ${roll} on d${entries}:\n${encounter}\nDifficulty: ${difficulty}`, 8000);
		} else {
			new Notice(`üé≤ Rolled ${roll} on d${entries}!`, 5000);
		}
	}

	async ensureFolderExists(path: string) {
		const folders = path.split("/");
		let currentPath = "";

		for (const folder of folders) {
			currentPath += (currentPath ? "/" : "") + folder;
			try {
				await this.app.vault.createFolder(currentPath);
			} catch (error) {
				// Folder might already exist, continue
			}
		}
	}

	getDefaultCampaignTemplate(): string {
		return CAMPAIGN_TEMPLATE;
	}

	getDefaultNpcTemplate(): string {
		return NPC_TEMPLATE;
	}

	getDefaultPcTemplate(): string {
		return PC_TEMPLATE;
	}

	getDefaultAdventureTemplate(): string {
		return ADVENTURE_TEMPLATE;
	}

	getDefaultSessionTemplate(): string {
		return SESSION_DEFAULT_TEMPLATE;
	}

	getDefaultItemTemplate(): string {
		return ITEM_TEMPLATE;
	}

	getDefaultSpellTemplate(): string {
		return SPELL_TEMPLATE;
	}

	getDefaultFactionTemplate(): string {
		return FACTION_TEMPLATE;
	}

	getFileNameFromPath(): string {
		// This is a placeholder - in actual use, this would be the filename
		return "New Entity";
	}

	getAllCampaigns(): Array<{ path: string; name: string }> {
		const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
		const campaigns: Array<{ path: string; name: string }> = [];

		if (ttrpgsFolder instanceof TFolder) {
			ttrpgsFolder.children.forEach((child) => {
				if (child instanceof TFolder) {
					campaigns.push({
						path: child.path,
						name: child.name
					});
				}
			});
		}

		return campaigns;
	}
}

class DndCampaignHubSettingTab extends PluginSettingTab {
  plugin: DndCampaignHubPlugin;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  async display(): Promise<void> {
    const { containerEl } = this;

    containerEl.empty();

    containerEl.createEl("h2", { text: "D&D Campaign Hub Settings" });

    // Plugin Dependencies Section
    containerEl.createEl("h3", { text: "üì¶ Plugin Dependencies" });
    
    const depsContainer = containerEl.createDiv({ cls: "dnd-dependencies-container" });
    await this.displayDependencyStatus(depsContainer);

    // Campaign Settings
    containerEl.createEl("h3", { text: "‚öôÔ∏è Campaign Settings" });

    new Setting(containerEl)
      .setName("Current Campaign")
      .setDesc("The currently active campaign for quick access")
      .addText((text) =>
        text
          .setPlaceholder("ttrpgs/Campaign Name")
          .setValue(this.plugin.settings.currentCampaign)
          .onChange(async (value) => {
            this.plugin.settings.currentCampaign = value;
            await this.plugin.saveSettings();
          })
      );

    // SRD Data Import Section
    containerEl.createEl("h3", { text: "üì• SRD Data Import" });
    
    const srdContainer = containerEl.createDiv({ cls: "dnd-about-container" });
    srdContainer.createEl("p", { 
      text: "Download and import D&D 5e SRD data from the official API. Data will be saved to system folders in your vault." 
    });

    new Setting(containerEl)
      .setName("Import All SRD Data")
      .setDesc("Downloads all available SRD content (conditions, equipment, races, features, etc.) and saves to system folders (e.g., z_Conditions, z_Equipment). This may take several minutes.")
      .addButton((button) =>
        button
          .setButtonText("Import All SRD Data")
          .setCta()
          .onClick(async () => {
            await this.plugin.importAllSRDData();
          })
      );

    new Setting(containerEl)
      .setName("Import Individual Categories")
      .setDesc("Import specific SRD data categories")
      .setHeading();

    const srdCategories = [
      { key: "ability-scores", folder: "z_AbilityScores", name: "Ability Scores" },
      { key: "classes", folder: "z_Classes", name: "Classes" },
      { key: "conditions", folder: "z_Conditions", name: "Conditions" },
      { key: "damage-types", folder: "z_DamageTypes", name: "Damage Types" },
      { key: "equipment", folder: "z_Equipment", name: "Equipment" },
      { key: "features", folder: "z_Features", name: "Features" },
      { key: "languages", folder: "z_Languages", name: "Languages" },
      { key: "magic-schools", folder: "z_MagicSchools", name: "Magic Schools" },
      { key: "proficiencies", folder: "z_Proficiencies", name: "Proficiencies" },
      { key: "races", folder: "z_Races", name: "Races" },
      { key: "skills", folder: "z_Skills", name: "Skills" },
      { key: "subclasses", folder: "z_Subclasses", name: "Subclasses" },
      { key: "subraces", folder: "z_Subraces", name: "Subraces" },
      { key: "traits", folder: "z_Traits", name: "Traits" },
      { key: "weapon-properties", folder: "z_WeaponProperties", name: "Weapon Properties" }
    ];

    srdCategories.forEach(category => {
      new Setting(containerEl)
        .setName(category.name)
        .addButton((button) =>
          button
            .setButtonText(`Import ${category.name}`)
            .onClick(async () => {
              await this.plugin.importSRDCategory(category.key, category.folder, category.name);
            })
        );
    });

    // SRD Creature Token Import
    containerEl.createEl("h3", { text: "üêâ SRD Creature Token Import" });

    const creatureImportContainer = containerEl.createDiv({ cls: "dnd-about-container" });
    creatureImportContainer.createEl("p", {
      text: "Import all 334 SRD creatures as battlemap tokens with artwork. Each creature gets a note in z_Beastiarity with full stats, a token in the marker library with the correct size and darkvision, and its SRD artwork saved locally. Already-existing creatures will be overwritten."
    });

    const creatureImportStatusEl = containerEl.createDiv();

    new Setting(containerEl)
      .setName("Import All SRD Creature Tokens")
      .setDesc("Downloads all SRD monsters, their images, creates creature notes and battlemap tokens. This may take a few minutes.")
      .addButton((button) =>
        button
          .setButtonText("üêâ Import SRD Creatures")
          .setCta()
          .onClick(async () => {
            button.setDisabled(true);
            button.setButtonText("‚è≥ Importing‚Ä¶");
            creatureImportStatusEl.empty();
            creatureImportStatusEl.createEl("p", { text: "Import in progress‚Ä¶ check Obsidian notices for updates." });

            try {
              const result = await this.plugin.importSRDCreatureTokens();
              creatureImportStatusEl.empty();
              creatureImportStatusEl.createEl("p", {
                text: `‚úÖ Done! ${result.imported} creatures imported, ${result.errors} errors.`
              });
            } catch (err) {
              creatureImportStatusEl.empty();
              creatureImportStatusEl.createEl("p", {
                text: `‚ùå Import failed: ${err instanceof Error ? err.message : String(err)}`
              });
            } finally {
              button.setDisabled(false);
              button.setButtonText("üêâ Import SRD Creatures");
            }
          })
      );

    // About Section
    containerEl.createEl("h3", { text: "‚ÑπÔ∏è About" });
    
    const aboutContainer = containerEl.createDiv({ cls: "dnd-about-container" });
    aboutContainer.createEl("p", { 
      text: `D&D Campaign Hub v${this.plugin.manifest.version}` 
    });
    aboutContainer.createEl("p", { 
      text: "A comprehensive plugin for managing D&D campaigns in Obsidian." 
    });
    
    new Setting(containerEl)
      .setName("Migrate Files")
      .setDesc("Safely migrate campaign files to the latest template versions (preserves all your content)")
      .addButton((button) =>
        button
          .setButtonText("Migrate Files")
          .setCta()
          .onClick(async () => {
            this.plugin.migrateTemplates();
          })
      );

    containerEl.createEl("h3", { text: "Danger Zone" });

    new Setting(containerEl)
      .setName("Purge D&D Campaign Hub")
      .setDesc("‚ö†Ô∏è Remove all D&D Campaign Hub folders and files from this vault. This cannot be undone!")
      .addButton((button) =>
        button
          .setButtonText("Purge Vault")
          .setWarning()
          .onClick(async () => {
            new PurgeConfirmModal(this.app, this.plugin).open();
          })
      );
  }

  async displayDependencyStatus(container: HTMLElement): Promise<void> {
    container.empty();

    const deps = await this.plugin.checkDependencies();
    const allInstalled = deps.missing.length === 0;

    // Status indicator
    const statusContainer = container.createDiv({ cls: "dnd-dependency-status" });
    
    if (allInstalled) {
      statusContainer.createEl("div", { 
        text: "‚úÖ All dependencies installed and ready!",
        cls: "dnd-status-success"
      });
    } else {
      statusContainer.createEl("div", { 
        text: `‚ö†Ô∏è ${deps.missing.length} dependency plugin(s) missing`,
        cls: "dnd-status-warning"
      });
    }

    // Detailed plugin list
    const pluginsContainer = container.createDiv({ cls: "dnd-plugins-list" });
    
    const requiredPlugins = [
      { id: "buttons", name: "Buttons", url: "obsidian://show-plugin?id=buttons" },
      { id: "dataview", name: "Dataview", url: "obsidian://show-plugin?id=dataview" },
      { id: "calendarium", name: "Calendarium", url: "obsidian://show-plugin?id=calendarium" },
      { id: "templater-obsidian", name: "Templater", url: "obsidian://show-plugin?id=templater-obsidian" },
      { id: "initiative-tracker", name: "Initiative Tracker", url: "obsidian://show-plugin?id=initiative-tracker" }
    ];

    for (const plugin of requiredPlugins) {
      const isInstalled = deps.installed.includes(plugin.name);
      
      const pluginRow = pluginsContainer.createDiv({ cls: "dnd-plugin-row" });
      
      const statusIcon = pluginRow.createEl("span", { 
        text: isInstalled ? "‚úÖ" : "‚ùå",
        cls: "dnd-plugin-status-icon"
      });
      
      const pluginName = pluginRow.createEl("span", { 
        text: plugin.name,
        cls: isInstalled ? "dnd-plugin-installed" : "dnd-plugin-missing"
      });
      
      if (!isInstalled) {
        const installButton = pluginRow.createEl("button", {
          text: "Install",
          cls: "mod-cta"
        });
        installButton.addEventListener("click", () => {
          // Open Obsidian's plugin browser directly to this plugin
          window.open(plugin.url, "_blank");
        });
      }
    }

    // Refresh button
    new Setting(container)
      .setName("Refresh Status")
      .setDesc("Check dependency status again")
      .addButton((button) =>
        button
          .setButtonText("Refresh")
          .onClick(async () => {
            await this.displayDependencyStatus(container);
            new Notice("Dependency status refreshed!");
          })
      );
  }
}

/**
 * Confirmation modal for clearing drawings from the map
 */
class ClearDrawingsConfirmModal extends Modal {
  private onConfirm: () => void;

  constructor(app: App, onConfirm: () => void) {
    super(app);
    this.onConfirm = onConfirm;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "Clear Drawings?" });

    contentEl.createEl("p", {
      text: "This will remove all drawings created with the Draw tool. Markers and other annotations will not be affected."
    });

    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const confirmButton = buttonContainer.createEl("button", {
      text: "Clear Drawings",
      cls: "mod-warning"
    });
    confirmButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });

    confirmButton.focus();
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class PurgeConfirmModal extends Modal {
  plugin: DndCampaignHubPlugin;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "‚ö†Ô∏è Purge D&D Campaign Hub" });

    contentEl.createEl("p", {
      text: "This will permanently delete ALL D&D Campaign Hub folders and their contents:",
      cls: "mod-warning"
    });

    const list = contentEl.createEl("ul");
    const folders = [
      "ttrpgs/ - All campaigns and their content",
      "z_Templates/ - All template files",
      "z_Assets/ - All assets",
      "z_Beastiarity/ - All monster data",
      "z_Databases/ - All databases",
      "z_Log/ - All session logs",
      "z_Tables/ - All tables",
      "z_Spells/ - All imported spells from API",
      "And all other z_* folders (SRD data, scripts, etc.)"
    ];

    folders.forEach(folder => {
      list.createEl("li", { text: folder });
    });

    contentEl.createEl("p", {
      text: "‚ö†Ô∏è THIS CANNOT BE UNDONE!",
      cls: "mod-warning"
    });

    contentEl.createEl("p", {
      text: "Type 'PURGE' to confirm:"
    });

    const input = contentEl.createEl("input", {
      type: "text",
      placeholder: "Type PURGE to confirm"
    });

    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const purgeButton = buttonContainer.createEl("button", {
      text: "Purge Vault",
      cls: "mod-warning"
    });

    purgeButton.disabled = true;

    input.addEventListener("input", () => {
      purgeButton.disabled = input.value !== "PURGE";
    });

    purgeButton.addEventListener("click", async () => {
      if (input.value === "PURGE") {
        this.close();
        await this.plugin.purgeVault();
      }
    });

    input.focus();
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class DndHubModal extends Modal {
  plugin: DndCampaignHubPlugin;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
  }


  showInitializationUI(container: HTMLElement) {
    container.createEl("p", { 
      text: "Welcome to D&D Campaign Hub! Your vault needs to be initialized before you can start creating campaigns.",
      cls: "dnd-hub-info"
    });

    container.createEl("p", {
      text: "This will create the following structure:"
    });

    const list = container.createEl("ul");
    const folders = [
      "ttrpgs/ - Main folder for all campaigns",
      "z_Templates/ - Template files for campaigns, sessions, NPCs, etc.",
      "z_Assets/ - Images and other assets",
      "z_Beastiarity/ - Monster and creature stats",
      "z_Databases/ - Campaign databases",
      "z_Log/ - Session logs",
      "z_Tables/ - Random tables and generators",
      "And more supporting folders..."
    ];

    folders.forEach(folder => {
      list.createEl("li", { text: folder });
    });

    container.createEl("p", {
      text: "‚ö†Ô∏è Note: This will also configure settings for Templater and Hide Folders plugins if they are installed."
    });

    const buttonContainer = container.createDiv({ cls: "dnd-hub-init-buttons" });
    
    const initButton = buttonContainer.createEl("button", {
      text: "üé≤ Initialize Vault",
      cls: "mod-cta"
    });

    initButton.addEventListener("click", async () => {
      this.close();
      await this.plugin.initializeVault();
      // Reopen the modal to show the full UI
      new DndHubModal(this.app, this.plugin).open();
    });

    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });

    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h1", { text: "D&D Campaign Hub" });

    // Check if vault is initialized
    if (!this.plugin.isVaultInitialized()) {
      console.log("DND Hub: Vault not initialized, showing init UI");
      this.showInitializationUI(contentEl);
      return;
    }

    // Check if any campaigns exist
    const campaigns = this.plugin.getAllCampaigns();
    const hasCampaigns = campaigns.length > 0;
    console.log("DND Hub: Found", campaigns.length, "campaigns. hasCampaigns:", hasCampaigns);

    // Quick Actions Section
    contentEl.createEl("h2", { text: "Quick Actions" });

    const quickActionsContainer = contentEl.createDiv({ cls: "dnd-hub-quick-actions" });

    console.log("DND Hub: Creating 'New Campaign' button");
    this.createActionButton(quickActionsContainer, "üé≤ New Campaign", () => {
      this.close();
      this.plugin.createCampaign();
    });

    // Only show other buttons if campaigns exist
    if (hasCampaigns) {
      this.createActionButton(quickActionsContainer, "üë§ New NPC", () => {
        this.close();
        this.plugin.createNpc();
      });

      this.createActionButton(quickActionsContainer, "üõ°Ô∏è New PC", () => {
        this.close();
        this.plugin.createPc();
      });

      this.createActionButton(quickActionsContainer, "üèõÔ∏è New Faction", () => {
        this.close();
        this.plugin.createFaction();
      });

      this.createActionButton(quickActionsContainer, "üó∫Ô∏è New Adventure", () => {
        this.close();
        this.plugin.createAdventure();
      });

      this.createActionButton(quickActionsContainer, "‚öîÔ∏è New Encounter", () => {
        this.close();
        this.plugin.createEncounter();
      });

      this.createActionButton(quickActionsContainer, "ü™§ New Trap", () => {
        this.close();
        this.plugin.createTrap();
      });

      this.createActionButton(quickActionsContainer, "‚öîÔ∏è New Item", () => {
        this.close();
        this.plugin.createItem();
      });

      this.createActionButton(quickActionsContainer, "üêâ New Creature", () => {
        this.close();
        this.plugin.createCreature();
      });
    }

    if (hasCampaigns) {
      contentEl.createEl("p", {
        text: "Create sessions from a campaign's World note or via the 'Create New Session' command.",
        cls: "dnd-hub-info",
      });

      // Browse Vault Section
      contentEl.createEl("h2", { text: "Browse Vault" });
      const browseContainer = contentEl.createDiv({ cls: "dnd-hub-browse" });

      this.createBrowseButton(browseContainer, "üìÅ Campaigns", "Campaigns");
      this.createBrowseButton(browseContainer, "üë• NPCs", "NPCs");
      this.createBrowseButton(browseContainer, "üõ°Ô∏è PCs", "PCs");
      this.createBrowseButton(browseContainer, "üó∫Ô∏è Adventures", "Adventures");
      this.createBrowseButton(browseContainer, "üìú Sessions", "Sessions");
      this.createBrowseButton(browseContainer, "‚öîÔ∏è Items", "Items");
      this.createBrowseButton(browseContainer, "‚ú® Spells", "Spells");
      this.createBrowseButton(browseContainer, "üèõÔ∏è Factions", "Factions");
    } else {
      contentEl.createEl("p", {
        text: "Create your first campaign to get started!",
        cls: "dnd-hub-info",
      });
    }
  }

  createActionButton(container: Element, text: string, callback: () => void) {
    const button = container.createEl("button", { text, cls: "dnd-hub-button" });
    button.addEventListener("click", callback);
  }

  createBrowseButton(container: Element, text: string, folderName: string) {
    const button = container.createEl("button", { text, cls: "dnd-hub-button" });
    button.addEventListener("click", () => {
      this.close();
      this.browseFolder(folderName);
    });
  }

  async browseFolder(folderName: string) {
    let folderPath: string;
    if (["NPCs", "PCs", "Adventures", "Factions", "Items"].includes(folderName)) {
      folderPath = `${this.plugin.settings.currentCampaign}/${folderName}`;
    } else if (folderName === "Campaigns") {
      folderPath = "ttrpgs";
    } else if (folderName === "Sessions") {
      folderPath = this.plugin.settings.currentCampaign;
    } else {
      folderPath = folderName;
    }

    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (folder instanceof TFolder) {
        // Open the folder in the file explorer
        const leaf = this.app.workspace.getLeaf();
        await this.app.workspace.revealLeaf(leaf);
      } else {
        new Notice(`Folder "${folderName}" not found. Create some ${folderName.toLowerCase()} first!`);
      }
    } catch (error) {
      new Notice(`Error browsing ${folderName}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class NamePromptModal extends Modal {
  type: string;
  resolve: (value: string | null) => void;

  constructor(app: App, type: string, resolve: (value: string | null) => void) {
    super(app);
    this.type = type;
    this.resolve = resolve;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: `Create New ${this.type}` });

    const input = contentEl.createEl("input", {
      type: "text",
      placeholder: `Enter ${this.type.toLowerCase()} name...`,
    });

    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.resolve(null);
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta",
    });
    createButton.addEventListener("click", () => {
      const name = input.value.trim();
      if (name) {
        this.close();
        this.resolve(name);
      }
    });

    input.focus();
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        createButton.click();
      }
    });
  }

  onClose() {
    this.resolve(null);
  }
}

/**
 * File suggest component for PDF files in the vault
 */
class PDFFileSuggest extends AbstractInputSuggest<TFile> {
  private inputEl: HTMLInputElement;

  constructor(app: App, inputEl: HTMLInputElement) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }

  getSuggestions(query: string): TFile[] {
    // Get all PDF files from vault
    const allFiles = this.app.vault.getFiles();
    const pdfFiles = allFiles.filter(f => f.extension === 'pdf');
    const lowerQuery = query.toLowerCase();
    
    if (!query) {
      return pdfFiles.slice(0, 50); // Show first 50 PDFs when no input
    }
    
    return pdfFiles
      .filter(file => 
        file.path.toLowerCase().includes(lowerQuery) ||
        file.basename.toLowerCase().includes(lowerQuery)
      )
      .slice(0, 50); // Max 50 suggestions
  }

  renderSuggestion(file: TFile, el: HTMLElement): void {
    const div = el.createDiv({ cls: 'suggestion-item' });
    
    // Filename in bold
    const titleDiv = div.createDiv({ cls: 'suggestion-title' });
    titleDiv.setText(file.basename);
    titleDiv.style.fontWeight = '600';
    
    // Path in gray below
    if (file.path !== file.basename + '.pdf') {
      const pathDiv = div.createDiv({ cls: 'suggestion-note' });
      pathDiv.setText(file.path);
      pathDiv.style.fontSize = '0.85em';
      pathDiv.style.color = 'var(--text-muted)';
    }
  }

  selectSuggestion(file: TFile): void {
    // Set the path
    this.inputEl.value = file.path;
    this.inputEl.dispatchEvent(new Event('input'));
    this.close();
  }
}

/**
 * Modal for browsing and selecting PDF files from the vault
 */
class PDFBrowserModal extends Modal {
  private files: TFile[];
  private onSelect: (file: TFile) => void;
  private filterText: string = '';

  constructor(app: App, files: TFile[], onSelect: (file: TFile) => void) {
    super(app);
    this.files = files;
    this.onSelect = onSelect;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl('h2', { text: 'Select PDF File' });

    // Search filter
    const searchContainer = contentEl.createDiv();
    searchContainer.style.marginBottom = '10px';
    const searchInput = searchContainer.createEl('input', { 
      type: 'text', 
      placeholder: 'Filter PDFs...' 
    });
    searchInput.style.width = '100%';
    searchInput.style.padding = '8px';
    searchInput.style.borderRadius = '4px';
    searchInput.style.border = '1px solid var(--background-modifier-border)';

    const listContainer = contentEl.createDiv({ cls: 'pdf-browser-list' });
    listContainer.style.maxHeight = '400px';
    listContainer.style.overflowY = 'auto';
    listContainer.style.padding = '10px';

    const renderFiles = (filter: string) => {
      listContainer.empty();
      const filtered = filter
        ? this.files.filter(f => f.path.toLowerCase().includes(filter.toLowerCase()))
        : this.files;

      if (filtered.length === 0) {
        listContainer.createEl('p', { 
          text: 'No PDF files found.',
          cls: 'setting-item-description'
        });
        return;
      }

      for (const file of filtered) {
        const item = listContainer.createDiv();
        item.style.padding = '8px';
        item.style.border = '1px solid var(--background-modifier-border)';
        item.style.borderRadius = '4px';
        item.style.marginBottom = '6px';
        item.style.cursor = 'pointer';
        item.style.transition = 'all 0.15s ease';

        // Filename
        const nameEl = item.createEl('div', { text: file.basename });
        nameEl.style.fontWeight = '600';
        nameEl.style.marginBottom = '2px';

        // Path
        const pathEl = item.createEl('div', { text: file.path });
        pathEl.style.fontSize = '0.85em';
        pathEl.style.color = 'var(--text-muted)';

        // Hover effect
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = 'var(--background-modifier-hover)';
        });
        item.addEventListener('mouseleave', () => {
          item.style.backgroundColor = '';
        });

        // Click to select
        item.addEventListener('click', () => {
          this.onSelect(file);
          this.close();
        });
      }
    };

    searchInput.addEventListener('input', (e) => {
      const target = e.target as HTMLInputElement;
      renderFiles(target.value);
    });

    // Initial render
    renderFiles('');
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class PCCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  pcName = "";
  playerName = "";
  campaign = "";
  classes: string[] = [""];
  level = "1";
  hpCurrent = "";
  hpMax = "";
  ac = "10";
  initBonus = "0";
  speed = "30";
  characterSheetUrl = "";
  characterSheetPdf = "";
  isGM = false;
  registerInTracker = true;  // Default: register PCs in Initiative Tracker

  // For editing existing PCs
  isEdit = false;
  originalPCPath = "";
  originalPCName = "";

  constructor(app: App, plugin: DndCampaignHubPlugin, pcPath?: string) {
    super(app);
    this.plugin = plugin;
    this.campaign = plugin.settings.currentCampaign;
    if (pcPath) {
      this.isEdit = true;
      this.originalPCPath = pcPath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    // Load existing PC data if editing
    if (this.isEdit) {
      await this.loadPCData();
    }

    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit Player Character" : "üõ°Ô∏è Create New Player Character" });

    contentEl.createEl("p", {
      text: "Create a new player character with detailed stats and information.",
      cls: "setting-item-description"
    });

    // Campaign Selection
    const campaigns = this.getAllCampaigns();
    const campaignSetting = new Setting(contentEl)
      .setName("Campaign")
      .setDesc("Which campaign does this PC belong to?")
      .addDropdown((dropdown) => {
        campaigns.forEach(campaign => {
          dropdown.addOption(campaign.path, campaign.name);
        });
        dropdown.setValue(this.campaign)
          .onChange(async (value) => {
            this.campaign = value;
            await this.checkCampaignRole();
            this.refresh();
          });
      });

    // Check initial role
    this.checkCampaignRole().then(() => {
      this.buildForm(contentEl);
    });
  }

  async checkCampaignRole() {
    const worldFile = this.app.vault.getAbstractFileByPath(`${this.campaign}/World.md`);
    if (worldFile instanceof TFile) {
      const worldContent = await this.app.vault.read(worldFile);
      const roleMatch = worldContent.match(/^role:\s*([^\r\n]\w*)$/m);
      if (roleMatch && roleMatch[1]) {
        this.isGM = roleMatch[1].toLowerCase() === 'gm';
      }
    }
  }

  buildForm(contentEl: HTMLElement) {
    // Clear existing form content (keep header and campaign selection)
    const children = Array.from(contentEl.children);
    for (let i = children.length - 1; i >= 3; i--) {
      children[i]?.remove();
    }

    // PC Name
    new Setting(contentEl)
      .setName("Character Name")
      .setDesc("The name of the player character")
      .addText((text) => {
        text
          .setPlaceholder("e.g., Gandalf the Grey")
          .setValue(this.pcName)
          .onChange((value) => {
            this.pcName = value;
          });
        if (!this.pcName) text.inputEl.focus();
      });

    // Player Name
    new Setting(contentEl)
      .setName("Player Name")
      .setDesc("Who plays this character?")
      .addText((text) =>
        text
          .setPlaceholder("e.g., John Smith")
          .setValue(this.playerName)
          .onChange((value) => {
            this.playerName = value;
          })
      );

    // GM-only fields
    if (this.isGM) {
      contentEl.createEl("h3", { text: "‚öîÔ∏è Character Stats" });

      // Class (with multiple class support)
      const classContainer = contentEl.createDiv({ cls: "dnd-class-container" });
      
      const updateClassInputs = () => {
        classContainer.empty();
        this.classes.forEach((cls, index) => {
          new Setting(classContainer)
            .setName(index === 0 ? "Class" : `Class ${index + 1}`)
            .setDesc(index === 0 ? "Character class(es)" : "Additional class for multiclassing")
            .addText((text) => {
              text
                .setPlaceholder("e.g., Fighter, Wizard")
                .setValue(cls)
                .onChange((value) => {
                  this.classes[index] = value;
                });
              text.inputEl.style.width = "200px";
            })
            .addButton((button) => {
              if (index === this.classes.length - 1) {
                button
                  .setButtonText("+")
                  .setTooltip("Add another class (multiclassing)")
                  .onClick(() => {
                    this.classes.push("");
                    updateClassInputs();
                  });
              } else {
                button
                  .setButtonText("‚àí")
                  .setTooltip("Remove this class")
                  .setWarning()
                  .onClick(() => {
                    this.classes.splice(index, 1);
                    updateClassInputs();
                  });
              }
            });
        });
      };

      updateClassInputs();

      // Level
      new Setting(contentEl)
        .setName("Level")
        .setDesc("Character level")
        .addText((text) => {
          text
            .setPlaceholder("1")
            .setValue(this.level)
            .onChange((value) => {
              this.level = value;
            });
          text.inputEl.type = "number";
          text.inputEl.style.width = "80px";
        });

      // HP
      const hpSetting = new Setting(contentEl)
        .setName("Hit Points")
        .setDesc("Current HP / Max HP");

      hpSetting.addText((text) => {
        text
          .setPlaceholder("Current")
          .setValue(this.hpCurrent)
          .onChange((value) => {
            this.hpCurrent = value;
          });
        text.inputEl.type = "number";
        text.inputEl.style.width = "80px";
      });

      hpSetting.controlEl.createSpan({ text: " / ", cls: "dnd-hp-separator" });

      hpSetting.addText((text) => {
        text
          .setPlaceholder("Max")
          .setValue(this.hpMax)
          .onChange((value) => {
            this.hpMax = value;
          });
        text.inputEl.type = "number";
        text.inputEl.style.width = "80px";
      });

      // AC
      new Setting(contentEl)
        .setName("Armor Class (AC)")
        .setDesc("Character's AC")
        .addText((text) => {
          text
            .setPlaceholder("10")
            .setValue(this.ac)
            .onChange((value) => {
              this.ac = value;
            });
          text.inputEl.type = "number";
          text.inputEl.style.width = "80px";
        });

      // Initiative Modifier
      new Setting(contentEl)
        .setName("Initiative Modifier")
        .setDesc("Bonus or penalty to initiative rolls")
        .addText((text) => {
          text
            .setPlaceholder("+0")
            .setValue(this.initBonus)
            .onChange((value) => {
              this.initBonus = value;
            });
          text.inputEl.style.width = "80px";
        });

      // Speed
      new Setting(contentEl)
        .setName("Speed")
        .setDesc("Movement speed in feet")
        .addText((text) => {
          text
            .setPlaceholder("30")
            .setValue(this.speed)
            .onChange((value) => {
              this.speed = value;
            });
          text.inputEl.type = "number";
          text.inputEl.style.width = "80px";
        });
    }

    // Character Sheet Links (for both GM and Player)
    contentEl.createEl("h3", { text: "üìÑ Character Sheet" });

    new Setting(contentEl)
      .setName("Digital Character Sheet Link")
      .setDesc("Optional: Link to D&D Beyond, Roll20, or other digital sheet")
      .addText((text) =>
        text
          .setPlaceholder("https://www.dndbeyond.com/characters/...")
          .setValue(this.characterSheetUrl)
          .onChange((value) => {
            this.characterSheetUrl = value;
          })
      );
    
    // Initiative Tracker Integration
    if (this.isGM) {
      contentEl.createEl("h3", { text: "üé≤ Initiative Tracker Integration" });
      
      new Setting(contentEl)
        .setName("Register in Initiative Tracker")
        .setDesc("Automatically add this PC to Initiative Tracker's party management system")
        .addToggle((toggle) =>
          toggle
            .setValue(this.registerInTracker)
            .onChange((value) => {
              this.registerInTracker = value;
            })
        );
    }

    // Character Sheet PDF with file browsing and suggestions
    let pdfTextComponent: TextComponent;
    const pdfSetting = new Setting(contentEl)
      .setName("Character Sheet PDF")
      .setDesc(this.characterSheetPdf ? `Selected: ${this.characterSheetPdf}` : 'Browse vault, import file, or type to search PDFs');

    pdfSetting.addButton(btn => btn
      .setButtonText('Browse Vault')
      .onClick(() => {
        // Get all PDF files from the vault
        const pdfFiles = this.app.vault.getFiles().filter(f => f.extension === 'pdf');
        
        if (pdfFiles.length === 0) {
          new Notice('No PDF files found in vault');
          return;
        }
        
        // Sort PDFs by path
        pdfFiles.sort((a, b) => a.path.localeCompare(b.path));
        
        new PDFBrowserModal(this.app, pdfFiles, (file: TFile) => {
          this.characterSheetPdf = file.path;
          pdfSetting.setDesc(`Selected: ${this.characterSheetPdf}`);
          pdfTextComponent?.setValue(file.path);
        }).open();
      })
    );

    pdfSetting.addButton(btn => btn
      .setButtonText('Import File')
      .onClick(() => {
        // Use hidden file input to pick from OS file system
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.pdf,application/pdf';
        input.addEventListener('change', async () => {
          const file = input.files?.[0];
          if (!file) return;
          
          // Validate it's a PDF
          if (!file.name.toLowerCase().endsWith('.pdf')) {
            new Notice('Please select a PDF file');
            return;
          }
          
          try {
            const buffer = await file.arrayBuffer();
            // Ensure z_Assets folder exists
            const assetsFolder = this.app.vault.getAbstractFileByPath('z_Assets');
            if (!assetsFolder) {
              await this.app.vault.createFolder('z_Assets');
            }
            // Save to z_Assets with original filename
            const destPath = `z_Assets/${file.name}`;
            const existing = this.app.vault.getAbstractFileByPath(destPath);
            if (existing) {
              // File already exists, just use it
              this.characterSheetPdf = destPath;
            } else {
              await this.app.vault.createBinary(destPath, buffer);
              this.characterSheetPdf = destPath;
            }
            pdfSetting.setDesc(`Selected: ${this.characterSheetPdf}`);
            pdfTextComponent?.setValue(this.characterSheetPdf);
            new Notice(`PDF saved to ${destPath}`);
          } catch (err) {
            new Notice('Failed to import PDF');
            console.error('PDF import error:', err);
          }
        });
        input.click();
      })
    );

    pdfSetting.addText((text) => {
      pdfTextComponent = text;
      text
        .setPlaceholder("Type to search vault PDFs...")
        .setValue(this.characterSheetPdf)
        .onChange((value) => {
          this.characterSheetPdf = value;
          pdfSetting.setDesc(value ? `Selected: ${value}` : 'Browse vault, import file, or type to search PDFs');
        });
      
      // Enable file suggestions for PDFs
      new PDFFileSuggest(this.app, text.inputEl);
    });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update PC" : "Create PC",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      if (!this.pcName.trim()) {
        new Notice("Please enter a character name!");
        return;
      }

      this.close();
      await this.createPCFile();
    });
  }

  refresh() {
    const { contentEl } = this;
    this.buildForm(contentEl);
  }

  async loadPCData() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.originalPCPath) as TFile;
      if (!file) {
        new Notice("PC file not found!");
        return;
      }

      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      
      if (cache?.frontmatter) {
        const fm = cache.frontmatter;
        this.pcName = fm.name || file.basename;
        this.originalPCName = this.pcName;
        this.playerName = fm.player || "";
        this.campaign = fm.campaign ? `ttrpgs/${fm.campaign}` : this.campaign;
        
        // Parse class string (could be multiclass like "Fighter/Wizard")
        if (fm.class) {
          this.classes = fm.class.toString().split("/").map((c: string) => c.trim());
        }
        
        this.level = fm.level?.toString() || "1";
        this.hpCurrent = fm.hp?.toString() || "";
        this.hpMax = fm.hp_max?.toString() || "";
        this.ac = fm.ac?.toString() || "10";
        this.initBonus = fm.init_bonus?.toString() || "0";
        this.speed = fm.speed?.toString() || "30";
        this.characterSheetUrl = fm.readonlyUrl || "";
        this.characterSheetPdf = fm.characterSheetPdf || "";
      }

      console.log(`[PC Edit] Loaded PC data: ${this.pcName}`);
    } catch (error) {
      console.error("Error loading PC data:", error);
      new Notice("Error loading PC data. Check console for details.");
    }
  }

  getAllCampaigns(): Array<{ path: string; name: string }> {
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
    const campaigns: Array<{ path: string; name: string }> = [];

    if (ttrpgsFolder instanceof TFolder) {
      ttrpgsFolder.children.forEach((child) => {
        if (child instanceof TFolder) {
          campaigns.push({
            path: child.path,
            name: child.name
          });
        }
      });
    }

    return campaigns;
  }

  async createPCFile() {
    const campaignName = this.campaign.split('/').pop() || "Unknown";
    const pcPath = `${this.campaign}/PCs`;
    
    new Notice(this.isEdit ? `Updating PC "${this.pcName}"...` : `Creating PC "${this.pcName}"...`);

    try {
      await this.plugin.ensureFolderExists(pcPath);

      // Get world info from campaign World.md
      const worldFile = this.app.vault.getAbstractFileByPath(`${this.campaign}/World.md`);
      let worldName = campaignName;
      
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const worldMatch = worldContent.match(/^world:\s*([^\r\n]\w*)$/m);
        if (worldMatch && worldMatch[1] && worldMatch[1].trim()) {
          worldName = worldMatch[1].trim();
        }
      }

      let tokenId: string;
      let pcFile: TFile | null = null;
      let filePath: string;

      if (this.isEdit) {
        // Editing existing PC
        pcFile = this.app.vault.getAbstractFileByPath(this.originalPCPath) as TFile;
        if (!pcFile) {
          new Notice("Original PC file not found!");
          return;
        }
        
        // Get existing token ID from frontmatter
        const cache = this.app.metadataCache.getFileCache(pcFile);
        tokenId = cache?.frontmatter?.token_id || this.plugin.markerLibrary.generateId();
        
        filePath = this.originalPCPath;

        // If PC name changed, rename the file
        if (this.pcName !== this.originalPCName) {
          const folder = filePath.substring(0, filePath.lastIndexOf('/'));
          const newPath = `${folder}/${this.pcName}.md`;
          
          // Check if new name conflicts
          if (await this.app.vault.adapter.exists(newPath)) {
            new Notice(`A PC named "${this.pcName}" already exists!`);
            return;
          }
          
          await this.app.fileManager.renameFile(pcFile, newPath);
          filePath = newPath;
          pcFile = this.app.vault.getAbstractFileByPath(newPath) as TFile;
        }
        
        // Update the map token
        const now = Date.now();
        const tokenDef: MarkerDefinition = {
          id: tokenId,
          name: this.pcName,
          type: 'player',
          icon: 'üõ°Ô∏è',
          backgroundColor: '#4a90d9',
          borderColor: '#ffffff',
          creatureSize: 'medium',
          createdAt: now,
          updatedAt: now
        };
        await this.plugin.markerLibrary.setMarker(tokenDef);
      } else {
        // Creating new PC
        // Create a map token for this PC
        const now = Date.now();
        tokenId = this.plugin.markerLibrary.generateId();
        const tokenDef: MarkerDefinition = {
          id: tokenId,
          name: this.pcName,
          type: 'player',
          icon: 'üõ°Ô∏è',
          backgroundColor: '#4a90d9',  // Blue for players
          borderColor: '#ffffff',
          creatureSize: 'medium',
          createdAt: now,
          updatedAt: now
        };
        await this.plugin.markerLibrary.setMarker(tokenDef);

        filePath = `${pcPath}/${this.pcName}.md`;

        // Check if PC already exists
        if (await this.app.vault.adapter.exists(filePath)) {
          new Notice(`A PC named "${this.pcName}" already exists!`);
          return;
        }
      }

      // Get PC content - use existing file content when editing, template for new PCs
      let pcContent: string;

      if (this.isEdit && pcFile) {
        // Preserve existing content when editing
        pcContent = await this.app.vault.read(pcFile);
      } else {
        // Use template for new PCs
        const templatePath = "z_Templates/Frontmatter - Player Character.md";
        const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
        
        if (templateFile instanceof TFile) {
          pcContent = await this.app.vault.read(templateFile);
        } else {
          pcContent = PC_TEMPLATE;
        }
      }

      // Get current date
      const currentDate = new Date().toISOString().split('T')[0];

      // Combine classes into a single string
      const classString = this.classes.filter(c => c.trim()).join("/");

      // Build complete frontmatter
      const frontmatter = `---
type: player
name: ${this.pcName}
player: ${this.playerName}
campaign: ${campaignName}
world: ${worldName}
race: 
class: ${classString}
subclass: 
level: ${this.level}
hp: ${this.hpCurrent || "0"}
hp_max: ${this.hpMax || "0"}
thp: 0
ac: ${this.ac}
init_bonus: ${this.initBonus}
speed: ${this.speed}
passive_perception: 10
background: 
alignment: 
experience: 0
readonlyUrl: ${this.characterSheetUrl}
characterSheetPdf: ${this.characterSheetPdf}
token_id: ${tokenId}
date: ${currentDate}
---`;

      // Replace the frontmatter
      pcContent = pcContent.replace(/^---\n[\s\S]*?\n---/, frontmatter);
      
      // Replace the title
      pcContent = pcContent.replace(/# <% tp\.frontmatter\.name %>/, `# ${this.pcName}`);

      // Replace template references with actual values
      pcContent = pcContent
        .replace(/<% tp\.frontmatter\.name %>/g, this.pcName)
        .replace(/<% tp\.frontmatter\.class %>/g, classString)
        .replace(/<% tp\.frontmatter\.level %>/g, this.level)
        .replace(/<% tp\.frontmatter\.hp %>/g, this.hpCurrent || "0")
        .replace(/<% tp\.frontmatter\.hp_max %>/g, this.hpMax || "0")
        .replace(/<% tp\.frontmatter\.ac %>/g, this.ac)
        .replace(/<% tp\.frontmatter\.init_bonus %>/g, this.initBonus)
        .replace(/<% tp\.frontmatter\.speed %>/g, this.speed)
        .replace(/<% tp\.frontmatter\.readonlyUrl \? "\[Digital Character Sheet\]\(" \+ tp\.frontmatter\.readonlyUrl \+ "\)" : "_No digital sheet linked_" %>/g, 
          this.characterSheetUrl ? `[Digital Character Sheet](${this.characterSheetUrl})` : "_No digital sheet linked_")
        .replace(/<% tp\.frontmatter\.characterSheetPdf \? "\[\[" \+ tp\.frontmatter\.characterSheetPdf \+ "\|Character Sheet PDF\]\]" : "_No PDF uploaded_" %>/g,
          this.characterSheetPdf ? `[[${this.characterSheetPdf}|Character Sheet PDF]]` : "_No PDF uploaded_");

      // When editing, also replace already-rendered content (not just Templater placeholders)
      if (this.isEdit) {
        // Replace existing PDF link or placeholder
        pcContent = pcContent
          .replace(/\[\[[^\]]+\|Character Sheet PDF\]\]/g, 
            this.characterSheetPdf ? `[[${this.characterSheetPdf}|Character Sheet PDF]]` : "_No PDF uploaded_")
          .replace(/_No PDF uploaded_/g, 
            this.characterSheetPdf ? `[[${this.characterSheetPdf}|Character Sheet PDF]]` : "_No PDF uploaded_");
        
        // Replace existing URL link or placeholder
        pcContent = pcContent
          .replace(/\[Digital Character Sheet\]\([^)]+\)/g, 
            this.characterSheetUrl ? `[Digital Character Sheet](${this.characterSheetUrl})` : "_No digital sheet linked_")
          .replace(/_No digital sheet linked_/g, 
            this.characterSheetUrl ? `[Digital Character Sheet](${this.characterSheetUrl})` : "_No digital sheet linked_");
      }

      // Create or update the file
      if (this.isEdit && pcFile) {
        await this.app.vault.modify(pcFile, pcContent);
        new Notice(`‚úÖ PC "${this.pcName}" updated successfully!`);
      } else {
        await this.app.vault.create(filePath, pcContent);
        new Notice(`‚úÖ PC "${this.pcName}" created successfully!`);
        pcFile = this.app.vault.getAbstractFileByPath(filePath) as TFile;
      }

      // Open the file
      if (pcFile) {
        await this.app.workspace.openLinkText(filePath, "", false);
      }
      
      // Register in Initiative Tracker if requested (only for new PCs)
      if (!this.isEdit && this.registerInTracker && this.isGM) {
        await this.registerPCInInitiativeTracker(filePath);
      }
    } catch (error) {
      new Notice(`‚ùå Error ${this.isEdit ? 'updating' : 'creating'} PC: ${error instanceof Error ? error.message : String(error)}`);
      console.error(`PC ${this.isEdit ? 'update' : 'creation'} error:`, error);
    }
  }

  /**
   * Register PC in Initiative Tracker's party management system
   */
  async registerPCInInitiativeTracker(pcFilePath: string) {
    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin) {
        new Notice("‚ö†Ô∏è Initiative Tracker not found. PC created but not registered in tracker.");
        return;
      }

      // Initialize players array if it doesn't exist
      if (!initiativePlugin.data.players) {
        initiativePlugin.data.players = [];
      }

      // Check if player already exists (by name or path)
      const existingPlayer = initiativePlugin.data.players.find((p: any) => 
        p.name === this.pcName || p.path === pcFilePath
      );
      
      if (existingPlayer) {
        new Notice(`‚ö†Ô∏è ${this.pcName} already registered in Initiative Tracker. Skipping duplicate registration.`);
        console.log("Player already exists:", existingPlayer);
        return;
      }

      // Generate unique ID for the player
      const playerId = this.generatePlayerId();
      
      // Parse initiative modifier - handle both "+2" and "2" formats
      console.log("Raw initBonus value:", this.initBonus);
      const initMod = parseInt(this.initBonus.replace(/[^-\d]/g, '')) || 0;
      console.log("Parsed initiative modifier:", initMod);
      
      // Parse HP values
      const currentHP = parseInt(this.hpCurrent) || parseInt(this.hpMax) || 1;
      const maxHP = parseInt(this.hpMax) || currentHP;
      
      // Parse AC
      const armorClass = parseInt(this.ac) || 10;
      
      // Parse level
      const charLevel = parseInt(this.level) || 1;
      
      // Create player data in Initiative Tracker format
      const playerData = {
        name: this.pcName,
        display: this.pcName,  // CRITICAL: Display name for party view
        id: playerId,
        initiative: 0,
        static: false,
        modifier: initMod,
        hp: maxHP,
        currentMaxHP: maxHP,
        currentHP: currentHP,
        tempHP: 0,
        ac: armorClass,
        currentAC: armorClass,
        level: charLevel,
        path: pcFilePath,  // Link to PC note in vault
        note: pcFilePath,  // Also used for "Link to Note" display
        player: true,
        marker: "default",
        status: [],
        enabled: true,
        active: false,
        hidden: false,
        friendly: true,
        rollHP: false
      };
      
      console.log("Player data to save:", JSON.stringify(playerData, null, 2));

      // Initialize players array if it doesn't exist
      if (!initiativePlugin.data.players) {
        initiativePlugin.data.players = [];
      }

      // Add player to Initiative Tracker
      initiativePlugin.data.players.push(playerData);

      // Get or create party for this campaign
      const campaignName = this.campaign.split('/').pop() || "Unknown Campaign";
      const partyId = await this.getOrCreateCampaignParty(campaignName, initiativePlugin);
      
      // Add player to party
      if (!initiativePlugin.data.parties) {
        initiativePlugin.data.parties = [];
      }
      
      const party = initiativePlugin.data.parties.find((p: any) => p.id === partyId);
      if (party && !party.players.includes(this.pcName)) {
        // Party.players stores player NAMES, not IDs
        party.players.push(this.pcName);
        
        // Clean up any orphaned entries (names that don't exist in players array)
        const validPlayerNames = new Set(initiativePlugin.data.players.map((p: any) => p.name));
        party.players = party.players.filter((name: string) => validPlayerNames.has(name));
      }

      // Save Initiative Tracker settings
      if (initiativePlugin.saveSettings) {
        await initiativePlugin.saveSettings();
        new Notice(`‚úÖ ${this.pcName} registered in Initiative Tracker party!`);
      }
    } catch (error) {
      console.error("Error registering PC in Initiative Tracker:", error);
      new Notice("‚ö†Ô∏è PC created but could not register in Initiative Tracker. Check console for details.");
    }
  }

  /**
   * Get existing party for campaign or create a new one
   */
  async getOrCreateCampaignParty(campaignName: string, initiativePlugin: any): Promise<string> {
    const partyName = `${campaignName} Party`;
    
    // Initialize parties array if needed
    if (!initiativePlugin.data.parties) {
      initiativePlugin.data.parties = [];
    }
    
    // Check if party already exists
    const existingParty = initiativePlugin.data.parties.find((p: any) => p.name === partyName);
    if (existingParty) {
      return existingParty.id;
    }
    
    // Create new party
    const partyId = this.generatePlayerId(); // Reuse the ID generator
    const newParty = {
      name: partyName,
      id: partyId,
      players: []
    };
    
    initiativePlugin.data.parties.push(newParty);
    
    // Set as default party if no default exists
    if (!initiativePlugin.data.defaultParty) {
      initiativePlugin.data.defaultParty = partyId;
    }
    
    return partyId;
  }

  /**
   * Generate unique ID for player/party
   */
  generatePlayerId(): string {
    const chars = '0123456789abcdef';
    let id = 'ID_';
    for (let i = 0; i < 12; i++) {
      id += chars[Math.floor(Math.random() * chars.length)];
    }
    return id;
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class NPCCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  npcName = "";
  campaign = "";
  motivation = "";
  pursuit = "";
  physicalDetail = "";
  speechPattern = "";
  activeProblem = "";

  // For editing existing NPCs
  isEdit = false;
  originalNPCPath = "";
  originalNPCName = "";

  constructor(app: App, plugin: DndCampaignHubPlugin, npcPath?: string) {
    super(app);
    this.plugin = plugin;
    this.campaign = plugin.settings.currentCampaign;
    if (npcPath) {
      this.isEdit = true;
      this.originalNPCPath = npcPath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    // Load existing NPC data if editing
    if (this.isEdit) {
      await this.loadNPCData();
    }

    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit NPC" : "üë§ Create New NPC" });

    contentEl.createEl("p", {
      text: "Build your NPC's core engine with these essential questions.",
      cls: "setting-item-description"
    });

    // NPC Name
    new Setting(contentEl)
      .setName("NPC Name")
      .setDesc("What is this character's name?")
      .addText((text) => {
        text
          .setPlaceholder("e.g., Gundren Rockseeker")
          .setValue(this.npcName)
          .onChange((value) => {
            this.npcName = value;
          });
        if (!this.isEdit) text.inputEl.focus();
      });

    // Campaign Selection
    const campaigns = this.getAllCampaigns();
    new Setting(contentEl)
      .setName("Campaign")
      .setDesc("Which campaign does this NPC belong to?")
      .addDropdown((dropdown) => {
        campaigns.forEach(campaign => {
          dropdown.addOption(campaign.path, campaign.name);
        });
        dropdown.setValue(this.campaign)
          .onChange((value) => {
            this.campaign = value;
          });
      });

    contentEl.createEl("h3", { text: "üé≠ Core NPC Engine" });

    // Motivation: What do they want?
    new Setting(contentEl)
      .setName("What do they want?")
      .setDesc("The NPC's primary motivation or goal")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., To reclaim their family's mine from goblin invaders")
          .setValue(this.motivation)
          .onChange((value) => {
            this.motivation = value;
          });
        text.inputEl.rows = 3;
      });

    // Pursuit: How do they pursue it?
    new Setting(contentEl)
      .setName("How do they pursue it?")
      .setDesc("Their methods, approach, or behavior in achieving their goal")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., By hiring adventurers and offering generous rewards")
          .setValue(this.pursuit)
          .onChange((value) => {
            this.pursuit = value;
          });
        text.inputEl.rows = 3;
      });

    contentEl.createEl("h3", { text: "üé® Character Details" });

    // Physical Detail
    new Setting(contentEl)
      .setName("Physical Detail")
      .setDesc("A memorable physical characteristic or appearance note")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Scarred hands from years of mining, always wears a bronze pendant")
          .setValue(this.physicalDetail)
          .onChange((value) => {
            this.physicalDetail = value;
          });
        text.inputEl.rows = 2;
      });

    // Speech Pattern
    new Setting(contentEl)
      .setName("Speech Pattern")
      .setDesc("How do they speak? Any quirks, accents, or mannerisms?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Gruff but warm, often uses mining metaphors")
          .setValue(this.speechPattern)
          .onChange((value) => {
            this.speechPattern = value;
          });
        text.inputEl.rows = 2;
      });

    contentEl.createEl("h3", { text: "‚ö†Ô∏è Current Situation" });

    // Active Problem
    new Setting(contentEl)
      .setName("Active Problem")
      .setDesc("What problem or conflict is this NPC currently facing?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Captured by goblins while traveling to Phandalin")
          .setValue(this.activeProblem)
          .onChange((value) => {
            this.activeProblem = value;
          });
        text.inputEl.rows = 3;
      });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update NPC" : "Create NPC",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      if (!this.npcName.trim()) {
        new Notice("Please enter an NPC name!");
        return;
      }

      this.close();
      await this.createNPCFile();
    });
  }

  async loadNPCData() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.originalNPCPath) as TFile;
      if (!file) {
        new Notice("NPC file not found!");
        return;
      }

      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      
      if (cache?.frontmatter) {
        const fm = cache.frontmatter;
        this.npcName = fm.name || file.basename;
        this.originalNPCName = this.npcName;
        this.campaign = fm.campaign ? `ttrpgs/${fm.campaign}` : this.campaign;
        this.motivation = fm.motivation || "";
        this.pursuit = fm.pursuit || "";
        this.physicalDetail = fm.physical_detail || "";
        this.speechPattern = fm.speech_pattern || "";
        this.activeProblem = fm.active_problem || "";
      }

      console.log(`[NPC Edit] Loaded NPC data: ${this.npcName}`);
    } catch (error) {
      console.error("Error loading NPC data:", error);
      new Notice("Error loading NPC data. Check console for details.");
    }
  }

  getAllCampaigns(): Array<{ path: string; name: string }> {
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
    const campaigns: Array<{ path: string; name: string }> = [];

    if (ttrpgsFolder instanceof TFolder) {
      ttrpgsFolder.children.forEach((child) => {
        if (child instanceof TFolder) {
          campaigns.push({
            path: child.path,
            name: child.name
          });
        }
      });
    }

    return campaigns;
  }

  async createNPCFile() {
    const campaignName = this.campaign.split('/').pop() || "Unknown";
    const npcPath = `${this.campaign}/NPCs`;
    
    new Notice(this.isEdit ? `Updating NPC "${this.npcName}"...` : `Creating NPC "${this.npcName}"...`);

    try {
      await this.plugin.ensureFolderExists(npcPath);

      // Get world info from campaign World.md
      const worldFile = this.app.vault.getAbstractFileByPath(`${this.campaign}/World.md`);
      let worldName = campaignName;
      
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const worldMatch = worldContent.match(/^world:\s*(.+)$/m);
        if (worldMatch && worldMatch[1]) {
          worldName = worldMatch[1].trim();
        }
      }

      let tokenId: string;
      let npcFile: TFile | null = null;
      let filePath: string;

      if (this.isEdit) {
        // Editing existing NPC
        npcFile = this.app.vault.getAbstractFileByPath(this.originalNPCPath) as TFile;
        if (!npcFile) {
          new Notice("Original NPC file not found!");
          return;
        }
        
        // Get existing token ID from frontmatter
        const cache = this.app.metadataCache.getFileCache(npcFile);
        tokenId = cache?.frontmatter?.token_id || this.plugin.markerLibrary.generateId();
        
        filePath = this.originalNPCPath;

        // If NPC name changed, rename the file
        if (this.npcName !== this.originalNPCName) {
          const folder = filePath.substring(0, filePath.lastIndexOf('/'));
          const newPath = `${folder}/${this.npcName}.md`;
          
          // Check if new name conflicts
          if (await this.app.vault.adapter.exists(newPath)) {
            new Notice(`An NPC named "${this.npcName}" already exists!`);
            return;
          }
          
          await this.app.fileManager.renameFile(npcFile, newPath);
          filePath = newPath;
          npcFile = this.app.vault.getAbstractFileByPath(newPath) as TFile;
        }
        
        // Update the map token
        const now = Date.now();
        const tokenDef: MarkerDefinition = {
          id: tokenId,
          name: this.npcName,
          type: 'npc',
          icon: 'üë§',
          backgroundColor: '#6b8e23',
          borderColor: '#ffffff',
          creatureSize: 'medium',
          createdAt: now,
          updatedAt: now
        };
        await this.plugin.markerLibrary.setMarker(tokenDef);
      } else {
        // Creating new NPC
        // Create a map token for this NPC
        const now = Date.now();
        tokenId = this.plugin.markerLibrary.generateId();
        const tokenDef: MarkerDefinition = {
          id: tokenId,
          name: this.npcName,
          type: 'npc',
          icon: 'üë§',
          backgroundColor: '#6b8e23',  // Olive green for NPCs
          borderColor: '#ffffff',
          creatureSize: 'medium',
          createdAt: now,
          updatedAt: now
        };
        await this.plugin.markerLibrary.setMarker(tokenDef);

        filePath = `${npcPath}/${this.npcName}.md`;

        // Check if NPC already exists
        if (await this.app.vault.adapter.exists(filePath)) {
          new Notice(`An NPC named "${this.npcName}" already exists!`);
          return;
        }
      }

      // Get NPC content - use existing file content when editing, template for new NPCs
      let npcContent: string;

      if (this.isEdit && npcFile) {
        // Preserve existing content when editing
        npcContent = await this.app.vault.read(npcFile);
      } else {
        // Use template for new NPCs
        const templatePath = "z_Templates/npc.md";
        const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
        
        if (templateFile instanceof TFile) {
          npcContent = await this.app.vault.read(templateFile);
        } else {
          npcContent = NPC_TEMPLATE;
        }
      }

      // Get current date
      const currentDate = new Date().toISOString().split('T')[0];

      // Replace placeholders in template - both frontmatter and content
      npcContent = npcContent
        .replace(/name: $/m, `name: ${this.npcName}`)
        .replace(/world: $/m, `world: ${worldName}`)
        .replace(/campaign: $/m, `campaign: ${campaignName}`)
        .replace(/date: $/m, `date: ${currentDate}\ntoken_id: ${tokenId}`)
        .replace(/motivation: $/m, `motivation: "${this.motivation}"`)
        .replace(/pursuit: $/m, `pursuit: "${this.pursuit}"`)
        .replace(/physical_detail: $/m, `physical_detail: "${this.physicalDetail}"`)
        .replace(/speech_pattern: $/m, `speech_pattern: "${this.speechPattern}"`)
        .replace(/active_problem: $/m, `active_problem: "${this.activeProblem}"`)
        .replace(/# <% tp\.frontmatter\.name %>/g, `# ${this.npcName}`)
        .replace(/<% tp\.frontmatter\.name %>/g, this.npcName)
        .replace(/<% tp\.frontmatter\.motivation %>/g, this.motivation)
        .replace(/<% tp\.frontmatter\.pursuit %>/g, this.pursuit)
        .replace(/<% tp\.frontmatter\.active_problem %>/g, this.activeProblem)
        .replace(/<% tp\.frontmatter\.physical_detail %>/g, this.physicalDetail)
        .replace(/<% tp\.frontmatter\.speech_pattern %>/g, this.speechPattern);

      // Create or update the file
      if (this.isEdit && npcFile) {
        await this.app.vault.modify(npcFile, npcContent);
        new Notice(`‚úÖ NPC "${this.npcName}" updated successfully!`);
      } else {
        await this.app.vault.create(filePath, npcContent);
        new Notice(`‚úÖ NPC "${this.npcName}" created successfully!`);
        npcFile = this.app.vault.getAbstractFileByPath(filePath) as TFile;
      }

      // Open the file
      if (npcFile) {
        await this.app.workspace.openLinkText(filePath, "", false);
      }
    } catch (error) {
      new Notice(`‚ùå Error ${this.isEdit ? 'updating' : 'creating'} NPC: ${error instanceof Error ? error.message : String(error)}`);
      console.error(`NPC ${this.isEdit ? 'update' : 'creation'} error:`, error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * Session Prep Dashboard - Central hub for GM session preparation (View)
 */
class SessionPrepDashboardView extends ItemView {
  plugin: DndCampaignHubPlugin;
  campaignPath: string;
  private refreshInterval: number | null = null;
  private activeLeafChangeRef: any = null;

  constructor(leaf: WorkspaceLeaf, plugin: DndCampaignHubPlugin) {
    super(leaf);
    this.plugin = plugin;
    this.campaignPath = plugin.settings.currentCampaign;
  }

  getViewType(): string {
    return SESSION_PREP_VIEW_TYPE;
  }

  getDisplayText(): string {
    return "Session Prep Dashboard";
  }

  getIcon(): string {
    return "clipboard-list";
  }

  setCampaign(campaignPath: string) {
    this.campaignPath = campaignPath;
    this.render();
  }

  async onOpen() {
    // Ensure the view container takes full width of the leaf
    this.containerEl.style.width = "100%";
    this.containerEl.style.minWidth = "0";
    this.containerEl.style.maxWidth = "none";
    
    await this.render();

    // Set up auto-refresh every 30 seconds
    this.refreshInterval = window.setInterval(() => {
      this.render();
    }, 30000);

    // Refresh when this view becomes active
    this.activeLeafChangeRef = this.app.workspace.on('active-leaf-change', (leaf) => {
      if (leaf?.view === this) {
        this.render();
      }
    });
  }

  async render() {
    const container = this.containerEl.children[1] as HTMLElement;
    container.empty();
    container.addClass("session-prep-dashboard");

    // Compact Header
    const header = container.createEl("div", { cls: "dashboard-header" });
    const headerTitle = header.createEl("div", { cls: "dashboard-header-title" });
    headerTitle.createEl("span", { text: "üìã Session Prep", cls: "dashboard-title" });
    const campaignName = this.campaignPath.split('/').pop() || "Unknown";
    headerTitle.createEl("span", { 
      text: campaignName,
      cls: "dashboard-campaign-name"
    });

    // Main action button
    const mainAction = container.createEl("button", {
      text: "üìù New Session",
      cls: "dashboard-main-action mod-cta"
    });
    mainAction.addEventListener("click", () => {
      this.plugin.createSession();
    });

    // Adventures & Next Scene (Primary focus)
    await this.renderAdventuresAndScenes(container);

    // Quick Actions (Collapsible)
    await this.renderQuickActions(container);

    // Party Overview (Collapsible)
    await this.renderPartyStats(container);

    // Recent NPCs (Collapsible)
    await this.renderRecentNPCsSection(container);

    // Last Session Recap (Collapsible)
    await this.renderLastSessionRecap(container);

    // Footer with refresh
    const footer = container.createEl("div", { cls: "dashboard-footer" });
    const refreshBtn = footer.createEl("button", { 
      text: "üîÑ",
      cls: "dashboard-refresh-btn"
    });
    refreshBtn.addEventListener("click", () => this.render());
  }

  async renderQuickActions(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section collapsible" });
    const header = section.createEl("div", { cls: "section-header" });
    const toggle = header.createEl("span", { text: "‚ñ∂", cls: "toggle-icon" });
    header.createEl("span", { text: "‚ö° Quick Actions" });
    
    const content = section.createEl("div", { cls: "section-content" });
    content.style.display = "none";
    
    const actionsGrid = content.createEl("div", { cls: "actions-grid" });
    const allActions = [
      { text: "üìù Session", cmd: "dnd-campaign-hub:create-session" },
      { text: "üé¨ Scene", cmd: "dnd-campaign-hub:create-scene" },
      { text: "‚öîÔ∏è Encounter", cmd: "dnd-campaign-hub:create-encounter" },
      { text: "üó∫Ô∏è Adventure", cmd: "dnd-campaign-hub:create-adventure" },
      { text: "üë§ NPC", cmd: "dnd-campaign-hub:create-npc" },
      { text: "üé≠ PC", cmd: "dnd-campaign-hub:create-pc" },
      { text: "üêâ Creature", cmd: "dnd-campaign-hub:create-creature" },
      { text: "üèõÔ∏è Faction", cmd: "dnd-campaign-hub:create-faction" },
      { text: "‚öîÔ∏è Item", cmd: "dnd-campaign-hub:create-item" },
      { text: "‚ú® Spell", cmd: "dnd-campaign-hub:create-spell" },
      { text: "ü™§ Trap", cmd: "dnd-campaign-hub:create-trap" }
    ];

    for (const action of allActions) {
      const btn = actionsGrid.createEl("button", {
        text: action.text,
        cls: "action-btn"
      });
      btn.addEventListener("click", () => {
        (this.app as any).commands?.executeCommandById(action.cmd);
      });
    }

    let isExpanded = false;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      content.style.display = isExpanded ? "block" : "none";
      toggle.textContent = isExpanded ? "‚ñº" : "‚ñ∂";
    });
  }

  async renderRecentNPCsSection(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section collapsible" });
    const header = section.createEl("div", { cls: "section-header" });
    const toggle = header.createEl("span", { text: "‚ñ∂", cls: "toggle-icon" });
    header.createEl("span", { text: "üë• Recent NPCs" });
    
    const content = section.createEl("div", { cls: "section-content" });
    content.style.display = "none";

    // Get NPCs from the campaign
    const npcsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/NPCs`);
    
    if (!(npcsFolder instanceof TFolder)) {
      content.createEl("p", { text: "No NPCs found", cls: "empty-msg" });
    } else {
      const npcFiles: TFile[] = [];
      for (const item of npcsFolder.children) {
        if (item instanceof TFile && item.extension === "md") {
          npcFiles.push(item);
        }
      }

      npcFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);
      const recentNPCs = npcFiles.slice(0, 8);

      if (recentNPCs.length === 0) {
        content.createEl("p", { text: "No NPCs yet", cls: "empty-msg" });
      } else {
        const npcGrid = content.createEl("div", { cls: "npc-grid" });
        for (const npc of recentNPCs) {
          const npcLink = npcGrid.createEl("a", { 
            href: npc.path,
            cls: "npc-tag"
          });
          npcLink.textContent = npc.basename;
          npcLink.addEventListener("click", async (e) => {
            e.preventDefault();
            await this.app.workspace.openLinkText(npc.path, "", false);
          });
        }
      }
    }

    let isExpanded = false;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      content.style.display = isExpanded ? "block" : "none";
      toggle.textContent = isExpanded ? "‚ñº" : "‚ñ∂";
    });
  }

  async renderAdventuresAndScenes(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "üó∫Ô∏è Adventure Progress", cls: "section-title" });

    // Get all adventures in this campaign
    const adventures = await this.getActiveAdventures();

    if (adventures.length === 0) {
      container.createEl("p", { text: "No active adventures found." });
      return;
    }

    for (const adventure of adventures) {
      const adventureCard = container.createEl("div", { cls: "dashboard-adventure-card" });
      
      // Adventure header
      const adventureHeader = adventureCard.createEl("div", { cls: "adventure-header" });
      const adventureLink = adventureHeader.createEl("a", {
        cls: "adventure-title",
        href: adventure.path
      });
      adventureLink.textContent = `${adventure.name}`;
      adventureLink.addEventListener("click", async (e) => {
        e.preventDefault();
        await this.app.workspace.openLinkText(adventure.path, "", false);
      });

      const statusBadge = adventureHeader.createEl("span", {
        cls: `status-badge status-${adventure.status}`,
        text: adventure.status
      });

      // Get scenes for this adventure
      const scenes = await this.getScenesForAdventure(adventure.path);
      
      if (scenes.length === 0) {
        adventureCard.createEl("p", { text: "No scenes yet" });
        continue;
      }

      // Find next scene (first not-completed)
      const nextScene = scenes.find(s => s.status !== "completed") || scenes[0];
      const completedCount = scenes.filter(s => s.status === "completed").length;

      // Progress bar
      const progressContainer = adventureCard.createEl("div", { cls: "progress-container" });
      progressContainer.createEl("span", { 
        text: `Progress: ${completedCount}/${scenes.length} scenes completed`
      });
      const progressBar = progressContainer.createEl("div", { cls: "progress-bar" });
      const progressFill = progressBar.createEl("div", { cls: "progress-fill" });
      progressFill.style.width = `${(completedCount / scenes.length) * 100}%`;

      // Next scene card
      if (nextScene) {
        const nextSceneCard = adventureCard.createEl("div", { cls: "next-scene-card" });
        nextSceneCard.createEl("strong", { text: "üé¨ Next Up:" });
        
        const sceneLink = nextSceneCard.createEl("a", {
          cls: "scene-link",
          href: nextScene.path
        });
        sceneLink.textContent = `Scene ${nextScene.number}: ${nextScene.name}`;
        sceneLink.addEventListener("click", async (e) => {
          e.preventDefault();
          await this.app.workspace.openLinkText(nextScene.path, "", false);
        });

        // Scene preview
        const scenePreview = nextSceneCard.createEl("div", { cls: "scene-preview" });
        scenePreview.createEl("span", { 
          text: `‚è±Ô∏è ${nextScene.duration} | ${this.getSceneIcon(nextScene.type)} ${nextScene.type} | üé≤ ${nextScene.difficulty}`
        });

        // Quick scene details if available
        if (nextScene.goal) {
          scenePreview.createEl("p", { 
            text: `Goal: ${nextScene.goal}`,
            cls: "scene-goal"
          });
        }

        // Open scene button
        const openBtn = nextSceneCard.createEl("button", {
          text: "Open Scene",
          cls: "mod-cta"
        });
        openBtn.addEventListener("click", async () => {
          await this.app.workspace.openLinkText(nextScene.path, "", false);
        });
      }

      // Upcoming scenes (collapsed by default)
      if (scenes.length > 1) {
        const upcomingHeader = adventureCard.createEl("div", { cls: "upcoming-header" });
        const toggleBtn = upcomingHeader.createEl("button", {
          text: `‚ñ∂ Show ${scenes.length - 1} more scenes`,
          cls: "upcoming-toggle"
        });

        const upcomingList = adventureCard.createEl("div", { cls: "upcoming-scenes-list" });
        upcomingList.style.display = "none";

        for (const scene of scenes) {
          if (scene.path === nextScene?.path) continue; // Skip the next scene

          const sceneItem = upcomingList.createEl("div", { cls: "scene-list-item" });
          const statusIcon = scene.status === "completed" ? "‚úÖ" : "‚¨ú";
          const sceneItemLink = sceneItem.createEl("a", { href: scene.path });
          sceneItemLink.textContent = `${statusIcon} Scene ${scene.number}: ${scene.name}`;
          sceneItemLink.addEventListener("click", async (e) => {
            e.preventDefault();
            await this.app.workspace.openLinkText(scene.path, "", false);
          });

          sceneItem.createEl("span", {
            text: ` - ${this.getSceneIcon(scene.type)} ${scene.type}`,
            cls: "scene-type"
          });
        }

        let isExpanded = false;
        toggleBtn.addEventListener("click", () => {
          isExpanded = !isExpanded;
          upcomingList.style.display = isExpanded ? "block" : "none";
          toggleBtn.textContent = isExpanded 
            ? `‚ñº Hide scenes` 
            : `‚ñ∂ Show ${scenes.length - 1} more scenes`;
        });
      }
    }

    // Party Stats
    await this.renderPartyStats(container);
  }

  async renderQuickReference(container: HTMLElement) {
    container.createEl("h3", { text: "üîñ Quick Reference" });

    // Recent NPCs
    const npcsSection = container.createEl("div", { cls: "quick-ref-section" });
    npcsSection.createEl("h4", { text: "üë• Recent NPCs" });
    await this.renderRecentNPCs(npcsSection);

    // Quick Actions - Compact single grid
    const actionsSection = container.createEl("div", { cls: "quick-ref-section" });
    actionsSection.createEl("h4", { text: "‚ö° Quick Actions" });
    
    // All actions in one compact grid
    const allActions = [
      { text: "üìù Session", cmd: "dnd-campaign-hub:create-session" },
      { text: "üé¨ Scene", cmd: "dnd-campaign-hub:create-scene" },
      { text: "‚öîÔ∏è Encounter", cmd: "dnd-campaign-hub:create-encounter" },
      { text: "üó∫Ô∏è Adventure", cmd: "dnd-campaign-hub:create-adventure" },
      { text: "üë§ NPC", cmd: "dnd-campaign-hub:create-npc" },
      { text: "üé≠ PC", cmd: "dnd-campaign-hub:create-pc" },
      { text: "üêâ Creature", cmd: "dnd-campaign-hub:create-creature" },
      { text: "üèõÔ∏è Faction", cmd: "dnd-campaign-hub:create-faction" },
      { text: "‚öîÔ∏è Item", cmd: "dnd-campaign-hub:create-item" },
      { text: "‚ú® Spell", cmd: "dnd-campaign-hub:create-spell" },
      { text: "ü™§ Trap", cmd: "dnd-campaign-hub:create-trap" }
    ];
    this.renderActionButtons(actionsSection, allActions);
  }

  renderActionButtons(container: HTMLElement, actions: Array<{text: string, cmd: string}>) {
    const buttonsWrapper = container.createEl("div", { cls: "action-buttons" });
    for (const action of actions) {
      const btn = buttonsWrapper.createEl("button", {
        text: action.text,
        cls: "quick-action-btn"
      });
      btn.addEventListener("click", () => {
        (this.app as any).commands?.executeCommandById(action.cmd);
      });
    }
  }

  async renderRecentNPCs(container: HTMLElement) {
    // Get NPCs from the campaign
    const npcsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/NPCs`);
    
    if (!(npcsFolder instanceof TFolder)) {
      container.createEl("p", { text: "No NPCs found" });
      return;
    }

    const npcFiles: TFile[] = [];
    for (const item of npcsFolder.children) {
      if (item instanceof TFile && item.extension === "md") {
        npcFiles.push(item);
      }
    }

    // Sort by modification time (most recent first)
    npcFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);

    // Show top 5
    const recentNPCs = npcFiles.slice(0, 5);

    if (recentNPCs.length === 0) {
      container.createEl("p", { text: "No NPCs yet" });
      return;
    }

    const npcList = container.createEl("div", { cls: "npc-list" });
    for (const npc of recentNPCs) {
      const npcItem = npcList.createEl("div", { cls: "npc-item" });
      const npcLink = npcItem.createEl("a", { href: npc.path });
      npcLink.textContent = `üë§ ${npc.basename}`;
      npcLink.addEventListener("click", async (e) => {
        e.preventDefault();
        await this.app.workspace.openLinkText(npc.path, "", false);
      });
    }
  }

  async renderPartyStats(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section collapsible" });
    const header = section.createEl("div", { cls: "section-header" });
    const toggle = header.createEl("span", { text: "‚ñ∂", cls: "toggle-icon" });
    header.createEl("span", { text: "üé≠ Party Overview" });
    
    const content = section.createEl("div", { cls: "section-content" });
    content.style.display = "none";

    // Get PCs from the campaign
    const pcsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/PCs`);
    
    if (!(pcsFolder instanceof TFolder)) {
      content.createEl("p", { text: "No PCs found", cls: "empty-msg" });
    } else {
      const pcFiles: TFile[] = [];
      for (const item of pcsFolder.children) {
        if (item instanceof TFile && item.extension === "md") {
          pcFiles.push(item);
        }
      }

      if (pcFiles.length === 0) {
        content.createEl("p", { text: "No PCs yet", cls: "empty-msg" });
      } else {
        // Collect PC stats
        const party: Array<{
          name: string;
          hp: number;
          hpMax: number;
          ac: number;
          path: string;
        }> = [];

        for (const pcFile of pcFiles) {
          const cache = this.app.metadataCache.getFileCache(pcFile);
          const fm = cache?.frontmatter;
          
          if (fm && fm.type === "player") {
            party.push({
              name: fm.name || pcFile.basename,
              hp: parseInt(fm.hp) || 0,
              hpMax: parseInt(fm.hp_max) || 0,
              ac: parseInt(fm.ac) || 10,
              path: pcFile.path
            });
          }
        }

        party.sort((a, b) => a.name.localeCompare(b.name));

        // Party grid
        const partyGrid = content.createEl("div", { cls: "party-grid" });
        
        for (const pc of party) {
          const pcCard = partyGrid.createEl("div", { cls: "party-card" });
          
          const pcLink = pcCard.createEl("a", { 
            href: pc.path,
            cls: "pc-name"
          });
          pcLink.textContent = pc.name;
          pcLink.addEventListener("click", async (e) => {
            e.preventDefault();
            await this.app.workspace.openLinkText(pc.path, "", false);
          });

          // HP bar
          const hpPercent = pc.hpMax > 0 ? (pc.hp / pc.hpMax) * 100 : 0;
          const hpBar = pcCard.createEl("div", { cls: "pc-hp-bar" });
          const hpFill = hpBar.createEl("div", { cls: "pc-hp-fill" });
          hpFill.style.width = `${hpPercent}%`;
          if (hpPercent < 25) hpFill.style.backgroundColor = "#cc0000";
          else if (hpPercent < 50) hpFill.style.backgroundColor = "#cc6600";
          
          pcCard.createEl("div", { 
            cls: "pc-stats",
            text: `‚ù§Ô∏è ${pc.hp}/${pc.hpMax} ‚Ä¢ AC ${pc.ac}`
          });
        }
      }
    }

    let isExpanded = false;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      content.style.display = isExpanded ? "block" : "none";
      toggle.textContent = isExpanded ? "‚ñº" : "‚ñ∂";
    });
  }

  async renderSessionNotes(container: HTMLElement) {
    container.createEl("h3", { text: "üìì Session Notes" });

    // Get recent sessions
    const sessionsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/Sessions`);
    const sessionFiles: TFile[] = [];

    if (sessionsFolder instanceof TFolder) {
      // Sessions in subfolder
      for (const item of sessionsFolder.children) {
        if (item instanceof TFile && item.extension === "md") {
          sessionFiles.push(item);
        }
      }
    } else {
      // Sessions at campaign root
      const campaignFolder = this.app.vault.getAbstractFileByPath(this.campaignPath);
      if (campaignFolder instanceof TFolder) {
        for (const item of campaignFolder.children) {
          if (item instanceof TFile && item.extension === "md") {
            const cache = this.app.metadataCache.getFileCache(item);
            if (cache?.frontmatter?.type === "session") {
              sessionFiles.push(item);
            }
          }
        }
      }
    }

    // Sort by session number (descending)
    sessionFiles.sort((a, b) => {
      const cacheA = this.app.metadataCache.getFileCache(a);
      const cacheB = this.app.metadataCache.getFileCache(b);
      
      const aNum = cacheA?.frontmatter?.sessionNum || this.extractSessionNumber(a.basename);
      const bNum = cacheB?.frontmatter?.sessionNum || this.extractSessionNumber(b.basename);
      
      return bNum - aNum;
    });

    const lastSession = sessionFiles[0];
    if (!lastSession) {
      container.createEl("p", { text: "No sessions yet" });
      return;
    }

    // Show last session summary
    const sessionCard = container.createEl("div", { cls: "session-card" });
    const sessionLink = sessionCard.createEl("a", { href: lastSession.path });
    sessionLink.textContent = `Last Session: ${lastSession.basename}`;
    sessionLink.addEventListener("click", async (e) => {
      e.preventDefault();
      await this.app.workspace.openLinkText(lastSession.path, "", false);
    });

    // Try to extract summary from last session
    try {
      const content = await this.app.vault.read(lastSession);
      const summaryMatch = content.match(/##\s*Summary\s*\n\n([\s\S]*?)(?=\n##|$)/);
      if (summaryMatch && summaryMatch[1]) {
        const summary = summaryMatch[1].trim().substring(0, 200);
        sessionCard.createEl("p", {
          text: summary + (summaryMatch[1].length > 200 ? "..." : ""),
          cls: "session-summary"
        });
      }
    } catch (error) {
      console.error("Error reading session file:", error);
    }
  }

  async getActiveAdventures(): Promise<Array<{
    path: string;
    name: string;
    status: string;
  }>> {
    const adventures: Array<{ path: string; name: string; status: string }> = [];
    const adventuresFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/Adventures`);

    if (!(adventuresFolder instanceof TFolder)) {
      return adventures;
    }

    for (const item of adventuresFolder.children) {
      if (item instanceof TFile && item.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(item);
        const status = cache?.frontmatter?.status || "planning";
        
        // Only show active adventures (not completed or on-hold)
        if (status === "active" || status === "in-progress" || status === "planning") {
          adventures.push({
            path: item.path,
            name: item.basename,
            status: status
          });
        }
      } else if (item instanceof TFolder) {
        // Check for adventure in folder structure
        const adventureFile = this.app.vault.getAbstractFileByPath(`${item.path}/${item.name}.md`);
        if (adventureFile instanceof TFile) {
          const cache = this.app.metadataCache.getFileCache(adventureFile);
          const status = cache?.frontmatter?.status || "planning";
          
          if (status === "active" || status === "in-progress" || status === "planning") {
            adventures.push({
              path: adventureFile.path,
              name: item.name,
              status: status
            });
          }
        }
      }
    }

    return adventures;
  }

  async getScenesForAdventure(adventurePath: string): Promise<Array<{
    path: string;
    number: number;
    name: string;
    type: string;
    duration: string;
    difficulty: string;
    status: string;
    goal: string;
  }>> {
    const scenes: Array<any> = [];
    const adventureFile = this.app.vault.getAbstractFileByPath(adventurePath);

    if (!(adventureFile instanceof TFile)) return scenes;

    const adventureFolder = adventureFile.parent;
    if (!adventureFolder) return scenes;

    // Check for flat structure
    const flatScenesFolder = this.app.vault.getAbstractFileByPath(
      `${adventureFolder.path}/${adventureFile.basename} - Scenes`
    );

    // Check for folder structure
    const folderScenesPath = `${adventureFolder.path}/${adventureFile.basename}`;
    const folderStructure = this.app.vault.getAbstractFileByPath(folderScenesPath);

    let sceneFolders: TFolder[] = [];

    if (flatScenesFolder instanceof TFolder) {
      sceneFolders.push(flatScenesFolder);
    } else if (folderStructure instanceof TFolder) {
      for (const child of folderStructure.children) {
        if (child instanceof TFolder && child.name.startsWith("Act ")) {
          sceneFolders.push(child);
        }
      }
      if (sceneFolders.length === 0) {
        sceneFolders.push(folderStructure);
      }
    } else {
      // Check if the adventure folder itself contains Act folders
      // (case where adventure file is inside a folder with the same name)
      for (const child of adventureFolder.children) {
        if (child instanceof TFolder && child.name.startsWith("Act ")) {
          sceneFolders.push(child);
        }
      }
      // If no Act folders, check the adventure folder itself for scenes
      if (sceneFolders.length === 0) {
        for (const child of adventureFolder.children) {
          if (child instanceof TFile && child.extension === "md" && 
              child.path !== adventurePath && 
              child.basename.match(/^Scene\s+\d+/)) {
            sceneFolders.push(adventureFolder);
            break;
          }
        }
      }
    }

    // Scan all scene folders
    for (const folder of sceneFolders) {
      for (const item of folder.children) {
        if (item instanceof TFile && item.extension === "md") {
          const match = item.basename.match(/^Scene\s+(\d+)\s+-\s+(.+)$/);
          if (match && match[1] && match[2]) {
            const cache = this.app.metadataCache.getFileCache(item);
            const frontmatter = cache?.frontmatter;

            scenes.push({
              path: item.path,
              number: parseInt(match[1]),
              name: match[2],
              type: frontmatter?.scene_type || "exploration",
              duration: frontmatter?.duration || "?",
              difficulty: frontmatter?.difficulty || "medium",
              status: frontmatter?.status || "not-started",
              goal: ""  // We'll extract this if needed
            });
          }
        }
      }
    }

    // Sort by scene number
    scenes.sort((a, b) => a.number - b.number);
    return scenes;
  }

  getSceneIcon(type: string): string {
    const icons: Record<string, string> = {
      social: "üó£Ô∏è",
      combat: "‚öîÔ∏è",
      exploration: "üîç",
      puzzle: "üß©",
      montage: "üé¨"
    };
    return icons[type] || "üìù";
  }

  async renderLastSessionRecap(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section collapsible" });
    const header = section.createEl("div", { cls: "section-header" });
    const toggle = header.createEl("span", { text: "‚ñ∂", cls: "toggle-icon" });
    header.createEl("span", { text: "üìñ Last Session" });
    
    const content = section.createEl("div", { cls: "section-content" });
    content.style.display = "none";

    // Get recent sessions
    const sessionsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/Sessions`);
    const sessionFiles: TFile[] = [];

    if (sessionsFolder instanceof TFolder) {
      for (const item of sessionsFolder.children) {
        if (item instanceof TFile && item.extension === "md") {
          sessionFiles.push(item);
        }
      }
    } else {
      const campaignFolder = this.app.vault.getAbstractFileByPath(this.campaignPath);
      if (campaignFolder instanceof TFolder) {
        for (const item of campaignFolder.children) {
          if (item instanceof TFile && item.extension === "md") {
            const cache = this.app.metadataCache.getFileCache(item);
            if (cache?.frontmatter?.type === "session") {
              sessionFiles.push(item);
            }
          }
        }
      }
    }

    if (sessionFiles.length === 0) {
      content.createEl("p", { 
        text: "No previous sessions yet.",
        cls: "empty-msg"
      });
    } else {
      // Sort by session number (descending)
      sessionFiles.sort((a, b) => {
        const cacheA = this.app.metadataCache.getFileCache(a);
        const cacheB = this.app.metadataCache.getFileCache(b);
        
        const aNum = cacheA?.frontmatter?.sessionNum || this.extractSessionNumber(a.basename);
        const bNum = cacheB?.frontmatter?.sessionNum || this.extractSessionNumber(b.basename);
        
        return bNum - aNum;
      });

      const lastSession = sessionFiles[0];
      if (lastSession) {
        const sessionLink = content.createEl("a", { 
          href: lastSession.path,
          cls: "session-link"
        });
        sessionLink.textContent = lastSession.basename;
        sessionLink.addEventListener("click", async (e) => {
          e.preventDefault();
          await this.app.workspace.openLinkText(lastSession.path, "", false);
        });

        // Try to extract summary
        try {
          const fileContent = await this.app.vault.read(lastSession);
          const summaryMatch = fileContent.match(/##\s*(?:Summary|Highlights?)\s*\n([\s\S]*?)(?=\n##|$)/i);
          if (summaryMatch && summaryMatch[1]) {
            const summary = summaryMatch[1].trim().substring(0, 150);
            content.createEl("p", {
              text: summary + (summaryMatch[1].length > 150 ? "..." : ""),
              cls: "session-summary"
            });
          }
        } catch (error) {
          // Ignore read errors
        }
      }
    }

    let isExpanded = false;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      content.style.display = isExpanded ? "block" : "none";
      toggle.textContent = isExpanded ? "‚ñº" : "‚ñ∂";
    });
  }

  extractSessionNumber(filename: string): number {
    // Try "Session X" format
    let match = filename.match(/Session\s+(\d+)/i);
    if (match && match[1]) return parseInt(match[1]);
    
    // Try "001_20250521" format
    match = filename.match(/^(\d{3})_\d{8}$/);
    if (match && match[1]) return parseInt(match[1]);
    
    return 0;
  }

  async onClose() {
    // Clear auto-refresh interval
    if (this.refreshInterval !== null) {
      window.clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }

    // Unregister workspace event listener
    if (this.activeLeafChangeRef) {
      this.app.workspace.offref(this.activeLeafChangeRef);
      this.activeLeafChangeRef = null;
    }
  }
}

/**
 * Timer Name Modal - Prompt for timer name
 */
class TimerNameModal extends Modal {
  resolve: (value: string | null) => void;
  defaultName: string;

  constructor(app: App, defaultName: string, resolve: (value: string | null) => void) {
    super(app);
    this.defaultName = defaultName;
    this.resolve = resolve;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "Add Timer" });

    const input = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter timer name...",
    });
    input.value = this.defaultName;

    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.resolve(null);
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Add",
      cls: "mod-cta",
    });
    createButton.addEventListener("click", () => {
      const name = input.value.trim();
      if (name) {
        this.close();
        this.resolve(name);
      }
    });

    input.focus();
    input.select();
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        createButton.click();
      }
    });
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * Session Run Dashboard - Active session management for GMs
 */
class SessionRunDashboardView extends ItemView {
  plugin: DndCampaignHubPlugin;
  campaignPath: string;
  currentSessionFile: TFile | null = null;
  readOnlyMode: boolean = true;
  timers: Array<{id: string; name: string; startTime: number; paused: boolean; pausedAt: number; elapsed: number}> = [];
  diceHistory: Array<{roll: string; result: number; timestamp: number}> = [];
  quickNotesContent: string = "";
  autoSaveInterval: number | null = null;
  timerUpdateInterval: number | null = null;
  musicCleanup: (() => void) | null = null;

  constructor(leaf: WorkspaceLeaf, plugin: DndCampaignHubPlugin) {
    super(leaf);
    this.plugin = plugin;
    this.campaignPath = plugin.settings.currentCampaign;
  }

  getViewType(): string {
    return SESSION_RUN_VIEW_TYPE;
  }

  getDisplayText(): string {
    return "Session Running";
  }

  getIcon(): string {
    return "play-circle";
  }

  setCampaign(campaignPath: string) {
    this.campaignPath = campaignPath;
    this.render();
  }

  async onOpen() {
    // Find current session file
    await this.detectCurrentSession();
    
    await this.render();
    
    // Enable read-only mode after a short delay to ensure workspace is ready
    setTimeout(() => {
      if (this.readOnlyMode) {
        this.enableReadOnlyMode();
      }
    }, 300);

    // Start auto-save for quick notes
    this.startAutoSave();
  }

  async detectCurrentSession() {
    // First try Sessions subfolder
    const sessionsFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/Sessions`);
    const sessionFiles: TFile[] = [];

    if (sessionsFolder instanceof TFolder) {
      // Sessions are in a subfolder
      for (const item of sessionsFolder.children) {
        if (item instanceof TFile && item.extension === "md") {
          sessionFiles.push(item);
        }
      }
    } else {
      // Sessions are at campaign root level (same level as world.md)
      const campaignFolder = this.app.vault.getAbstractFileByPath(this.campaignPath);
      if (campaignFolder instanceof TFolder) {
        for (const item of campaignFolder.children) {
          if (item instanceof TFile && item.extension === "md") {
            // Check frontmatter for type: session
            const cache = this.app.metadataCache.getFileCache(item);
            if (cache?.frontmatter?.type === "session") {
              sessionFiles.push(item);
            } else if (item.basename.match(/^Session\s+\d+/i) || 
                       item.basename.match(/^\d{3}_\d{8}$/)) {
              // Fallback to filename patterns: "Session X" or "001_20250521"
              sessionFiles.push(item);
            }
          }
        }
      }
    }

    // Get the most recent session
    sessionFiles.sort((a, b) => {
      // Try to get session number from frontmatter first
      const cacheA = this.app.metadataCache.getFileCache(a);
      const cacheB = this.app.metadataCache.getFileCache(b);
      
      const aNum = cacheA?.frontmatter?.sessionNum || this.extractSessionNumber(a.basename);
      const bNum = cacheB?.frontmatter?.sessionNum || this.extractSessionNumber(b.basename);
      
      return bNum - aNum;
    });

    this.currentSessionFile = sessionFiles[0] || null;
  }

  extractSessionNumber(filename: string): number {
    // Try "Session X" format
    let match = filename.match(/Session\s+(\d+)/i);
    if (match && match[1]) return parseInt(match[1]);
    
    // Try "001_20250521" format
    match = filename.match(/^(\d{3})_\d{8}$/);
    if (match && match[1]) return parseInt(match[1]);
    
    return 0;
  }

  enableReadOnlyMode() {
    this.readOnlyMode = true;
    // Set all markdown views to read mode
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        const view = leaf.view as any;
        if (view.getMode && view.getMode() === "source") {
          const state = view.getState();
          view.setState({ ...state, mode: "preview" }, {});
        }
      }
    });
  }

  disableReadOnlyMode() {
    this.readOnlyMode = false;
    // User can manually switch views back to edit mode
  }

  startAutoSave() {
    if (this.autoSaveInterval) return;
    
    // Auto-save every 30 seconds
    this.autoSaveInterval = window.setInterval(() => {
      this.saveQuickNotes();
    }, 30000);
  }

  async saveQuickNotes() {
    if (!this.currentSessionFile || !this.quickNotesContent.trim()) return;

    try {
      const content = await this.app.vault.read(this.currentSessionFile);
      
      // Check if Quick Notes section exists
      const quickNotesMarker = "## Quick Notes (During Session)";
      
      if (content.includes(quickNotesMarker)) {
        // Update existing section
        const regex = /## Quick Notes \(During Session\)\s*\n([\s\S]*?)(?=\n##|$)/;
        const newContent = content.replace(
          regex,
          `## Quick Notes (During Session)\n\n${this.quickNotesContent}\n`
        );
        await this.app.vault.modify(this.currentSessionFile, newContent);
      } else {
        // Add new section at the end
        const newContent = content + `\n\n${quickNotesMarker}\n\n${this.quickNotesContent}\n`;
        await this.app.vault.modify(this.currentSessionFile, newContent);
      }
    } catch (error) {
      console.error("Error saving quick notes:", error);
    }
  }

  addTimer(name: string) {
    const timer = {
      id: `timer-${Date.now()}`,
      name: name,
      startTime: Date.now(),
      paused: false,
      pausedAt: 0,
      elapsed: 0
    };
    this.timers.push(timer);
    this.render();
  }

  removeTimer(id: string) {
    this.timers = this.timers.filter(t => t.id !== id);
    this.render();
  }

  toggleTimer(id: string) {
    const timer = this.timers.find(t => t.id === id);
    if (!timer) return;

    if (timer.paused) {
      // Resume
      timer.startTime = Date.now() - timer.elapsed;
      timer.paused = false;
    } else {
      // Pause
      timer.elapsed = Date.now() - timer.startTime;
      timer.pausedAt = Date.now();
      timer.paused = true;
    }
    this.render();
  }

  getTimerDisplay(timer: {startTime: number; paused: boolean; elapsed: number}): string {
    const totalMs = timer.paused ? timer.elapsed : Date.now() - timer.startTime;
    const totalSeconds = Math.floor(totalMs / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  rollDice(diceType: string) {
    // Built-in dice roller
    const sides = parseInt(diceType.substring(1)); // Remove 'd' prefix (e.g., "d20" -> 20)
    const result = Math.floor(Math.random() * sides) + 1;
    
    this.diceHistory.unshift({
      roll: diceType,
      result: result,
      timestamp: Date.now()
    });

    // Keep only last 20 rolls
    if (this.diceHistory.length > 20) {
      this.diceHistory = this.diceHistory.slice(0, 20);
    }

    this.render();
  }

  async render() {
    const container = this.containerEl.children[1];
    if (!container) return;
    
    container.empty();
    container.addClass("session-run-dashboard");
    container.addClass("session-run-compact");

    // Header with session info
    const header = container.createEl("div", { cls: "run-dashboard-header-compact" });
    const sessionName = this.currentSessionFile?.basename || "No Active Session";
    header.createEl("h3", { text: `üéÆ Session Control` });
    header.createEl("p", { 
      text: sessionName,
      cls: "session-name-compact"
    });

    // Read-only mode toggle
    const modeToggle = header.createEl("div", { cls: "mode-toggle-compact" });
    const toggleBtn = modeToggle.createEl("button", {
      text: this.readOnlyMode ? "üîí Read-Only" : "üîì Editable",
      cls: this.readOnlyMode ? "mod-warning" : ""
    });
    toggleBtn.addEventListener("click", () => {
      if (this.readOnlyMode) {
        this.disableReadOnlyMode();
      } else {
        this.enableReadOnlyMode();
      }
      this.render();
    });

    // Compact single-column layout for control panel
    const controlPanel = container.createEl("div", { cls: "run-dashboard-controls" });

    // Timers section
    await this.renderTimers(controlPanel);
    
    // Dice roller section
    this.renderDiceRoller(controlPanel);

    // Music player section
    if (this.musicCleanup) {
      this.musicCleanup();
      this.musicCleanup = null;
    }
    this.musicCleanup = renderMusicPlayer(
      controlPanel,
      this.app,
      this.plugin.musicPlayer,
      this.plugin.settings.musicSettings,
      () => {
        new MusicSettingsModal(this.app, this.plugin.settings.musicSettings, async (updated: MusicSettings) => {
          this.plugin.settings.musicSettings = updated;
          this.plugin.musicPlayer.reloadSettings(updated);
          await this.plugin.saveSettings();
          new Notice("Music settings saved");
          this.render();
        }).open();
      }
    );

    // Soundboard section
    renderSoundboard(controlPanel, this.app, this.plugin.musicPlayer, this.plugin.settings.musicSettings);

    // Scene music detection ‚Äì scan active scene for dnd-music codeblock
    await this.renderSceneMusicDetector(controlPanel);
    
    // Quick notes section
    await this.renderQuickNotes(controlPanel);
    
    // SRD Quick Search section
    await this.renderSRDQuickSearch(controlPanel);
    
    // Quick actions section
    await this.renderQuickActions(controlPanel);

    // Setup Layout button
    const layoutSection = container.createEl("div", { cls: "dashboard-section" });
    const setupBtn = layoutSection.createEl("button", {
      text: "üìê Setup Session Layout",
      cls: "mod-cta"
    });
    setupBtn.style.width = "100%";
    setupBtn.addEventListener("click", () => {
      console.log("üîò Setup Session Layout button clicked");
      this.setupSessionLayout();
    });

    // Update timers display every second
    if (this.timerUpdateInterval) {
      window.clearInterval(this.timerUpdateInterval);
    }
    
    this.timerUpdateInterval = window.setInterval(() => {
      const timerDisplays = container.querySelectorAll('.timer-display');
      timerDisplays.forEach((display, index) => {
        if (this.timers[index]) {
          display.textContent = this.getTimerDisplay(this.timers[index]);
        }
      });
    }, 1000);
  }

  async setupSessionLayout() {
    console.log("üéØ setupSessionLayout called");
    
    // Get or create main workspace leaf
    let mainLeaf = this.app.workspace.getLeaf(false);
    
    if (!mainLeaf) {
      console.error("‚ùå No workspace leaf available");
      new Notice("Could not set up layout - no workspace available");
      return;
    }

    console.log("‚úÖ Got main leaf");

    // Get active adventure and scene
    const adventures = await this.getActiveAdventures();
    console.log(`üìö Found ${adventures.length} adventures`);
    const adventure = adventures.length > 0 ? adventures[0] : null;
    
    if (adventure) {
      console.log(`üìñ Adventure found: ${adventure.name}`);
      const scenes = await this.getScenesForAdventure(adventure.path);
      console.log(`üé¨ Found ${scenes.length} scenes`);
      const currentScene = scenes.find(s => s.status === "in-progress") || 
                          scenes.find(s => s.status === "not-started");
      
      if (currentScene) {
        console.log(`üé¨ Opening scene: ${currentScene.name}`);
        // Open scene in main pane (largest view)
        const sceneFile = this.app.vault.getAbstractFileByPath(currentScene.path);
        if (sceneFile instanceof TFile) {
          await mainLeaf.openFile(sceneFile);
          // Collapse properties for scene
          await this.collapseProperties(mainLeaf);
        }
        
        // Split right for adventure
        const adventureLeaf = this.app.workspace.getLeaf('split', 'vertical');
        const adventureFile = this.app.vault.getAbstractFileByPath(adventure.path);
        if (adventureFile instanceof TFile) {
          await adventureLeaf.openFile(adventureFile);
          // Collapse properties for adventure
          await this.collapseProperties(adventureLeaf);
        }
        
        // Split bottom of adventure pane for session notes
        if (this.currentSessionFile) {
          const sessionLeaf = this.app.workspace.getLeaf('split', 'horizontal');
          await sessionLeaf.openFile(this.currentSessionFile);
          // Collapse properties for session
          await this.collapseProperties(sessionLeaf);
        }
      } else {
        // No scene available, open adventure in main
        const adventureFile = this.app.vault.getAbstractFileByPath(adventure.path);
        if (adventureFile instanceof TFile) {
          await mainLeaf.openFile(adventureFile);
          await this.collapseProperties(mainLeaf);
        }
        
        // Open session in split if available
        if (this.currentSessionFile) {
          const sessionLeaf = this.app.workspace.getLeaf('split', 'vertical');
          await sessionLeaf.openFile(this.currentSessionFile);
          await this.collapseProperties(sessionLeaf);
        }
      }
    } else if (this.currentSessionFile) {
      // No adventure, just open session
      await mainLeaf.openFile(this.currentSessionFile);
      await this.collapseProperties(mainLeaf);
    }

    // Try to open Initiative Tracker if available
    const initiativePlugin = (this.app as any).plugins?.getPlugin("initiative-tracker");
    if (initiativePlugin) {
      // Give a moment for the layout to settle, then open tracker
      setTimeout(() => {
        (this.app as any).commands?.executeCommandById("initiative-tracker:open-tracker");
      }, 500);
    }

    // Enable read-only mode for the opened files
    setTimeout(() => {
      if (this.readOnlyMode) {
        this.enableReadOnlyMode();
      }
    }, 800);

    new Notice("Session layout configured!");
  }

  /**
   * Collapse the properties (frontmatter) panel in a leaf
   */
  async collapseProperties(leaf: WorkspaceLeaf) {
    // Wait for the file to fully load and metadata editor to be ready
    await new Promise(resolve => setTimeout(resolve, 150));
    
    const view = leaf.view;
    if (view.getViewType() === "markdown") {
      try {
        // Access the metadata editor (properties panel) directly
        const metadataEditor = (view as any).metadataEditor;
        
        if (metadataEditor) {
          // Method 1: Try to collapse via the toggle method
          if (typeof metadataEditor.toggle === 'function') {
            // Close it if it's open
            if (!metadataEditor.collapsed) {
              metadataEditor.toggle();
            }
          }
          
          // Method 2: Set collapsed state directly
          if ('collapsed' in metadataEditor) {
            metadataEditor.collapsed = true;
          }
          
          // Method 3: Hide the container element
          if (metadataEditor.containerEl) {
            metadataEditor.containerEl.style.display = 'none';
          }
        }
        
        // Also try setting ephemeral state as fallback
        leaf.setEphemeralState({ showProperties: false });
      } catch (error) {
        console.error("Error collapsing properties:", error);
      }
    }
  }

  async renderTimers(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "‚è±Ô∏è Timers" });

    if (this.timers.length === 0) {
      section.createEl("p", { text: "No active timers", cls: "empty-message" });
    }

    for (const timer of this.timers) {
      const timerCard = section.createEl("div", { cls: "timer-card" });
      
      const timerHeader = timerCard.createEl("div", { cls: "timer-header" });
      timerHeader.createEl("strong", { text: timer.name });
      
      const timerDisplay = timerCard.createEl("div", { 
        cls: "timer-display",
        text: this.getTimerDisplay(timer)
      });

      const timerControls = timerCard.createEl("div", { cls: "timer-controls" });
      
      const pauseBtn = timerControls.createEl("button", {
        text: timer.paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause"
      });
      pauseBtn.addEventListener("click", () => this.toggleTimer(timer.id));

      const removeBtn = timerControls.createEl("button", {
        text: "üóëÔ∏è Remove",
        cls: "mod-warning"
      });
      removeBtn.addEventListener("click", () => this.removeTimer(timer.id));
    }

    // Add timer button
    const addTimerBtn = section.createEl("button", {
      text: "+ Add Timer",
      cls: "mod-cta"
    });
    addTimerBtn.addEventListener("click", (e) => {
      e.preventDefault();
      console.log("Add timer button clicked");
      
      // Use modal instead of prompt (prompt() not supported in Electron)
      new Promise<string | null>((resolve) => {
        new TimerNameModal(this.app, "Session Timer", resolve).open();
      }).then((name) => {
        console.log("Timer name entered:", name);
        if (name) {
          this.addTimer(name);
        }
      });
    });
  }

  renderDiceRoller(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "üé≤ Dice Roller" });

    const diceButtons = section.createEl("div", { cls: "dice-buttons" });
    const commonDice = ["d4", "d6", "d8", "d10", "d12", "d20", "d100"];
    
    for (const dice of commonDice) {
      const btn = diceButtons.createEl("button", {
        text: dice,
        cls: "dice-button"
      });
      btn.addEventListener("click", () => this.rollDice(dice));
    }

    // Dice history
    if (this.diceHistory.length > 0) {
      const historyHeader = section.createEl("div", { cls: "dice-history-header" });
      historyHeader.createEl("h4", { text: "History" });
      const clearBtn = historyHeader.createEl("button", {
        text: "üóëÔ∏è Clear",
        cls: "dice-clear-button"
      });
      clearBtn.addEventListener("click", () => {
        this.diceHistory = [];
        this.render();
      });
      
      const history = section.createEl("div", { cls: "dice-history" });
      
      for (const roll of this.diceHistory.slice(0, 10)) {
        const rollItem = history.createEl("div", { cls: "dice-history-item" });
        rollItem.createEl("span", { 
          text: `${roll.roll}: `,
          cls: "dice-type"
        });
        rollItem.createEl("span", { 
          text: roll.result.toString(),
          cls: "dice-result"
        });
      }
    }
  }

  async renderQuickNotes(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "üìù Quick Notes" });
    
    const textarea = section.createEl("textarea", {
      cls: "quick-notes-textarea",
      placeholder: "Jot down quick notes... (Auto-saves every 30s)"
    });
    textarea.value = this.quickNotesContent;
    textarea.addEventListener("input", (e) => {
      this.quickNotesContent = (e.target as HTMLTextAreaElement).value;
    });

    const saveBtn = section.createEl("button", {
      text: "üíæ Save Now",
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", () => {
      this.saveQuickNotes();
      new Notice("Quick notes saved to session!");
    });
  }

  /**
   * Scan all open markdown files for a dnd-music codeblock and show
   * a compact Scene Music card in the dashboard with a Load & Play button.
   */
  async renderSceneMusicDetector(container: HTMLElement) {
    // Look through all open leaves for a scene note containing a dnd-music block
    const configs: Array<{ config: SceneMusicConfig; sceneName: string }> = [];

    for (const leaf of this.app.workspace.getLeavesOfType('markdown')) {
      const file = (leaf.view as any).file as TFile | undefined;
      if (!file) continue;

      const content = await this.app.vault.read(file);
      const match = content.match(/```dnd-music\s*\n([\s\S]*?)```/);
      if (match && match[1]) {
        try {
          const config: SceneMusicConfig = JSON.parse(match[1].trim());
          configs.push({ config, sceneName: file.basename });
        } catch { /* ignore invalid JSON */ }
      }
    }

    if (configs.length === 0) return;

    const section = container.createEl('div', { cls: 'dashboard-section scene-music-detector' });
    section.createEl('h3', { text: 'üé¨ Scene Music' });

    for (const { config, sceneName } of configs) {
      const card = section.createEl('div', { cls: 'scene-music-detect-card' });

      card.createEl('strong', { text: sceneName, cls: 'scene-music-detect-name' });

      const details = card.createEl('div', { cls: 'scene-music-detect-details' });

      // Primary info
      if (config.primaryPlaylistId) {
        const pl = this.plugin.settings.musicSettings.playlists.find(
          (p: any) => p.id === config.primaryPlaylistId
        );
        details.createEl('span', {
          text: `üéµ ${pl ? pl.name : '(unknown)'}`,
          cls: 'scene-music-detect-tag',
        });
      }

      // Ambient info
      if (config.ambientPlaylistId) {
        const pl = this.plugin.settings.musicSettings.playlists.find(
          (p: any) => p.id === config.ambientPlaylistId
        );
        details.createEl('span', {
          text: `üåä ${pl ? pl.name : '(unknown)'}`,
          cls: 'scene-music-detect-tag',
        });
      }

      let isLoaded = false;
      const playBtn = card.createEl('button', {
        text: '‚ñ∂ Load & Play',
        cls: 'mod-cta scene-music-detect-play',
      });
      playBtn.addEventListener('click', () => {
        if (!isLoaded) {
          this.plugin.musicPlayer.loadSceneMusic(config, config.autoPlay);
          isLoaded = true;
          playBtn.textContent = '‚èπ Stop';
          playBtn.classList.remove('mod-cta');
          playBtn.classList.add('mod-warning');
          new Notice(`üéµ Loaded scene music for "${sceneName}"`);
        } else {
          this.plugin.musicPlayer.stopAll();
          isLoaded = false;
          playBtn.textContent = '‚ñ∂ Load & Play';
          playBtn.classList.add('mod-cta');
          playBtn.classList.remove('mod-warning');
        }
      });
    }
  }

  async renderSRDQuickSearch(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "üîç SRD Quick Search" });
    
    // Search input
    const searchContainer = section.createEl("div", { cls: "srd-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search spells, equipment, classes...",
      cls: "srd-search-input"
    });

    // Results container
    const resultsContainer = section.createEl("div", { cls: "srd-search-results" });
    resultsContainer.style.display = "none";

    let searchTimeout: number | null = null;

    searchInput.addEventListener("input", async (e) => {
      const query = (e.target as HTMLInputElement).value.trim().toLowerCase();
      
      // Clear previous timeout
      if (searchTimeout) {
        window.clearTimeout(searchTimeout);
      }

      if (query.length < 2) {
        resultsContainer.style.display = "none";
        resultsContainer.empty();
        return;
      }

      // Debounce search
      searchTimeout = window.setTimeout(async () => {
        resultsContainer.empty();
        resultsContainer.style.display = "block";
        
        const loading = resultsContainer.createEl("div", {
          text: "Searching...",
          cls: "srd-search-loading"
        });

        try {
          const results = await this.searchSRDData(query);
          
          loading.remove();

          if (results.length === 0) {
            resultsContainer.createEl("div", {
              text: "No results found",
              cls: "srd-search-empty"
            });
            return;
          }

          // Show max 10 results
          const displayResults = results.slice(0, 10);
          
          for (const result of displayResults) {
            const resultCard = resultsContainer.createEl("div", { cls: "srd-search-result-card" });
            
            // Type badge
            const header = resultCard.createEl("div", { cls: "srd-result-header" });
            header.createEl("span", {
              text: result.type,
              cls: "srd-result-type"
            });
            
            // Name (as link)
            const nameLink = header.createEl("a", {
              text: result.name,
              cls: "srd-result-name"
            });
            nameLink.addEventListener("click", async (e) => {
              e.preventDefault();
              await this.app.workspace.openLinkText(result.path, "", true);
            });

            // Preview content
            if (result.preview) {
              resultCard.createEl("div", {
                text: result.preview,
                cls: "srd-result-preview"
              });
            }
          }

          if (results.length > 10) {
            resultsContainer.createEl("div", {
              text: `...and ${results.length - 10} more results`,
              cls: "srd-search-more"
            });
          }
        } catch (error) {
          loading.remove();
          resultsContainer.createEl("div", {
            text: `Search error: ${error instanceof Error ? error.message : String(error)}`,
            cls: "srd-search-error"
          });
        }
      }, 300);
    });

    // Clear search on focus out after a delay
    searchInput.addEventListener("blur", () => {
      setTimeout(() => {
        // Only hide if we're not clicking on a result link
        const activeElement = document.activeElement;
        if (activeElement?.tagName !== "A" || !activeElement.classList.contains("srd-result-name")) {
          resultsContainer.style.display = "none";
        }
      }, 200);
    });

    searchInput.addEventListener("focus", () => {
      if (searchInput.value.trim().length >= 2) {
        resultsContainer.style.display = "block";
      }
    });
  }

  async searchSRDData(query: string): Promise<Array<{type: string; name: string; path: string; preview: string}>> {
    const results: Array<{type: string; name: string; path: string; preview: string; score: number}> = [];
    
    // Define SRD folders to search
    const srdFolders = [
      { path: "z_Spells", type: "Spell" },
      { path: "z_Equipment", type: "Equipment" },
      { path: "z_Classes", type: "Class" },
      { path: "z_Races", type: "Race" },
      { path: "z_Conditions", type: "Condition" },
      { path: "z_Features", type: "Feature" },
      { path: "z_Traits", type: "Trait" },
      { path: "z_AbilityScores", type: "Ability" },
      { path: "z_Skills", type: "Skill" },
      { path: "z_Languages", type: "Language" },
      { path: "z_DamageTypes", type: "Damage Type" },
      { path: "z_MagicSchools", type: "Magic School" },
      { path: "z_Proficiencies", type: "Proficiency" },
      { path: "z_Subclasses", type: "Subclass" },
      { path: "z_Subraces", type: "Subrace" },
      { path: "z_WeaponProperties", type: "Weapon Property" }
    ];

    for (const folder of srdFolders) {
      const srdFolder = this.app.vault.getAbstractFileByPath(folder.path);
      
      if (!(srdFolder instanceof TFolder)) continue;

      for (const file of srdFolder.children) {
        if (!(file instanceof TFile) || file.extension !== "md") continue;

        const fileName = file.basename.toLowerCase();
        
        // Calculate match score
        let score = 0;
        if (fileName === query) {
          score = 100; // Exact match
        } else if (fileName.startsWith(query)) {
          score = 50; // Starts with query
        } else if (fileName.includes(query)) {
          score = 25; // Contains query
        }

        if (score > 0) {
          try {
            const content = await this.app.vault.read(file);
            
            // Extract preview from content (first non-frontmatter paragraph)
            let preview = "";
            const lines = content.split("\n");
            let inFrontmatter = false;
            let foundContent = false;
            
            for (const line of lines) {
              if (line.trim() === "---") {
                if (!foundContent) {
                  inFrontmatter = !inFrontmatter;
                }
                continue;
              }
              
              if (!inFrontmatter && line.trim() && !line.startsWith("#")) {
                preview = line.trim();
                if (preview.length > 100) {
                  preview = preview.substring(0, 100) + "...";
                }
                break;
              }
            }

            results.push({
              type: folder.type,
              name: file.basename,
              path: file.path,
              preview: preview,
              score: score
            });
          } catch (error) {
            console.error(`Error reading file ${file.path}:`, error);
          }
        }
      }
    }

    // Sort by score (highest first) and then alphabetically
    results.sort((a, b) => {
      if (b.score !== a.score) {
        return b.score - a.score;
      }
      return a.name.localeCompare(b.name);
    });

    return results;
  }

  async renderQuickActions(container: HTMLElement) {
    const section = container.createEl("div", { cls: "dashboard-section" });
    section.createEl("h3", { text: "‚ö° Quick Actions" });
    
    const actions = section.createEl("div", { cls: "quick-actions-compact" });

    // Initiative Tracker
    const initiativeBtn = actions.createEl("button", {
      text: "‚öîÔ∏è Open Initiative Tracker",
      cls: "quick-action-button"
    });
    initiativeBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      
      const initiativePlugin = (this.app as any).plugins?.getPlugin("initiative-tracker");
      
      if (!initiativePlugin) {
        new Notice("Initiative Tracker plugin not installed or enabled");
        return;
      }
      
      // Try method 1: Look for existing Initiative Tracker view and reveal it
      const existingLeaves = this.app.workspace.getLeavesOfType("initiative-tracker-view");
      if (existingLeaves.length > 0 && existingLeaves[0]) {
        this.app.workspace.revealLeaf(existingLeaves[0]);
        new Notice("Initiative Tracker opened");
        return;
      }
      
      // Try method 2: Execute the command to open the tracker
      try {
        const commands = (this.app as any).commands;
        if (commands) {
          // Try different possible command IDs
          const commandIds = [
            "initiative-tracker:open-tracker",
            "initiative-tracker:toggle-encounter",
            "obsidian-initiative-tracker:open-tracker"
          ];
          
          for (const cmdId of commandIds) {
            const executed = commands.executeCommandById(cmdId);
            if (executed) {
              new Notice("Initiative Tracker opened");
              return;
            }
          }
        }
      } catch (error) {
        console.error("Error executing command:", error);
      }
      
      // Try method 3: Create a new leaf in the right sidebar with the tracker view
      try {
        const leaf = this.app.workspace.getRightLeaf(false);
        if (leaf) {
          await leaf.setViewState({
            type: "initiative-tracker-view",
            active: true
          });
          this.app.workspace.revealLeaf(leaf);
          new Notice("Initiative Tracker opened");
          return;
        }
      } catch (error) {
        console.error("Error creating tracker view:", error);
      }
      
      new Notice("Could not open Initiative Tracker. Try opening it manually from the command palette.");
    });

    // Create Encounter
    const encounterBtn = actions.createEl("button", {
      text: "‚öîÔ∏è Create Encounter",
      cls: "quick-action-button"
    });
    encounterBtn.addEventListener("click", () => {
      (this.app as any).commands?.executeCommandById("dnd-campaign-hub:create-encounter");
    });

    // Open Session File
    if (this.currentSessionFile) {
      const sessionBtn = actions.createEl("button", {
        text: "üìÑ Open Session Note",
        cls: "quick-action-button"
      });
      sessionBtn.addEventListener("click", async () => {
        if (this.currentSessionFile) {
          await this.app.workspace.openLinkText(this.currentSessionFile.path, "", false);
        }
      });
    }
  }

  async getActiveAdventures() {
    const adventures: Array<{path: string; name: string; status: string}> = [];
    const adventuresFolder = this.app.vault.getAbstractFileByPath(`${this.campaignPath}/Adventures`);

    if (!(adventuresFolder instanceof TFolder)) {
      return adventures;
    }

    for (const item of adventuresFolder.children) {
      if (item instanceof TFile && item.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(item);
        const status = cache?.frontmatter?.status || "planning";
        
        // Show active, in-progress, and planning adventures (not completed or on-hold)
        if (status === "active" || status === "in-progress" || status === "planning") {
          adventures.push({
            path: item.path,
            name: item.basename,
            status: status
          });
        }
      } else if (item instanceof TFolder) {
        // Check for adventure in folder structure
        const adventureFile = this.app.vault.getAbstractFileByPath(`${item.path}/${item.name}.md`);
        if (adventureFile instanceof TFile) {
          const cache = this.app.metadataCache.getFileCache(adventureFile);
          const status = cache?.frontmatter?.status || "planning";
          
          if (status === "active" || status === "in-progress" || status === "planning") {
            adventures.push({
              path: adventureFile.path,
              name: item.name,
              status: status
            });
          }
        }
      }
    }

    return adventures;
  }

  async getScenesForAdventure(adventurePath: string) {
    const scenes: Array<any> = [];
    const adventureFile = this.app.vault.getAbstractFileByPath(adventurePath);

    if (!(adventureFile instanceof TFile)) return scenes;

    const adventureFolder = adventureFile.parent;
    if (!adventureFolder) return scenes;

    const flatScenesFolder = this.app.vault.getAbstractFileByPath(
      `${adventureFolder.path}/${adventureFile.basename} - Scenes`
    );

    const folderScenesPath = `${adventureFolder.path}/${adventureFile.basename}`;
    const folderStructure = this.app.vault.getAbstractFileByPath(folderScenesPath);

    let sceneFolders: TFolder[] = [];

    if (flatScenesFolder instanceof TFolder) {
      sceneFolders.push(flatScenesFolder);
    } else if (folderStructure instanceof TFolder) {
      for (const child of folderStructure.children) {
        if (child instanceof TFolder && child.name.startsWith("Act ")) {
          sceneFolders.push(child);
        }
      }
      if (sceneFolders.length === 0) {
        sceneFolders.push(folderStructure);
      }
    } else {
      for (const child of adventureFolder.children) {
        if (child instanceof TFolder && child.name.startsWith("Act ")) {
          sceneFolders.push(child);
        }
      }
      if (sceneFolders.length === 0) {
        for (const child of adventureFolder.children) {
          if (child instanceof TFile && child.extension === "md" && 
              child.path !== adventurePath && 
              child.basename.match(/^Scene\s+\d+/)) {
            sceneFolders.push(adventureFolder);
            break;
          }
        }
      }
    }

    for (const folder of sceneFolders) {
      for (const item of folder.children) {
        if (item instanceof TFile && item.extension === "md") {
          const match = item.basename.match(/^Scene\s+(\d+)\s+-\s+(.+)$/);
          if (match && match[1] && match[2]) {
            const cache = this.app.metadataCache.getFileCache(item);
            const frontmatter = cache?.frontmatter;

            scenes.push({
              path: item.path,
              number: parseInt(match[1]),
              name: match[2],
              type: frontmatter?.scene_type || "exploration",
              difficulty: frontmatter?.difficulty || "medium",
              status: frontmatter?.status || "not-started"
            });
          }
        }
      }
    }

    scenes.sort((a, b) => a.number - b.number);
    return scenes;
  }

  getSceneIcon(type: string): string {
    const icons: Record<string, string> = {
      social: "üó£Ô∏è",
      combat: "‚öîÔ∏è",
      exploration: "üîç",
      puzzle: "üß©",
      montage: "üé¨"
    };
    return icons[type] || "üìù";
  }

  async markSceneComplete(scenePath: string) {
    const file = this.app.vault.getAbstractFileByPath(scenePath);
    if (!(file instanceof TFile)) return;

    try {
      const content = await this.app.vault.read(file);
      const newContent = content.replace(
        /status:\s*[^\n]+/,
        'status: completed'
      );
      await this.app.vault.modify(file, newContent);
      new Notice("Scene marked as completed!");
    } catch (error) {
      console.error("Error marking scene complete:", error);
      new Notice("Error updating scene status");
    }
  }

  async onClose() {
    // Stop auto-save
    if (this.autoSaveInterval) {
      window.clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
    
    // Stop timer updates
    if (this.timerUpdateInterval) {
      window.clearInterval(this.timerUpdateInterval);
      this.timerUpdateInterval = null;
    }
    
    // Save any unsaved notes
    await this.saveQuickNotes();
    
    // Disable read-only mode
    if (this.readOnlyMode) {
      this.disableReadOnlyMode();
    }
  }
}

class SessionCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  campaignPath: string;
  sessionTitle = "";
  sessionDate: string;
  location = "";
  adventurePath = "";
  useCustomDate = false;
  calendar = "";
  startYear = "";
  startMonth = "";
  startDay = "";
  endYear = "";
  endMonth = "";
  endDay = "";
  selectedCalendarData: any = null;
  endDayDropdown: any = null;

  constructor(app: App, plugin: DndCampaignHubPlugin, adventurePath?: string, campaignPath?: string) {
    super(app);
    this.plugin = plugin;
    this.campaignPath = campaignPath || plugin.settings.currentCampaign;
    this.sessionDate = new Date().toISOString().split('T')[0] || "";
    if (adventurePath) {
      this.adventurePath = adventurePath;
    }
  }

  async getAllAdventures(): Promise<Array<{ path: string; name: string }>> {
    const adventures: Array<{ path: string; name: string }> = [];
    const campaignPath = this.campaignPath;
    
    const adventuresFolder = this.app.vault.getAbstractFileByPath(`${campaignPath}/Adventures`);
    
    if (adventuresFolder instanceof TFolder) {
      for (const item of adventuresFolder.children) {
        if (item instanceof TFile && item.extension === 'md') {
          // Adventure file directly in Adventures folder (flat structure)
          adventures.push({
            path: item.path,
            name: item.basename
          });
        } else if (item instanceof TFolder) {
          // Adventure folder with main note inside (folder structure)
          const mainFile = this.app.vault.getAbstractFileByPath(`${item.path}/${item.name}.md`);
          if (mainFile instanceof TFile) {
            adventures.push({
              path: mainFile.path,
              name: item.name
            });
          }
        }
      }
    }

    return adventures;
  }

  async loadCalendarData() {
    // Get campaign World.md to fetch calendar and dates
    const campaignPath = this.campaignPath;
    const worldFile = this.app.vault.getAbstractFileByPath(`${campaignPath}/World.md`);
    
    if (worldFile instanceof TFile) {
      const worldContent = await this.app.vault.read(worldFile);
      const calendarMatch = worldContent.match(/fc-calendar:\s*([^\r\n]\w*)$/m);
      if (calendarMatch && calendarMatch[1]) {
        this.calendar = calendarMatch[1].trim();
        // Get calendar data from Calendarium - search by name
        const calendariumPlugin = (this.app as any).plugins?.plugins?.calendarium;
        if (calendariumPlugin && calendariumPlugin.data?.calendars) {
          // Find calendar by name (stored in fc-calendar field)
          const calendars = calendariumPlugin.data.calendars;
          for (const [id, calData] of Object.entries(calendars)) {
            if ((calData as any).name === this.calendar) {
              this.selectedCalendarData = calData;
              break;
            }
          }
        }
      }
    }

    // Try to get start date from previous session
    const previousSession = await this.getPreviousSession();
    if (previousSession) {
      // Use end date of previous session as start date of this session
      this.startYear = previousSession.endYear;
      this.startMonth = previousSession.endMonth;
      this.startDay = previousSession.endDay;
    } else {
      // No previous session, use campaign start date
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const yearMatch = worldContent.match(/fc-date:\s*\n\s*year:\s*([^\r\n]\w*)$/m);
        const monthMatch = worldContent.match(/fc-date:\s*\n\s*year:.*\n\s*month:\s*([^\r\n]\w*)$/m);
        const dayMatch = worldContent.match(/fc-date:\s*\n\s*year:.*\n\s*month:.*\n\s*day:\s*([^\r\n]\w*)$/m);
        
        if (yearMatch && yearMatch[1]) this.startYear = yearMatch[1].trim();
        if (monthMatch && monthMatch[1]) this.startMonth = monthMatch[1].trim();
        if (dayMatch && dayMatch[1]) this.startDay = dayMatch[1].trim();
      }
    }

    // Ensure defaults if still empty
    if (!this.startYear) this.startYear = "1";
    if (!this.startMonth) this.startMonth = "1";
    if (!this.startDay) this.startDay = "1";

    // Initialize end date same as start date
    this.endYear = this.startYear;
    this.endMonth = this.startMonth;
    this.endDay = this.startDay;
  }

  async getPreviousSession(): Promise<{endYear: string, endMonth: string, endDay: string} | null> {
    const campaignFolder = this.app.vault.getAbstractFileByPath(this.campaignPath);
    
    if (campaignFolder instanceof TFolder) {
      const files = campaignFolder.children.filter(
        f => f instanceof TFile && f.name.match(/^\d{3}_\d{8}\.md$/)
      );
      
      if (files.length === 0) return null;
      
      // Sort by session number and get the last one
      const sortedFiles = files.sort((a, b) => {
        const numA = parseInt((a as TFile).name.substring(0, 3));
        const numB = parseInt((b as TFile).name.substring(0, 3));
        return numB - numA;
      });
      
      const lastSession = sortedFiles[0] as TFile;
      const content = await this.app.vault.read(lastSession);
      
      const endYearMatch = content.match(/fc-end:\s*\n\s*year:\s*(.+)/);
      const endMonthMatch = content.match(/fc-end:\s*\n\s*year:.*\n\s*month:\s*(.+)/);
      const endDayMatch = content.match(/fc-end:\s*\n\s*year:.*\n\s*month:.*\n\s*day:\s*(.+)/);
      
      if (endYearMatch?.[1] && endMonthMatch?.[1] && endDayMatch?.[1]) {
        return {
          endYear: endYearMatch[1].trim(),
          endMonth: endMonthMatch[1].trim(),
          endDay: endDayMatch[1].trim()
        };
      }
    }
    
    return null;
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "üìú Create New Session" });

    // Wait for calendar data to load
    await this.loadCalendarData();

    // Get campaign info
    const campaignPath = this.campaignPath;
    const campaignName = campaignPath?.split('/').pop() || "Unknown";
    
    contentEl.createEl("p", { 
      text: `Campaign: ${campaignName}`,
      cls: "setting-item-description"
    });

    // Calculate next session number
    const nextSessionNum = this.getNextSessionNumber();
    contentEl.createEl("p", { 
      text: `Session Number: ${nextSessionNum}`,
      cls: "setting-item-description"
    });

    // Session Title/Name
    new Setting(contentEl)
      .setName("Session Title")
      .setDesc("Optional descriptive title for this session")
      .addText((text) => {
        text
          .setPlaceholder("e.g., The Goblin Ambush")
          .onChange((value) => {
            this.sessionTitle = value;
          });
        text.inputEl.focus();
      });

    // Adventure Selection
    const adventures = await this.getAllAdventures();
    if (adventures.length > 0) {
      new Setting(contentEl)
        .setName("Adventure")
        .setDesc("Link this session to an adventure (optional)")
        .addDropdown(dropdown => {
          dropdown.addOption("", "-- None --");
          adventures.forEach(adv => {
            dropdown.addOption(adv.path, adv.name);
          });
          dropdown.setValue(this.adventurePath);
          dropdown.onChange(value => {
            this.adventurePath = value;
          });
        });
    }

    // Session Date (real world)
    new Setting(contentEl)
      .setName("Session Date")
      .setDesc("Date when this session was/will be played (real world)")
      .addText((text) =>
        text
          .setValue(this.sessionDate)
          .onChange((value) => {
            this.sessionDate = value;
          })
      )
      .addToggle((toggle) =>
        toggle
          .setTooltip("Use custom date")
          .setValue(this.useCustomDate)
          .onChange((value) => {
            this.useCustomDate = value;
            if (!value) {
              this.sessionDate = new Date().toISOString().split('T')[0] || "";
            }
          })
      );

    // Calendar section
    if (this.calendar && this.selectedCalendarData) {
      contentEl.createEl("h3", { text: `üìÖ In-Game Calendar: ${this.selectedCalendarData.name || this.calendar}` });

      const monthData = this.selectedCalendarData.static?.months || [];

      // Start Date (from previous session or campaign) - Read only display
      new Setting(contentEl)
        .setName("Start Date (In-Game)")
        .setDesc(`Starts: ${this.getDateDisplay(this.startYear, this.startMonth, this.startDay, monthData)}`);

      // End Date (user sets this)
      const endDateSetting = new Setting(contentEl)
        .setName("End Date (In-Game)")
        .setDesc("When does this session end in your world?");

      // Display current end date
      const endDateDisplay = contentEl.createEl("div", {
        cls: "dnd-date-display",
        text: this.getDateDisplay(this.endYear, this.endMonth, this.endDay, monthData)
      });

      // Add button to open date picker
      endDateSetting.addButton((button) => {
        button
          .setButtonText("üìÖ Pick End Date")
          .setCta()
          .onClick(async () => {
            await this.openSessionDatePicker(endDateDisplay, monthData);
          });
      });
    }

    // Location
    new Setting(contentEl)
      .setName("Location")
      .setDesc("Where does this session take place in your world?")
      .addText((text) =>
        text
          .setPlaceholder("e.g., Phandalin")
          .onChange((value) => {
            this.location = value;
          })
      );

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Create Session",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      this.close();
      await this.createSessionFile();
    });
  }

  getNextSessionNumber(): number {
    const campaignFolder = this.app.vault.getAbstractFileByPath(this.campaignPath);
    let nextNumber = 1;
    
    if (campaignFolder instanceof TFolder) {
      const files = campaignFolder.children.filter(
        f => f instanceof TFile && f.name.match(/^\d{3}_\d{8}\.md$/)
      );
      const numbers = files.map(f => parseInt((f as TFile).name.substring(0, 3)));
      if (numbers.length > 0) {
        nextNumber = Math.max(...numbers) + 1;
      }
    }
    
    return nextNumber;
  }

  getDateDisplay(year: string, month: string, day: string, monthData: any[]): string {
    const monthIndex = parseInt(month) - 1;
    const monthName = monthData[monthIndex]?.name || `Month ${month}`;
    return `${monthName} ${day}, Year ${year}`;
  }

  async openSessionDatePicker(displayElement: HTMLElement, monthData: any[]) {
    // Use our custom date picker modal with calendar validation
    const modal = new CalendarDateInputModal(
      this.app,
      this.selectedCalendarData,
      this.endYear,
      this.endMonth,
      this.endDay,
      (year, month, day) => {
        this.endYear = year;
        this.endMonth = month;
        this.endDay = day;
        displayElement.setText(this.getDateDisplay(this.endYear, this.endMonth, this.endDay, monthData));
      }
    );
    modal.open();
  }

  async createSessionFile() {
    const campaignPath = this.campaignPath;
    const campaignName = campaignPath?.split('/').pop() || "Unknown";
    const nextNumber = this.getNextSessionNumber();

    new Notice(`Creating session ${nextNumber}...`);

    try {
      // Determine which template to use based on campaign role
      const worldFile = this.app.vault.getAbstractFileByPath(`${campaignPath}/World.md`);
      let isGM = true; // Default to GM
      
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const roleMatch = worldContent.match(/role:\s*(GM|player)/i);
        if (roleMatch && roleMatch[1]) {
          isGM = roleMatch[1].toLowerCase() === 'gm';
        }
      }

      // Get appropriate template
      const templatePath = isGM ? "z_Templates/session-gm.md" : "z_Templates/session-player.md";
      const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
      let sessionContent: string;

      if (templateFile instanceof TFile) {
        sessionContent = await this.app.vault.read(templateFile);
      } else {
        sessionContent = isGM ? SESSION_GM_TEMPLATE : SESSION_PLAYER_TEMPLATE;
      }

      // Create filename: 001_20260120.md format
      const dateStr = this.sessionDate.replace(/-/g, '');
      const fileName = `${nextNumber.toString().padStart(3, '0')}_${dateStr}.md`;
      const filePath = `${campaignPath}/${fileName}`;

      // Find previous session for recap
      let recapContent = "";
      if (nextNumber > 1) {
        const prevNumber = nextNumber - 1;
        const campaignFolder = this.app.vault.getAbstractFileByPath(campaignPath);
        
        if (campaignFolder instanceof TFolder) {
          // Find the previous session file (format: 001_20260120.md)
          const prevSessionFile = campaignFolder.children.find(
            f => f instanceof TFile && f.name.match(new RegExp(`^${prevNumber.toString().padStart(3, '0')}_\\d{8}\\.md$`))
          );
          
          if (prevSessionFile instanceof TFile) {
            // Get filename without extension
            const prevSessionName = prevSessionFile.basename;
            recapContent = `\n![[${prevSessionName}#^summary]]\n`;
          }
        }
      }

      // Replace the Recap section with previous session's summary (if available)
      if (recapContent) {
        sessionContent = sessionContent.replace(/## Recap\s*\n/m, `## Recap\n${recapContent}`);
      }

      // Replace placeholders in template using proper regex patterns
      sessionContent = sessionContent
        .replace(/campaign:\s*([^\r\n]\w*)$/m, `campaign: ${campaignName}`)
        .replace(/world:\s*([^\r\n]\w*)$/m, `world: ${campaignName}`)
        .replace(/adventure:\s*([^\r\n]\w*)$/m, `adventure: ${this.adventurePath ? `"[[${this.adventurePath}]]"` : ''}`)
        .replace(/sessionNum:\s*([^\r\n]\w*)$/m, `sessionNum: ${nextNumber}`)
        .replace(/location:\s*([^\r\n]\w*)$/m, `location: ${this.location}`)
        .replace(/date:\s*([^\r\n]\w*)$/m, `date: ${this.sessionDate}`)
        .replace(/fc-calendar:\s*([^\r\n]\w*)$/m, `fc-calendar: ${this.calendar}`)
        .replace(/# Session\s*([^\r\n]\w*)$/m, `# Session ${nextNumber}${this.sessionTitle ? ' - ' + this.sessionTitle : ''}`);

      // Replace fc-date (start date) - need to match the nested structure
      sessionContent = sessionContent
        .replace(/fc-date:\s*\n\s*year:\s*([^\r\n]\w*)$/m, `fc-date:\n  year: ${this.startYear}`)
        .replace(/(fc-date:\s*\n\s*year:.*\n\s*)month:\s*([^\r\n]\w*)$/m, `$1month: ${this.startMonth}`)
        .replace(/(fc-date:\s*\n\s*year:.*\n\s*month:.*\n\s*)day:\s*([^\r\n]\w*)$/m, `$1day: ${this.startDay}`);

      // Replace fc-end (end date) - need to match the nested structure
      sessionContent = sessionContent
        .replace(/fc-end:\s*\n\s*year:\s*([^\r\n]\w*)$/m, `fc-end:\n  year: ${this.endYear}`)
        .replace(/(fc-end:\s*\n\s*year:.*\n\s*)month:\s*([^\r\n]\w*)$/m, `$1month: ${this.endMonth}`)
        .replace(/(fc-end:\s*\n\s*year:.*\n\s*month:.*\n\s*)day:\s*([^\r\n]\w*)$/m, `$1day: ${this.endDay}`);
      // Create the file
      await this.app.vault.create(filePath, sessionContent);

      // Open the file
      await this.app.workspace.openLinkText(filePath, "", true);

      new Notice(`‚úÖ Session ${nextNumber} created successfully!`);
    } catch (error) {
      new Notice(`‚ùå Error creating session: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Session creation error:", error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class CampaignCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  campaignName = "";
  dmName = "";
  system = "D&D 5e";
  role = "GM";
  calendar = "";
  calendarName = "";
  startYear = "";
  startMonth = "";
  startDay = "";
  selectedCalendarData: any = null;
  calendarContainer: HTMLElement | null = null;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "üé≤ Create New Campaign" });

    // Campaign Name
    new Setting(contentEl)
      .setName("Campaign Name")
      .setDesc("The name of your campaign")
      .addText((text) => {
        text
          .setPlaceholder("e.g., Lost Mines of Phandelver")
          .onChange((value) => {
            this.campaignName = value;
          });
        text.inputEl.focus();
      });

    // Role Selection
    new Setting(contentEl)
      .setName("Your Role")
      .setDesc("Are you the GM/DM or a player?")
      .addDropdown((dropdown) => {
        dropdown
          .addOption("GM", "Game Master / DM")
          .addOption("player", "Player")
          .setValue(this.role)
          .onChange((value) => {
            this.role = value;
            this.updateDMField();
          });
      });

    // DM Name (shown only if player)
    const dmSetting = new Setting(contentEl)
      .setName("DM Name")
      .setDesc("Name of the Dungeon Master")
      .addText((text) =>
        text
          .setPlaceholder("e.g., John Smith")
          .onChange((value) => {
            this.dmName = value;
          })
      );

    // Hide DM field initially if GM
    if (this.role === "GM") {
      dmSetting.settingEl.style.display = "none";
    }

    // System Selection
    new Setting(contentEl)
      .setName("Game System")
      .setDesc("Which RPG system are you using?")
      .addDropdown((dropdown) => {
        dropdown
          .addOption("D&D 5e", "Dungeons & Dragons 5th Edition")
          .addOption("Pathfinder 2e", "Pathfinder 2nd Edition")
          .addOption("Call of Cthulhu", "Call of Cthulhu")
          .addOption("Savage Worlds", "Savage Worlds")
          .addOption("FATE", "FATE Core")
          .addOption("OSR", "Old School Renaissance")
          .addOption("Other", "Other / Custom")
          .setValue(this.system)
          .onChange((value) => {
            this.system = value;
          });
      });

    contentEl.createEl("h3", { text: "üìÖ Calendar Settings" });

    // Calendar Selection
    const calendars = this.getAvailableCalendars();
    new Setting(contentEl)
      .setName("Fantasy Calendar")
      .setDesc("Select an existing calendar or create a new one")
      .addDropdown((dropdown) => {
        dropdown.addOption("", "None");
        dropdown.addOption("__CREATE_NEW__", "‚ûï Create New Calendar");
        calendars.forEach(cal => {
          dropdown.addOption(cal.id, cal.name);
        });
        dropdown.setValue(this.calendar)
          .onChange((value) => {
            this.calendar = value;
            if (value === "__CREATE_NEW__") {
              this.showCreateCalendarUI();
            } else if (value) {
              this.selectedCalendarData = this.getCalendarData(value);
              this.calendarName = this.selectedCalendarData?.name || value;
              this.showDateSelectors();
            } else {
              this.hideDateSelectors();
            }
          });
      });

    // Container for calendar-specific UI
    this.calendarContainer = contentEl.createDiv({ cls: "dnd-calendar-container" });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Create Campaign",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      if (!this.campaignName.trim()) {
        new Notice("Please enter a campaign name!");
        return;
      }

      this.close();
      await this.createCampaignStructure();
    });

    // Store DM setting reference for later
    this.updateDMField = () => {
      if (this.role === "GM") {
        dmSetting.settingEl.style.display = "none";
      } else {
        dmSetting.settingEl.style.display = "";
      }
    };
  }

  updateDMField() {
    // This will be set in onOpen
  }

  showDateSelectors() {
    if (!this.calendarContainer) return;
    this.calendarContainer.empty();

    if (!this.selectedCalendarData) return;

    // Initialize default values if not set
    if (!this.startYear) this.startYear = "1";
    if (!this.startMonth) this.startMonth = "1";
    if (!this.startDay) this.startDay = "1";

    // Campaign Start Date with date picker button
    const dateSetting = new Setting(this.calendarContainer)
      .setName("Campaign Start Date")
      .setDesc("When does the campaign begin in your world?");

    // Display current date
    const dateDisplay = this.calendarContainer.createEl("div", {
      cls: "dnd-date-display"
    });
    this.updateDateDisplay(dateDisplay);

    // Add button to open Calendarium's date picker
    dateSetting.addButton((button) => {
      button
        .setButtonText("üìÖ Pick Date")
        .setCta()
        .onClick(async () => {
          await this.openCalendariumDatePicker();
        });
    });
  }

  updateDateDisplay(container: HTMLElement) {
    const monthData = this.selectedCalendarData?.static?.months || [];
    const monthIndex = parseInt(this.startMonth || "1") - 1;
    const monthName = monthData[monthIndex]?.name || `Month ${this.startMonth}`;
    
    container.setText(`${monthName} ${this.startDay}, Year ${this.startYear}`);
  }

  async openCalendariumDatePicker() {
    // Use our custom date picker modal with calendar validation
    const modal = new CalendarDateInputModal(
      this.app,
      this.selectedCalendarData,
      this.startYear,
      this.startMonth,
      this.startDay,
      (year, month, day) => {
        this.startYear = year;
        this.startMonth = month;
        this.startDay = day;
        
        const dateDisplay = this.calendarContainer?.querySelector('.dnd-date-display');
        if (dateDisplay) {
          this.updateDateDisplay(dateDisplay as HTMLElement);
        }
      }
    );
    modal.open();
  }

  hideDateSelectors() {
    if (this.calendarContainer) {
      this.calendarContainer.empty();
    }
  }

  showCreateCalendarUI() {
    if (!this.calendarContainer) return;
    this.calendarContainer.empty();

    this.calendarContainer.createEl("p", {
      text: "Click below to open Calendarium's calendar creation interface.",
      cls: "setting-item-description"
    });

    const buttonContainer = this.calendarContainer.createDiv({ cls: "dnd-calendar-buttons" });

    // Quick Create button
    const quickButton = buttonContainer.createEl("button", {
      text: "‚ö° Quick Create",
      cls: "mod-cta"
    });
    quickButton.addEventListener("click", async () => {
      await this.openCalendariumCreation("quick");
    });

    // Full Create button
    const fullButton = buttonContainer.createEl("button", {
      text: "üé® Full Create"
    });
    fullButton.addEventListener("click", async () => {
      await this.openCalendariumCreation("full");
    });

    // Import button
    const importButton = buttonContainer.createEl("button", {
      text: "üì• Import"
    });
    importButton.addEventListener("click", async () => {
      await this.openCalendariumCreation("import");
    });

    this.calendarContainer.createEl("p", {
      text: "After creating your calendar, reopen this modal to select it.",
      cls: "setting-item-description mod-warning"
    });
  }

  async openCalendariumCreation(type: "quick" | "full" | "import") {
    const calendariumPlugin = (this.app as any).plugins?.plugins?.calendarium;
    if (!calendariumPlugin) {
      new Notice("Calendarium plugin not found!");
      return;
    }

    // Close this modal temporarily
    this.close();

    // Open Calendarium settings to the calendar creation section
    // This uses Obsidian's settings API
    const settingTab = (this.app as any).setting;
    if (settingTab) {
      settingTab.open();
      settingTab.openTabById("calendarium");
    }

    // Try to trigger the appropriate calendar creation command
    const commands = {
      quick: "calendarium:open-quick-creator",
      full: "calendarium:open-creator",
      import: "calendarium:import-calendar"
    };

    const commandId = commands[type];

    setTimeout(() => {
      (this.app as any).commands?.executeCommandById(commandId);
    }, 100);

    new Notice("After creating your calendar, use 'Create Campaign' again to select it.");
  }

  getAvailableCalendars(): Array<{ id: string; name: string }> {
    const calendariumPlugin = (this.app as any).plugins?.plugins?.calendarium;
    if (calendariumPlugin && calendariumPlugin.data?.calendars) {
      const calendars = calendariumPlugin.data.calendars as Record<string, { name?: string }>;
      return Object.keys(calendars).map((id) => ({
        id,
        name: calendars[id]?.name || id,
      }));
    }
    return [];
  }

  getCalendarData(calendarId: string): any {
    const calendariumPlugin = (this.app as any).plugins?.plugins?.calendarium;
    if (calendariumPlugin && calendariumPlugin.data?.calendars) {
      return calendariumPlugin.data.calendars[calendarId];
    }
    return null;
  }

  async createCampaignStructure() {
    const campaignName = this.campaignName.trim();
    const campaignPath = `ttrpgs/${campaignName}`;

    new Notice(`Creating campaign "${campaignName}"...`);

    try {
      const campaignFolders = [
        campaignPath,
        `${campaignPath}/NPCs`,
        `${campaignPath}/PCs`,
        `${campaignPath}/Adventures`,
        `${campaignPath}/Factions`,
        `${campaignPath}/Items`,
        `${campaignPath}/Modules`,
        `${campaignPath}/Plot`,
        `${campaignPath}/fc-calendar`,
      ];

      for (const folder of campaignFolders) {
        await this.plugin.ensureFolderExists(folder);
      }

      const worldTemplate = this.app.vault.getAbstractFileByPath("z_Templates/world.md");
      let worldContent: string;

      if (worldTemplate instanceof TFile) {
        worldContent = await this.app.vault.read(worldTemplate);
      } else {
        worldContent = WORLD_TEMPLATE;
      }

      worldContent = worldContent
        .replace(/world: $/m, `world: ${campaignName}`)
        .replace(/campaign: $/m, `campaign: ${campaignName}`)
        .replace(/role: player$/m, `role: ${this.role}`)
        .replace(/system:$/m, `system: ${this.system}`)
        .replace(/fc-calendar:\s*([^\r\n]\w*)$/m, `fc-calendar: ${this.calendarName}`)
        .replace(/fc-date:\s*\n\s*year:\s*([^\r\n]\w*)$/m, `fc-date:\n  year: ${this.startYear}`)
        .replace(/(fc-date:\s*\n\s*year:.+\n\s*)month:\s*([^\r\n]\w*)$/m, `$1month: ${this.startMonth}`)
        .replace(/(fc-date:\s*\n\s*year:.+\n\s*month:.+\n\s*)day:\s*([^\r\n]\w*)$/m, `$1day: ${this.startDay}`)
        .replace(/# The World of Your Campaign/g, `# The World of ${campaignName}`)
        .replace(/{{CAMPAIGN_NAME}}/g, campaignName);

      const worldFilePath = `${campaignPath}/World.md`;
      await this.app.vault.create(worldFilePath, worldContent);

      if (this.role === "GM") {
        const houseRulesContent = `---
type: rules
campaign: ${campaignName}
---

# House Rules

## Character Creation
- 

## Combat Rules
- 

## Homebrew Content
- 

## Table Etiquette
- 
`;
        await this.app.vault.create(`${campaignPath}/House Rules.md`, houseRulesContent);
      }

      this.plugin.settings.currentCampaign = campaignPath;
      await this.plugin.saveSettings();

      await this.app.workspace.openLinkText(worldFilePath, "", true);

      new Notice(`‚úÖ Campaign "${campaignName}" created successfully!`);
    } catch (error) {
      new Notice(`‚ùå Error creating campaign: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Campaign creation error:", error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * Modal to inform users about missing plugin dependencies
 */
class DependencyModal extends Modal {
  dependencies: { missing: string[]; installed: string[] };

  constructor(app: App, dependencies: { missing: string[]; installed: string[] }) {
    super(app);
    this.dependencies = dependencies;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "‚ö†Ô∏è Missing Plugin Dependencies" });

    contentEl.createEl("p", {
      text: "D&D Campaign Hub requires the following community plugins to work properly:"
    });

    // Show missing plugins
    if (this.dependencies.missing.length > 0) {
      const missingList = contentEl.createEl("div", { cls: "dnd-dependency-list" });
      missingList.createEl("h3", { text: "‚ùå Missing:" });
      const ul = missingList.createEl("ul");
      this.dependencies.missing.forEach(plugin => {
        ul.createEl("li", { text: plugin });
      });
    }

    // Show installed plugins
    if (this.dependencies.installed.length > 0) {
      const installedList = contentEl.createEl("div", { cls: "dnd-dependency-list" });
      installedList.createEl("h3", { text: "‚úÖ Installed:" });
      const ul = installedList.createEl("ul");
      this.dependencies.installed.forEach(plugin => {
        ul.createEl("li", { text: plugin });
      });
    }

    contentEl.createEl("h3", { text: "üì¶ How to Install" });
    const instructions = contentEl.createEl("div", { cls: "dnd-dependency-instructions" });
    instructions.createEl("p", { text: "1. Open Settings ‚Üí Community Plugins" });
    instructions.createEl("p", { text: "2. Click 'Browse' to open the plugin browser" });
    instructions.createEl("p", { text: "3. Search for and install the missing plugins" });
    instructions.createEl("p", { text: "4. Enable each plugin after installation" });
    instructions.createEl("p", { text: "5. Return to D&D Campaign Hub and try again" });

    contentEl.createEl("p", { 
      text: "üí° These plugins add buttons, tables, and calendar features that make your campaigns interactive and organized.",
      cls: "dnd-dependency-note"
    });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const settingsButton = buttonContainer.createEl("button", {
      text: "Open Settings",
      cls: "mod-cta"
    });
    settingsButton.addEventListener("click", () => {
      (this.app as any).setting.open();
      (this.app as any).setting.openTabById('community-plugins');
      this.close();
    });

    const closeButton = buttonContainer.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class CalendarDateInputModal extends Modal {
  calendarData: any;
  year: string;
  month: string;
  day: string;
  onSubmit: (year: string, month: string, day: string) => void;
  dayDropdown: any = null;

  constructor(
    app: App,
    calendarData: any,
    year: string,
    month: string,
    day: string,
    onSubmit: (year: string, month: string, day: string) => void
  ) {
    super(app);
    this.calendarData = calendarData;
    this.year = year || "1";
    this.month = month || "1";
    this.day = day || "1";
    this.onSubmit = onSubmit;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: " Select Date" });

    const monthData = this.calendarData?.static?.months || [];

    const dateSetting = new Setting(contentEl)
      .setName("Date")
      .setDesc("Select year, month, and day");

    dateSetting.addText((text) => {
      text
        .setPlaceholder("Year")
        .setValue(this.year)
        .onChange((value) => {
          this.year = value;
        });
      text.inputEl.style.width = "80px";
    });

    dateSetting.addDropdown((dropdown) => {
      monthData.forEach((month: any, index: number) => {
        const monthName = month.name || `Month ${index + 1}`;
        dropdown.addOption((index + 1).toString(), monthName);
      });
      dropdown.setValue(this.month || "1")
        .onChange((value) => {
          this.month = value;
          this.updateDayDropdown();
        });
    });

    dateSetting.addDropdown((dropdown) => {
      this.dayDropdown = dropdown;
      this.updateDayDropdown();
      dropdown.setValue(this.day || "1")
        .onChange((value) => {
          this.day = value;
        });
    });

    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const selectButton = buttonContainer.createEl("button", {
      text: "Select Date",
      cls: "mod-cta"
    });
    selectButton.addEventListener("click", () => {
      this.onSubmit(this.year, this.month, this.day);
      this.close();
    });
  }

  updateDayDropdown() {
    if (!this.dayDropdown) return;

    const monthData = this.calendarData?.static?.months || [];
    const monthIndex = parseInt(this.month || "1") - 1;
    const daysInMonth = monthData[monthIndex]?.length || 30;

    this.dayDropdown.selectEl.empty();
    for (let d = 1; d <= daysInMonth; d++) {
      this.dayDropdown.addOption(d.toString(), d.toString());
    }
    
    if (parseInt(this.day) > daysInMonth) {
      this.day = daysInMonth.toString();
      this.dayDropdown.setValue(this.day);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class AdventureCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  adventureName = "";
  campaign = "";
  theProblem = "";
  levelFrom = "1";
  levelTo = "3";
  expectedSessions = "3";
  useFolderStructure = false;
  isGM = false;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
    this.campaign = plugin.settings.currentCampaign;
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "üó∫Ô∏è Create New Adventure" });

    // Get all campaigns and filter for GM ones
    const allCampaigns = await this.getAllGMCampaigns();

    if (allCampaigns.length === 0) {
      contentEl.createEl("p", {
        text: "‚ö†Ô∏è Only GMs can create adventures. You don't have any campaigns where you are set as GM (role: gm in World.md).",
        cls: "mod-warning"
      });
      
      const closeBtn = contentEl.createEl("button", { text: "Close" });
      closeBtn.addEventListener("click", () => this.close());
      return;
    }

    // Default to first GM campaign
    if (allCampaigns.length > 0 && allCampaigns[0]) {
      this.campaign = allCampaigns[0].path;
      this.isGM = true;
    }

    contentEl.createEl("p", {
      text: "Plan a compelling multi-session adventure with a 3-act structure.",
      cls: "setting-item-description"
    });

    // Adventure Name
    new Setting(contentEl)
      .setName("Adventure Name")
      .setDesc("What is this adventure called?")
      .addText((text) => {
        text
          .setPlaceholder("e.g., The Sunless Citadel, Murder in Baldur's Gate")
          .onChange((value) => {
            this.adventureName = value;
          });
        text.inputEl.focus();
      });

    // Campaign Selection (only GM campaigns)
    new Setting(contentEl)
      .setName("Campaign")
      .setDesc("Which campaign does this adventure belong to?")
      .addDropdown((dropdown) => {
        allCampaigns.forEach(campaign => {
          dropdown.addOption(campaign.path, campaign.name);
        });
        dropdown.setValue(this.campaign)
          .onChange((value) => {
            this.campaign = value;
          });
      });

    contentEl.createEl("h3", { text: "üìñ Core Adventure" });

    // The Problem
    new Setting(contentEl)
      .setName("The Problem")
      .setDesc("What urgent situation demands heroes? (2-3 sentences)")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., A kobold tribe has taken over an ancient citadel and is terrorizing nearby settlements. The mayor desperately needs heroes to stop the raids before the town is abandoned.")
          .onChange((value) => {
            this.theProblem = value;
          });
        text.inputEl.rows = 4;
      });

    contentEl.createEl("h3", { text: "‚öôÔ∏è Adventure Parameters" });

    // Level Range
    const levelSetting = new Setting(contentEl)
      .setName("Target Level Range")
      .setDesc("What character levels is this adventure designed for?");

    levelSetting.addText((text) => {
      text
        .setPlaceholder("1")
        .setValue(this.levelFrom)
        .onChange((value) => {
          this.levelFrom = value;
        });
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });

    levelSetting.controlEl.createSpan({ text: " to ", cls: "dnd-level-separator" });

    levelSetting.addText((text) => {
      text
        .setPlaceholder("3")
        .setValue(this.levelTo)
        .onChange((value) => {
          this.levelTo = value;
        });
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });

    // Expected Sessions
    new Setting(contentEl)
      .setName("Expected Sessions")
      .setDesc("How many sessions do you expect this adventure to take?")
      .addText((text) => {
        text
          .setPlaceholder("3")
          .setValue(this.expectedSessions)
          .onChange((value) => {
            this.expectedSessions = value;
          });
        text.inputEl.type = "number";
        text.inputEl.style.width = "80px";
      });

    contentEl.createEl("h3", { text: "üìÅ Structure Options" });

    // Folder Structure Toggle
    new Setting(contentEl)
      .setName("Create full folder structure with Acts")
      .setDesc("Organize scenes into separate Act folders (recommended for 3+ session adventures)")
      .addToggle((toggle) =>
        toggle
          .setValue(this.useFolderStructure)
          .onChange((value) => {
            this.useFolderStructure = value;
          })
      );

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Create Adventure",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      if (!this.adventureName.trim()) {
        new Notice("Please enter an adventure name!");
        return;
      }

      this.close();
      await this.createAdventureFile();
    });
  }

  async getAllGMCampaigns(): Promise<Array<{ path: string; name: string }>> {
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
    const gmCampaigns: Array<{ path: string; name: string }> = [];

    if (ttrpgsFolder instanceof TFolder) {
      for (const child of ttrpgsFolder.children) {
        if (child instanceof TFolder) {
          // Check if this campaign has role: gm
          const worldFile = this.app.vault.getAbstractFileByPath(`${child.path}/World.md`);
          if (worldFile instanceof TFile) {
            const worldContent = await this.app.vault.read(worldFile);
            const roleMatch = worldContent.match(/^role:\s*([^\r\n]\w*)$/m);
            if (roleMatch && roleMatch[1] && roleMatch[1].toLowerCase() === 'gm') {
              gmCampaigns.push({
                path: child.path,
                name: child.name
              });
            }
          }
        }
      }
    }

    return gmCampaigns;
  }

  async createAdventureFile() {
    const campaignName = this.campaign.split('/').pop() || "Unknown";
    const baseAdventurePath = `${this.campaign}/Adventures`;
    
    new Notice(`Creating Adventure "${this.adventureName}"...`);

    try {
      await this.plugin.ensureFolderExists(baseAdventurePath);

      // Get world info from campaign World.md
      const worldFile = this.app.vault.getAbstractFileByPath(`${this.campaign}/World.md`);
      let worldName = campaignName;
      
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const worldMatch = worldContent.match(/^world:\s*([^\r\n]+)$/m);
        if (worldMatch && worldMatch[1] && worldMatch[1].trim()) {
          worldName = worldMatch[1].trim();
        }
      }

      // Determine folder structure
      let adventureFolder: string;
      let mainNotePath: string;
      let scenesBasePath: string;

      if (this.useFolderStructure) {
        // Full folder structure: Adventures/Adventure Name/Adventure Name.md
        adventureFolder = `${baseAdventurePath}/${this.adventureName}`;
        await this.plugin.ensureFolderExists(adventureFolder);
        mainNotePath = `${adventureFolder}/${this.adventureName}.md`;
        scenesBasePath = adventureFolder; // Acts will be subfolders here
      } else {
        // Flat structure: Adventures/Adventure Name.md with Scenes subfolder
        mainNotePath = `${baseAdventurePath}/${this.adventureName}.md`;
        scenesBasePath = `${baseAdventurePath}/${this.adventureName} - Scenes`;
        await this.plugin.ensureFolderExists(scenesBasePath);
      }

      // Get current date
      const currentDate: string = new Date().toISOString().split('T')[0] || new Date().toISOString().substring(0, 10);

      // Ensure worldName has a value for type safety
      const safeWorldName: string = worldName || campaignName || "Unknown";
      const safeCampaignName: string = campaignName || "Unknown";

      // Create main adventure note
      await this.createMainAdventureNote(mainNotePath, safeCampaignName, safeWorldName, currentDate);

      // Create scene notes
      await this.createSceneNotes(scenesBasePath, safeCampaignName, safeWorldName, currentDate);

      // Open the main adventure file
      await this.app.workspace.openLinkText(mainNotePath, "", true);

      new Notice(`‚úÖ Adventure "${this.adventureName}" created with 9 scenes!`);
    } catch (error) {
      new Notice(`‚ùå Error creating Adventure: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Adventure creation error:", error);
    }
  }

  async createMainAdventureNote(filePath: string, campaignName: string, worldName: string, currentDate: string) {
    // Get Adventure template
    const templatePath = "z_Templates/Frontmatter - Adventure.md";
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    let adventureContent: string;

    if (templateFile instanceof TFile) {
      adventureContent = await this.app.vault.read(templateFile);
    } else {
      adventureContent = ADVENTURE_TEMPLATE;
    }

    // Build complete frontmatter
    const frontmatter = `---
type: adventure
name: ${this.adventureName}
campaign: ${campaignName}
world: ${worldName}
status: planning
level_range: ${this.levelFrom}-${this.levelTo}
current_act: 1
expected_sessions: ${this.expectedSessions}
sessions: []
date: ${currentDate}
---`;

    // Replace the frontmatter
    adventureContent = adventureContent.replace(/^---\n[\s\S]*?\n---/, frontmatter);
    
    // Replace template placeholders
    adventureContent = adventureContent
      .replace(/# <% tp\.frontmatter\.name %>/g, `# ${this.adventureName}`)
      .replace(/<% tp\.frontmatter\.name %>/g, this.adventureName)
      .replace(/{{ADVENTURE_NAME}}/g, this.adventureName)
      .replace(/{{CAMPAIGN_NAME}}/g, campaignName)
      .replace(/{{LEVEL_RANGE}}/g, `${this.levelFrom}-${this.levelTo}`)
      .replace(/{{EXPECTED_SESSIONS}}/g, this.expectedSessions)
      .replace(/{{THE_PROBLEM}}/g, this.theProblem || "_[What urgent situation demands heroes?]_")
      .replace(/<% tp\.frontmatter\.level_range %>/g, `${this.levelFrom}-${this.levelTo}`)
      .replace(/<% tp\.frontmatter\.expected_sessions %>/g, this.expectedSessions)
      .replace(/<% tp\.frontmatter\.current_act %>/g, "1");

    await this.app.vault.create(filePath, adventureContent);
  }

  async createSceneNotes(basePath: string, campaignName: string, worldName: string, currentDate: string) {
    const scenes = [
      { act: 1, num: 1, name: "Opening Hook", duration: "15min", type: "social", difficulty: "easy" },
      { act: 1, num: 2, name: "Investigation", duration: "30min", type: "exploration", difficulty: "medium" },
      { act: 1, num: 3, name: "First Confrontation", duration: "45min", type: "combat", difficulty: "medium" },
      { act: 2, num: 4, name: "Complication Arises", duration: "20min", type: "social", difficulty: "medium" },
      { act: 2, num: 5, name: "Major Challenge", duration: "40min", type: "combat", difficulty: "hard" },
      { act: 2, num: 6, name: "Critical Choice", duration: "30min", type: "social", difficulty: "hard" },
      { act: 3, num: 7, name: "Preparation", duration: "20min", type: "exploration", difficulty: "medium" },
      { act: 3, num: 8, name: "Climactic Battle", duration: "60min", type: "combat", difficulty: "deadly" },
      { act: 3, num: 9, name: "Resolution", duration: "10min", type: "social", difficulty: "easy" }
    ];

    for (const scene of scenes) {
      let scenePath: string;
      
      if (this.useFolderStructure) {
        // Create Act folders
        const actName = scene.act === 1 ? "Act 1 - Setup" : scene.act === 2 ? "Act 2 - Rising Action" : "Act 3 - Climax";
        const actFolder = `${basePath}/${actName}`;
        await this.plugin.ensureFolderExists(actFolder);
        scenePath = `${actFolder}/Scene ${scene.num} - ${scene.name}.md`;
      } else {
        // Flat structure
        scenePath = `${basePath}/Scene ${scene.num} - ${scene.name}.md`;
      }

      await this.createSceneNote(scenePath, scene, campaignName, worldName, currentDate);
    }
  }

  async createSceneNote(filePath: string, scene: any, campaignName: string, worldName: string, currentDate: string) {
    const sceneContent = SCENE_TEMPLATE
      .replace(/{{SCENE_NUMBER}}/g, scene.num.toString())
      .replace(/{{SCENE_NAME}}/g, scene.name)
      .replace(/{{ADVENTURE_NAME}}/g, this.adventureName)
      .replace(/{{ACT_NUMBER}}/g, scene.act.toString())
      .replace(/{{DURATION}}/g, scene.duration)
      .replace(/{{TYPE}}/g, scene.type)
      .replace(/{{DIFFICULTY}}/g, scene.difficulty)
      .replace(/{{CAMPAIGN}}/g, campaignName)
      .replace(/{{WORLD}}/g, worldName)
      .replace(/{{DATE}}/g, currentDate)
      .replace(/{{TRACKER_ENCOUNTER}}/g, "")
      .replace(/{{ENCOUNTER_CREATURES}}/g, "[]")
      .replace(/{{ENCOUNTER_DIFFICULTY}}/g, "null");

    await this.app.vault.create(filePath, sceneContent);
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

// Trap-related interfaces
interface TrapElement {
  name: string;
  element_type: 'active' | 'dynamic' | 'constant';
  initiative?: number;  // For active elements
  attack_bonus?: number;
  save_dc?: number;
  save_ability?: string;
  damage?: string;
  additional_damage?: string;  // Extra damage (e.g., ongoing, secondary)
  range?: string;  // Attack/effect range (e.g., "60 ft.", "Touch")
  on_success?: string;  // What happens on successful save
  on_failure?: string;  // What happens on failed save
  effect?: string;
  condition?: string;  // For dynamic elements
}

interface TrapCountermeasure {
  method: string;
  description?: string;
  dc?: number;
  checks_needed?: number;
  effect?: string;
}

interface EncounterCreature {
  name: string;
  count: number;
  hp?: number;
  ac?: number;
  cr?: string;
  source?: string;
  path?: string;  // Path to creature file for statblock plugin
  isCustom?: boolean;  // Temporary custom creature
  isFriendly?: boolean;  // Friendly NPC/creature
  isHidden?: boolean;  // Hidden from players
  isTrap?: boolean;  // Trap hazard (uses trap calculation logic)
  trapData?: {  // Trap-specific data for difficulty calculation
    elements: TrapElement[];
    threatLevel: 'setback' | 'dangerous' | 'deadly';
    trapType: 'simple' | 'complex';
  };
}

interface EncounterData {
  name: string;
  creatures: EncounterCreature[];
  includeParty: boolean;
  useColorNames: boolean;
  adventurePath?: string;
  scenePath?: string;
  campaignPath?: string;
  difficulty?: {
    rating: string;
    color: string;
    summary: string;
    partyStats?: any;
    enemyStats?: any;
  };
}

class EncounterBuilder {
  app: App;
  plugin: DndCampaignHubPlugin;

  encounterName = "";
  creatures: EncounterCreature[] = [];
  includeParty = true;
  selectedPartyMembers: string[] = [];
  selectedPartyId = "";
  useColorNames = false;
  adventurePath = "";
  scenePath = "";
  campaignPath = "";

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    this.app = app;
    this.plugin = plugin;
  }

  /**
   * Refresh party data from Initiative Tracker by reloading its settings
   * This attempts to sync the latest player stats from Character Notes through Initiative Tracker
   */
  async refreshPartyData(): Promise<boolean> {
    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin) {
        console.warn("[RefreshPartyData] Initiative Tracker plugin not found");
        return false;
      }

      // Check if the plugin has a loadSettings method (standard Obsidian plugin pattern)
      if (typeof initiativePlugin.loadSettings === 'function') {
        console.log("[RefreshPartyData] Calling Initiative Tracker's loadSettings()...");
        await initiativePlugin.loadSettings();
        console.log("[RefreshPartyData] ‚úÖ Successfully reloaded Initiative Tracker data");
        new Notice("‚úÖ Party stats refreshed from Initiative Tracker");
        return true;
      } else {
        console.warn("[RefreshPartyData] Initiative Tracker doesn't expose loadSettings() method");
        new Notice("‚ö†Ô∏è Cannot refresh party stats - Initiative Tracker doesn't support refresh API");
        return false;
      }
    } catch (error) {
      console.error("[RefreshPartyData] Error refreshing party data:", error);
      new Notice("‚ùå Failed to refresh party stats");
      return false;
    }
  }

  findCampaignFolder(filePath: string): string | null {
    // Look for campaign folder in path (folders containing "ttrpgs" subdirectory)
    const parts = filePath.split('/');
    for (let i = parts.length - 1; i >= 0; i--) {
      const potentialCampaign = parts.slice(0, i + 1).join('/');
      const ttrpgPath = `${potentialCampaign}/ttrpgs`;
      if (this.app.vault.getAbstractFileByPath(ttrpgPath)) {
        return potentialCampaign;
      }
    }
    return null;
  }

  async getAvailablePartyMembers(): Promise<Array<{ name: string; level: number; hp: number; ac: number }>> {
    const members: Array<{ name: string; level: number; hp: number; ac: number }> = [];

    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin?.data) return members;

      const party = this.resolveParty(initiativePlugin);
      if (!party?.players) return members;

      const players = this.getPartyPlayersFromParty(initiativePlugin, party, false);
      for (const player of players) {
        members.push({
          name: player.name || "Unknown",
          level: player.level || 1,
          hp: player.hp || player.currentMaxHP || 20,
          ac: player.ac || player.currentAC || 14
        });
      }
    } catch (error) {
      console.error("Error getting available party members:", error);
    }

    return members;
  }

  async getAvailableParties(): Promise<Array<{ id: string; name: string }>> {
    const parties: Array<{ id: string; name: string }> = [];

    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin?.data?.parties) return parties;

      for (const party of initiativePlugin.data.parties) {
        const id = party.id || party.name;
        const name = party.name || "Unnamed Party";
        parties.push({ id, name });
      }

      parties.sort((a, b) => a.name.localeCompare(b.name));
    } catch (error) {
      console.error("Error getting available parties:", error);
    }

    return parties;
  }

  async getResolvedParty(): Promise<{ id: string; name: string } | null> {
    const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
    if (!initiativePlugin?.data) return null;

    const party = this.resolveParty(initiativePlugin);
    if (!party) return null;

    return { id: party.id || party.name, name: party.name || "Unnamed Party" };
  }

  async getPartyForDifficulty(): Promise<Array<{ level: number; hp?: number; ac?: number }>> {
    if (!this.includeParty) return [];

    const partyMembers: Array<{ level: number; hp?: number; ac?: number }> = [];

    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin?.data) return partyMembers;

      const party = this.resolveParty(initiativePlugin);
      if (!party?.players) return partyMembers;

      const players = this.getPartyPlayersFromParty(initiativePlugin, party, true);
      for (const player of players) {
        partyMembers.push({
          level: player.level || 1,
          hp: player.hp || player.currentMaxHP,
          ac: player.ac || player.currentAC
        });
      }
    } catch (error) {
      console.error("Error getting party for difficulty:", error);
    }

    return partyMembers;
  }

  async getSelectedPartyPlayers(): Promise<any[]> {
    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin?.data) return [];

      const party = this.resolveParty(initiativePlugin);
      if (!party?.players) return [];

      return this.getPartyPlayersFromParty(initiativePlugin, party, true);
    } catch (error) {
      console.error("Error getting selected party players:", error);
      return [];
    }
  }

  resolveParty(initiativePlugin: any, campaignNameOverride?: string): any | null {
    const parties: any[] = initiativePlugin?.data?.parties || [];
    if (parties.length === 0) return null;

    if (this.selectedPartyId) {
      const selected = parties.find((p: any) => (p.id || p.name) === this.selectedPartyId);
      if (selected) return selected;
    }

    let campaignName = campaignNameOverride || "";
    
    // Use campaignPath if available (e.g., "ttrpgs/Frozen Sick (SOLINA)")
    if (!campaignName && this.campaignPath) {
      const pathParts = this.campaignPath.split('/');
      campaignName = pathParts[pathParts.length - 1] || "";
      console.log(`[EncounterBuilder] Using campaignPath to resolve party: "${campaignName}"`);
    }
    
    if (!campaignName) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        const campaignFolder = this.findCampaignFolder(activeFile.path);
        if (campaignFolder) {
          campaignName = campaignFolder.split('/').pop() || "";
          console.log(`[EncounterBuilder] Resolved campaign from active file: "${campaignName}"`);
        }
      }
    }

    if (campaignName) {
      const partyName = `${campaignName} Party`;
      console.log(`[EncounterBuilder] Looking for party: "${partyName}"`);
      const namedParty = parties.find((p: any) => p.name === partyName);
      if (namedParty) {
        console.log(`[EncounterBuilder] Found party: "${namedParty.name}" with ${namedParty.players?.length || 0} players`);
        return namedParty;
      } else {
        console.log(`[EncounterBuilder] Party "${partyName}" not found. Available parties:`, parties.map(p => p.name));
      }
    }

    if (initiativePlugin?.data?.defaultParty) {
      const defaultParty = parties.find((p: any) => p.id === initiativePlugin.data.defaultParty);
      if (defaultParty) {
        console.log(`[EncounterBuilder] Using default party: "${defaultParty.name}"`);
        return defaultParty;
      }
    }

    console.log(`[EncounterBuilder] No matching party found, using first available party`);
    return parties[0] || null;
  }

  getPartyPlayersFromParty(initiativePlugin: any, party: any, filterSelected = true): any[] {
    const players: any[] = initiativePlugin?.data?.players || [];
    const playerById = new Map(players.map(p => [p.id, p]));
    const playerByName = new Map(players.map(p => [p.name, p]));

    const selectedNames = filterSelected && this.selectedPartyMembers.length > 0
      ? new Set(this.selectedPartyMembers)
      : null;

    const results: any[] = [];
    for (const entry of party.players || []) {
      const player = playerById.get(entry) || playerByName.get(entry);
      if (!player) continue;
      if (selectedNames && !selectedNames.has(player.name)) continue;
      results.push(player);
    }

    return results;
  }

  getCRStats(cr: string | undefined): { hp: number; ac: number; dpr: number; attackBonus: number; xp: number } {
    // CR stats table from D&D 5e DMG
    const crTable: { [key: string]: { hp: number; ac: number; dpr: number; attackBonus: number; xp: number } } = {
      "0": { hp: 5, ac: 13, dpr: 1, attackBonus: 3, xp: 10 },
      "1/8": { hp: 10, ac: 13, dpr: 2, attackBonus: 3, xp: 25 },
      "1/4": { hp: 20, ac: 13, dpr: 3, attackBonus: 3, xp: 50 },
      "1/2": { hp: 35, ac: 13, dpr: 5, attackBonus: 3, xp: 100 },
      "1": { hp: 70, ac: 13, dpr: 8, attackBonus: 3, xp: 200 },
      "2": { hp: 85, ac: 13, dpr: 15, attackBonus: 3, xp: 450 },
      "3": { hp: 100, ac: 13, dpr: 21, attackBonus: 4, xp: 700 },
      "4": { hp: 115, ac: 14, dpr: 27, attackBonus: 5, xp: 1100 },
      "5": { hp: 130, ac: 15, dpr: 33, attackBonus: 6, xp: 1800 },
      "6": { hp: 145, ac: 15, dpr: 39, attackBonus: 6, xp: 2300 },
      "7": { hp: 160, ac: 15, dpr: 45, attackBonus: 6, xp: 2900 },
      "8": { hp: 175, ac: 16, dpr: 51, attackBonus: 7, xp: 3900 },
      "9": { hp: 190, ac: 16, dpr: 57, attackBonus: 7, xp: 5000 },
      "10": { hp: 205, ac: 17, dpr: 63, attackBonus: 7, xp: 5900 },
      "11": { hp: 220, ac: 17, dpr: 69, attackBonus: 7, xp: 7200 },
      "12": { hp: 235, ac: 17, dpr: 75, attackBonus: 8, xp: 8400 },
      "13": { hp: 250, ac: 18, dpr: 81, attackBonus: 8, xp: 10000 },
      "14": { hp: 265, ac: 18, dpr: 87, attackBonus: 8, xp: 11500 },
      "15": { hp: 280, ac: 18, dpr: 93, attackBonus: 8, xp: 13000 },
      "16": { hp: 295, ac: 18, dpr: 99, attackBonus: 9, xp: 15000 },
      "17": { hp: 310, ac: 19, dpr: 105, attackBonus: 10, xp: 18000 },
      "18": { hp: 325, ac: 19, dpr: 111, attackBonus: 10, xp: 20000 },
      "19": { hp: 340, ac: 19, dpr: 117, attackBonus: 10, xp: 22000 },
      "20": { hp: 355, ac: 19, dpr: 123, attackBonus: 10, xp: 25000 },
      "21": { hp: 400, ac: 19, dpr: 140, attackBonus: 11, xp: 33000 },
      "22": { hp: 450, ac: 19, dpr: 150, attackBonus: 11, xp: 41000 },
      "23": { hp: 500, ac: 19, dpr: 160, attackBonus: 11, xp: 50000 },
      "24": { hp: 550, ac: 19, dpr: 170, attackBonus: 12, xp: 62000 },
      "25": { hp: 600, ac: 19, dpr: 180, attackBonus: 12, xp: 75000 },
      "26": { hp: 650, ac: 19, dpr: 190, attackBonus: 12, xp: 90000 },
      "27": { hp: 700, ac: 19, dpr: 200, attackBonus: 13, xp: 105000 },
      "28": { hp: 750, ac: 19, dpr: 210, attackBonus: 13, xp: 120000 },
      "29": { hp: 800, ac: 19, dpr: 220, attackBonus: 13, xp: 135000 },
      "30": { hp: 850, ac: 19, dpr: 230, attackBonus: 14, xp: 155000 }
    };

    return crTable[cr || "1/4"] || crTable["1/4"]!;
  }

  getLevelStats(level: number): { hp: number; ac: number; dpr: number; attackBonus: number } {
    // Level-based stats from D&D 5e Player's Handbook averages
    // Updated DPR to be more realistic for actual play
    const baseHP = 8; // Average starting HP
    const hpPerLevel = 5; // Average HP gain per level
    const baseAC = 12;
    const acIncreaseInterval = 4; // AC increases every 4 levels
    const baseDPR = 8; // Starting DPR at level 1 (more realistic)
    const dprPerLevel = 2.5; // DPR increases more significantly per level
    const baseAttackBonus = 2;
    const proficiencyBonus = Math.floor((level - 1) / 4) + 2;

    return {
      hp: baseHP + hpPerLevel * (level - 1),
      ac: baseAC + Math.floor(level / acIncreaseInterval),
      dpr: baseDPR + dprPerLevel * (level - 1),
      attackBonus: baseAttackBonus + proficiencyBonus
    };
  }

  calculateHitChance(attackBonus: number, targetAC: number): number {
    const rollNeeded = Math.max(2, Math.min(20, targetAC - attackBonus));
    return Math.max(0.05, Math.min(0.95, (21 - rollNeeded) / 20));
  }

  calculateEffectiveDPR(baseDPR: number, hitChance: number): number {
    return baseDPR * hitChance;
  }

  calculateRoundsToDefeat(totalHP: number, effectiveDPR: number): number {
    if (effectiveDPR <= 0) return 999;
    return Math.max(1, Math.ceil(totalHP / effectiveDPR));
  }

  /**
   * Detect if trap effect text indicates area-of-effect (multiple targets)
   */
  detectAoETargets(effectText: string): number {
    if (!effectText) return 1;
    
    const text = effectText.toLowerCase();
    
    // Strong AoE indicators - likely hits all party members
    const strongAoE = [
      'each creature',
      'all creatures',
      'any creature',
      'creatures in the',
      'everyone in',
      'all targets',
      'each target',
      'all characters'
    ];
    
    for (const indicator of strongAoE) {
      if (text.includes(indicator)) {
        console.log(`[AoE Detection] Strong AoE indicator found: "${indicator}" - assuming 4 targets`);
        return 4; // Average party size
      }
    }
    
    // Area indicators with size
    const areaPatterns = [
      /(\d+)-foot (radius|cone|cube|line|sphere|cylinder)/,
      /(\d+)-foot.{0,20}(radius|cone|cube|line|sphere|cylinder)/,
      /within (\d+) feet/
    ];
    
    for (const pattern of areaPatterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        const size = parseInt(match[1]);
        // Estimate targets based on area size
        let targets = 1;
        if (size >= 30) targets = 4; // Large area
        else if (size >= 20) targets = 3; // Medium area
        else if (size >= 10) targets = 2; // Small area
        console.log(`[AoE Detection] ${size}-foot area detected - assuming ${targets} targets`);
        return targets;
      }
    }
    
    // Moderate AoE indicators - likely hits 2-3 characters
    const moderateAoE = [
      'creatures within',
      'multiple targets',
      'targets within',
      'nearby creatures',
      'adjacent creatures'
    ];
    
    for (const indicator of moderateAoE) {
      if (text.includes(indicator)) {
        console.log(`[AoE Detection] Moderate AoE indicator found: "${indicator}" - assuming 2 targets`);
        return 2;
      }
    }
    
    // Single target indicators
    const singleTarget = [
      'one target',
      'one creature',
      'single target',
      'the target',
      'a target'
    ];
    
    for (const indicator of singleTarget) {
      if (text.includes(indicator)) {
        console.log(`[AoE Detection] Single target indicator found: "${indicator}"`);
        return 1;
      }
    }
    
    // No clear indicators - check if it mentions targeting at all
    if (text.includes('target') || text.includes('creature')) {
      console.log(`[AoE Detection] Generic targeting text - assuming 2 targets (conservative)`);
      return 2; // Conservative estimate for unclear traps
    }
    
    console.log(`[AoE Detection] No targeting indicators - assuming 1 target`);
    return 1;
  }

  /**
   * Calculate trap stats for encounter difficulty
   * Traps are treated as hostile entities that deal damage but have different mechanics
   */
  calculateTrapStats(trapData: {
    elements: TrapElement[];
    threatLevel: 'setback' | 'dangerous' | 'deadly';
    trapType: 'simple' | 'complex';
  }): { hp: number; ac: number; dpr: number; attackBonus: number; cr: string } {
    
    console.log(`[Trap Stats] Starting calculation for ${trapData.trapType} trap, threat: ${trapData.threatLevel}`);
    console.log(`[Trap Stats] Elements count: ${trapData.elements?.length || 0}`);
    
    let totalDamage = 0;
    let maxDC = 0;
    let maxAttackBonus = 0;
    let elementCount = 0;
    let maxAoETargets = 1;

    // Parse damage from each element and detect AoE
    for (const element of trapData.elements) {
      console.log(`[Trap Stats] Processing element: ${element.name}`);
      
      if (element.damage) {
        const avgDamage = this.parseTrapDamage(element.damage);
        console.log(`[Trap Stats] - Damage: ${element.damage} ‚Üí ${avgDamage} avg`);
        totalDamage += avgDamage;
        elementCount++;
      }

      if (element.additional_damage) {
        const additionalDmg = this.parseTrapDamage(element.additional_damage);
        console.log(`[Trap Stats] - Additional damage: ${element.additional_damage} ‚Üí ${additionalDmg} avg`);
        totalDamage += additionalDmg;
      }

      if (element.save_dc && element.save_dc > maxDC) {
        maxDC = element.save_dc;
        console.log(`[Trap Stats] - Save DC: ${element.save_dc}`);
      }

      if (element.attack_bonus && element.attack_bonus > maxAttackBonus) {
        maxAttackBonus = element.attack_bonus;
        console.log(`[Trap Stats] - Attack bonus: ${element.attack_bonus}`);
      }
      
      // Check for AoE indicators in effect text
      if (element.effect) {
        console.log(`[Trap Stats] - Effect text: ${element.effect.substring(0, Math.min(100, element.effect.length))}...`);
        const targets = this.detectAoETargets(element.effect);
        if (targets > maxAoETargets) {
          maxAoETargets = targets;
        }
      } else {
        console.log(`[Trap Stats] - No effect text found`);
      }
    }

    // Calculate DPR (damage per round)
    // All trap elements deal their full damage (even if on different initiatives)
    // Complex traps with multiple initiatives create sustained threat, not reduced damage
    let dpr = totalDamage;

    // Multiply DPR by number of targets for AoE traps
    if (maxAoETargets > 1) {
      console.log(`[Trap Stats] AoE trap detected - multiplying DPR by ${maxAoETargets} targets`);
      dpr *= maxAoETargets;
    }

    // Apply threat level modifier to DPR
    if (trapData.threatLevel === 'dangerous') {
      dpr *= 1.25;
    } else if (trapData.threatLevel === 'deadly') {
      dpr *= 1.5;
    } else if (trapData.threatLevel === 'setback') {
      dpr *= 0.75;
    }

    // Determine attack bonus or save DC for hit chance calculation
    // Prefer attack bonus if present, otherwise derive from save DC
    const attackBonus = maxAttackBonus > 0 
      ? maxAttackBonus 
      : maxDC > 0 
        ? Math.floor((maxDC - 8) / 0.8) // Approximate attack bonus from DC
        : 5; // Default moderate attack bonus

    // Traps have high AC (hard to damage) but can be disabled
    // AC 15-20 depending on complexity and threat level
    let ac = 15;
    if (trapData.trapType === 'complex') ac += 2;
    if (trapData.threatLevel === 'dangerous') ac += 1;
    if (trapData.threatLevel === 'deadly') ac += 2;

    // Traps have limited HP (they're not creatures)
    // HP represents how much effort to disable/destroy
    // Base HP is proportional to DPR and threat level
    let hp = Math.max(1, Math.floor(dpr * 2));
    if (trapData.threatLevel === 'dangerous') hp *= 1.5;
    if (trapData.threatLevel === 'deadly') hp *= 2;

    // Estimate CR based on DPR
    let estimatedCR = this.estimateCRFromDPR(dpr);
    
    // Adjust CR based on save DC or attack bonus
    if (maxDC > 0 || maxAttackBonus > 0) {
      const dcOrAttack = maxDC > 0 ? maxDC : maxAttackBonus;
      const crByDC = this.estimateCRFromDC(dcOrAttack);
      estimatedCR = Math.round((estimatedCR + crByDC) / 2);
    }

    const crString = this.formatCR(estimatedCR);

    console.log(`[Trap Stats] Base Damage: ${totalDamage}, AoE Targets: ${maxAoETargets}, DPR: ${dpr.toFixed(1)}, AC: ${ac}, HP: ${hp}, Attack: ${attackBonus}, CR: ${crString}`);

    return {
      hp,
      ac,
      dpr,
      attackBonus,
      cr: crString
    };
  }

  /**
   * Parse trap damage string to average damage value
   * Examples: "4d10" -> 22, "2d6+3" -> 10, "45" -> 45
   */
  parseTrapDamage(damageStr: string | undefined): number {
    if (!damageStr) return 0;
    
    console.log(`[Damage Parser] Input: "${damageStr}"`);
    
    let cleanDamage = damageStr.trim().toLowerCase();
    
    // Remove damage type (e.g., "4d10 fire" -> "4d10")
    const parts = cleanDamage.split(' ');
    cleanDamage = parts[0] || cleanDamage;
    console.log(`[Damage Parser] After cleanup: "${cleanDamage}"`);

    // Parse dice notation FIRST: XdY+Z or XdY-Z or XdY
    const diceMatch = cleanDamage.match(/(\d+)d(\d+)([+-]\d+)?/);
    if (diceMatch) {
      const numDice = parseInt(diceMatch[1]!);
      const dieSize = parseInt(diceMatch[2]!);
      const modifier = diceMatch[3] ? parseInt(diceMatch[3]) : 0;
      
      // Average of XdY is X * (Y+1)/2
      const avgRoll = numDice * (dieSize + 1) / 2;
      const total = Math.floor(avgRoll + modifier);
      console.log(`[Damage Parser] Dice: ${numDice}d${dieSize}${modifier >= 0 ? '+' : ''}${modifier || ''} = ${avgRoll} + ${modifier} = ${total}`);
      return total;
    }

    // Check if it's just a number (static damage)
    const staticDamage = parseInt(cleanDamage);
    if (!isNaN(staticDamage)) {
      console.log(`[Damage Parser] Parsed as static damage: ${staticDamage}`);
      return staticDamage;
    }

    console.log(`[Damage Parser] No match, returning 0`);
    return 0;
  }

  /**
   * Estimate CR from DPR using D&D 5e CR table
   */
  estimateCRFromDPR(dpr: number): number {
    const crDPRTable = [
      { cr: 0, dpr: 1 },
      { cr: 0.125, dpr: 2 },
      { cr: 0.25, dpr: 3 },
      { cr: 0.5, dpr: 5 },
      { cr: 1, dpr: 8 },
      { cr: 2, dpr: 15 },
      { cr: 3, dpr: 21 },
      { cr: 4, dpr: 27 },
      { cr: 5, dpr: 33 },
      { cr: 6, dpr: 39 },
      { cr: 7, dpr: 45 },
      { cr: 8, dpr: 51 },
      { cr: 9, dpr: 57 },
      { cr: 10, dpr: 63 },
      { cr: 11, dpr: 69 },
      { cr: 12, dpr: 75 },
      { cr: 13, dpr: 81 },
      { cr: 14, dpr: 87 },
      { cr: 15, dpr: 93 },
      { cr: 16, dpr: 99 },
      { cr: 17, dpr: 105 },
      { cr: 18, dpr: 111 },
      { cr: 19, dpr: 117 },
      { cr: 20, dpr: 123 }
    ];

    let closestCR = 0;
    let minDiff = Infinity;

    for (const entry of crDPRTable) {
      const diff = Math.abs(entry.dpr - dpr);
      if (diff < minDiff) {
        minDiff = diff;
        closestCR = entry.cr;
      }
    }

    return closestCR;
  }

  /**
   * Estimate CR from save DC or attack bonus
   */
  estimateCRFromDC(dc: number): number {
    const crDCTable = [
      { cr: 0, dc: 13 },
      { cr: 1, dc: 13 },
      { cr: 2, dc: 13 },
      { cr: 3, dc: 13 },
      { cr: 4, dc: 14 },
      { cr: 5, dc: 15 },
      { cr: 8, dc: 16 },
      { cr: 11, dc: 17 },
      { cr: 13, dc: 18 },
      { cr: 17, dc: 19 },
      { cr: 21, dc: 20 },
      { cr: 24, dc: 21 },
      { cr: 27, dc: 22 },
      { cr: 29, dc: 23 },
      { cr: 30, dc: 24 }
    ];

    let closestCR = 0;
    let minDiff = Infinity;

    for (const entry of crDCTable) {
      const diff = Math.abs(entry.dc - dc);
      if (diff < minDiff) {
        minDiff = diff;
        closestCR = entry.cr;
      }
    }

    return closestCR;
  }

  /**
   * Format CR as string (handles fractional CRs)
   */
  formatCR(cr: number): string {
    if (cr === 0.125) return "1/8";
    if (cr === 0.25) return "1/4";
    if (cr === 0.5) return "1/2";
    return cr.toString();
  }

  /**
   * Parse statblock YAML to extract real combat stats
   * Returns hp, ac, dpr (damage per round), and attackBonus
   */
  async parseStatblockStats(filePath: string): Promise<{ hp: number; ac: number; dpr: number; attackBonus: number } | null> {
    try {
      console.log(`[Parser] Reading file: ${filePath}`);
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof TFile)) {
        console.log(`[Parser] File not found or not a TFile`);
        return null;
      }

      const cache = this.app.metadataCache.getFileCache(file);
      if (!cache?.frontmatter) {
        console.log(`[Parser] No frontmatter found`);
        return null;
      }

      const fm = cache.frontmatter;
      console.log(`[Parser] Frontmatter keys:`, Object.keys(fm));
      
      // Extract basic stats
      const hp = this.parseHP(fm.hp);
      const ac = this.parseAC(fm.ac);
      console.log(`[Parser] Parsed HP: ${hp}, AC: ${ac}`);
      
      // Calculate DPR and attack bonus from actions
      let totalDPR = 0;
      let highestAttackBonus = 0;
      let attackCount = 0;
      
      // Check for actions array (where attacks are defined)
      if (fm.actions && Array.isArray(fm.actions)) {
        console.log(`[Parser] Found ${fm.actions.length} actions`);
        
        for (const action of fm.actions) {
          if (!action.name) continue;
          console.log(`[Parser] Action: "${action.name}"`);
          
          // === CHECK STRUCTURED FIELDS FIRST ===
          let actionDPR = 0;
          let actionAttackBonus = 0;
          let usedStructuredData = false;
          
          // Check for attack_bonus field
          if (typeof action.attack_bonus === 'number') {
            actionAttackBonus = action.attack_bonus;
            if (actionAttackBonus > highestAttackBonus) {
              highestAttackBonus = actionAttackBonus;
            }
            console.log(`[Parser] Found structured attack_bonus: ${actionAttackBonus}`);
            usedStructuredData = true;
          }
          
          // Check for damage_dice and damage_bonus fields
          if (action.damage_dice || action.damage_bonus) {
            console.log(`[Parser] Found structured damage fields: dice="${action.damage_dice}", bonus="${action.damage_bonus}"`);
            
            // Parse damage_dice (e.g., "1d6" or "2d8")
            let diceDamage = 0;
            if (action.damage_dice && typeof action.damage_dice === 'string') {
              const diceMatch = action.damage_dice.match(/(\d+)d(\d+)/i);
              if (diceMatch) {
                const numDice = parseInt(diceMatch[1]);
                const dieSize = parseInt(diceMatch[2]);
                diceDamage = numDice * ((dieSize + 1) / 2); // Average of dice
                console.log(`[Parser] Calculated dice damage: ${numDice}d${dieSize} = ${diceDamage}`);
              }
            }
            
            // Add damage bonus
            let damageBonus = 0;
            if (typeof action.damage_bonus === 'number') {
              damageBonus = action.damage_bonus;
            } else if (typeof action.damage_bonus === 'string') {
              damageBonus = parseInt(action.damage_bonus) || 0;
            }
            
            actionDPR = diceDamage + damageBonus;
            console.log(`[Parser] Calculated structured damage: ${diceDamage} + ${damageBonus} = ${actionDPR}`);
            
            if (actionDPR > 0) {
              totalDPR += actionDPR;
              attackCount++;
              usedStructuredData = true;
            }
          }
          
          // If we successfully used structured data, skip text parsing for this action
          if (usedStructuredData) {
            console.log(`[Parser] Used structured data for ${action.name}, DPR=${actionDPR}, Attack=${actionAttackBonus}`);
            continue;
          }
          
          // === FALLBACK TO TEXT PARSING ===
          if (action.desc && typeof action.desc === 'string') {
            const desc = action.desc;
            console.log(`[Parser] Description: ${desc.substring(0, 100)}...`);
            
            // Look for attack bonus
            const attackMatch = desc.match(/[+\-]\d+\s+to\s+hit/i);
            if (attackMatch) {
              const bonusMatch = attackMatch[0].match(/[+\-]\d+/);
              if (bonusMatch) {
                attackCount++;
                const bonus = parseInt(bonusMatch[0]);
                console.log(`[Parser] Found attack bonus: ${bonus}`);
                if (bonus > highestAttackBonus) highestAttackBonus = bonus;
              }
            }
            
            // Look for damage
            let damageFound = false;
            const avgDamageMatch = desc.match(/(\d+)\s*\((\d+)d(\d+)\s*([+\-]?\s*\d+)?\)/i);
            if (avgDamageMatch) {
              const avgDamage = parseInt(avgDamageMatch[1]);
              console.log(`[Parser] Found pre-calculated damage: ${avgDamage}`);
              totalDPR += avgDamage;
              damageFound = true;
              if (!attackMatch) attackCount++;
            } else {
              const diceMatch = desc.match(/(\d+)d(\d+)\s*([+\-]?\s*\d+)?/i);
              if (diceMatch) {
                if (!attackMatch) attackCount++;
                const numDice = parseInt(diceMatch[1]);
                const dieSize = parseInt(diceMatch[2]);
                const modifier = diceMatch[3] ? parseInt(diceMatch[3].replace(/\s/g, '')) : 0;
                const avgDamage = Math.floor(numDice * (dieSize + 1) / 2) + modifier;
                console.log(`[Parser] Calculated damage from ${diceMatch[0]}: ${avgDamage}`);
                totalDPR += avgDamage;
                damageFound = true;
              }
            }
            
            if (!damageFound) {
              console.log(`[Parser] No damage found in action`);
            }
          }
        }
      } else {
        console.log(`[Parser] No actions array found`);
      }
      
      console.log(`[Parser] Total DPR before multiattack: ${totalDPR}`);
      
      // Check for multiattack
      let multiattackMultiplier = 1;
      if (fm.actions && Array.isArray(fm.actions)) {
        const multiattack = fm.actions.find((a: any) => 
          a.name && a.name.toLowerCase().includes('multiattack')
        );
        
        if (multiattack?.desc) {
          console.log(`[Parser] Multiattack found: ${multiattack.desc}`);
          const countMatch = multiattack.desc.match(/makes?\s+(two|three|four|five|\d+)\s+.*?attack/i);
          if (countMatch) {
            const countStr = countMatch[1].toLowerCase();
            const countMap: Record<string, number> = { 'two': 2, 'three': 3, 'four': 4, 'five': 5 };
            multiattackMultiplier = countMap[countStr] || parseInt(countStr) || 1;
            console.log(`[Parser] Multiattack multiplier: ${multiattackMultiplier}`);
          }
        }
      }
      
      // Apply multiattack multiplier
      if (totalDPR > 0 && multiattackMultiplier > 1) {
        console.log(`[Parser] Applying multiattack multiplier ${multiattackMultiplier} to DPR ${totalDPR}`);
        totalDPR *= multiattackMultiplier;
        console.log(`[Parser] Final DPR after multiattack: ${totalDPR}`);
      }
      
      // If we couldn't parse DPR, return null to fall back to CR estimates
      if (totalDPR === 0) {
        console.log(`[Parser] No DPR found, returning null to use CR estimates`);
        return null;
      }
      
      // Use a reasonable default attack bonus if we couldn't parse it
      if (highestAttackBonus === 0) {
        highestAttackBonus = Math.max(2, Math.floor(totalDPR / 5));
        console.log(`[Parser] No attack bonus found, estimating ${highestAttackBonus} based on DPR`);
      }
      
      const result = {
        hp: hp || 1,
        ac: ac || 10,
        dpr: totalDPR,
        attackBonus: highestAttackBonus
      };
      console.log(`[Parser] SUCCESS: Returning`, result);
      return result;
    } catch (error) {
      console.error("[Parser] Error parsing statblock:", filePath, error);
      return null;
    }
  }

  /**
   * Parse HP from various formats: "45 (6d10+12)" or just "45"
   */
  parseHP(hpStr: any): number {
    if (typeof hpStr === 'number') return hpStr;
    if (typeof hpStr !== 'string') return 0;
    
    const match = hpStr.match(/^(\d+)/);
    return match && match[1] ? parseInt(match[1]) : 0;
  }

  /**
   * Parse AC from various formats: "13 (natural armor)" or just "13" or number
   */
  parseAC(acStr: any): number {
    if (typeof acStr === 'number') return acStr;
    if (typeof acStr !== 'string') return 10;
    
    const match = acStr.match(/^(\d+)/);
    return match && match[1] ? parseInt(match[1]) : 10;
  }

  /**
   * Consolidate trap elements (creatures with [SRD] path and initiative numbers)
   * into single trap entities with trapData loaded from trap files
   */
  async consolidateTrapElements(): Promise<void> {
    const trapGroups = new Map<string, any[]>();
    const nonTraps: any[] = [];
    
    // Group creatures by trap name (before the "Initiative" part)
    for (const creature of this.creatures) {
      // Check if this looks like a trap element: has [SRD] path and name with "Initiative"
      if (creature.path === "[SRD]" && creature.name.includes("(Initiative")) {
        const baseName = creature.name.replace(/\s*\(Initiative\s+\d+\)/, '').trim();
        if (!trapGroups.has(baseName)) {
          trapGroups.set(baseName, []);
        }
        trapGroups.get(baseName)!.push(creature);
      } else if (!creature.isTrap) {
        // Keep non-trap creatures as-is
        nonTraps.push(creature);
      } else {
        // Already a proper trap with trapData
        nonTraps.push(creature);
      }
    }
    
    // Find and load trap files for each trap group
    const consolidatedTraps: any[] = [];
    for (const [trapName, elements] of trapGroups.entries()) {
      console.log(`ü™§ Consolidating trap: ${trapName} (${elements.length} elements)`);
      
      // Search for the trap file
      let trapFile: TFile | null = null;
      for (const file of this.app.vault.getMarkdownFiles()) {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache?.frontmatter?.type === 'trap' && 
            (cache.frontmatter.trap_name === trapName || file.basename === trapName)) {
          trapFile = file;
          break;
        }
      }
      
      if (trapFile) {
        try {
          const trapCache = this.app.metadataCache.getFileCache(trapFile);
          if (trapCache?.frontmatter) {
            const fm = trapCache.frontmatter;
            const consolidatedTrap = {
              name: trapName,
              count: 1,
              isTrap: true,
              trapData: {
                trapType: fm.trap_type || "complex",
                threatLevel: fm.threat_level || "dangerous",
                elements: fm.elements || []
              },
              // Preserve manual overrides from first element if any
              hp: elements[0].hp,
              ac: elements[0].ac,
              cr: elements[0].cr,
              path: trapFile.path
            };
            consolidatedTraps.push(consolidatedTrap);
            console.log(`‚úÖ Consolidated ${trapName} from ${elements.length} elements`);
          }
        } catch (error) {
          console.error(`Error loading trap file for ${trapName}:`, error);
          // If we can't load the trap, keep the elements as regular creatures
          nonTraps.push(...elements);
        }
      } else {
        console.warn(`‚ö†Ô∏è No trap file found for ${trapName}, keeping as separate creatures`);
        nonTraps.push(...elements);
      }
    }
    
    // Replace creatures array with consolidated version
    this.creatures = [...nonTraps, ...consolidatedTraps];
    console.log(`üìä Consolidated ${trapGroups.size} traps, ${nonTraps.length} other creatures`);
  }

  async calculateEncounterDifficulty(): Promise<any> {
    // First, consolidate any trap elements
    await this.consolidateTrapElements();
    
    // Calculate enemy stats with real statblock data when available
    let enemyTotalHP = 0;
    let enemyTotalAC = 0;
    let enemyTotalDPR = 0;
    let enemyTotalAttackBonus = 0;
    let enemyCount = 0;
    
    // Track friendly creatures to add to party
    let friendlyTotalHP = 0;
    let friendlyTotalAC = 0;
    let friendlyTotalDPR = 0;
    let friendlyTotalAttackBonus = 0;
    let friendlyCount = 0;
    
    console.log("=== ENCOUNTER DIFFICULTY CALCULATION (EncounterBuilder) ===");
    
    for (const creature of this.creatures) {
      const count = creature.count || 1;
      
      console.log(`\n--- Creature: ${creature.name} (x${count}) ---`);
      console.log(`Path: ${creature.path || 'none'}`);
      console.log(`CR: ${creature.cr || 'unknown'}`);
      console.log(`Is Trap: ${creature.isTrap || false}`);
      console.log(`Is Friendly: ${creature.isFriendly || false}`);
      
      // Handle friendly creatures - add them to the party side
      if (creature.isFriendly) {
        console.log(`ü§ù FRIENDLY CREATURE - Adding to party stats`);
        
        // Get stats for friendly creature (same logic as enemies)
        let realStats = null;
        if (creature.path && typeof creature.path === 'string') {
          console.log(`Attempting to parse statblock: ${creature.path}`);
          realStats = await this.parseStatblockStats(creature.path);
          console.log(`Parsed stats:`, realStats);
        }
        
        const crStats = this.getCRStats(creature.cr);
        const hp = creature.hp || realStats?.hp || crStats.hp;
        const ac = creature.ac || realStats?.ac || crStats.ac;
        const dpr = realStats?.dpr || crStats.dpr;
        const attackBonus = realStats?.attackBonus || crStats.attackBonus;
        
        console.log(`Friendly stats: HP=${hp}, AC=${ac}, DPR=${dpr}, Attack=${attackBonus}`);
        console.log(`Total contribution (x${count}): HP=${hp * count}, DPR=${dpr * count}`);
        
        friendlyTotalHP += hp * count;
        friendlyTotalAC += ac * count;
        friendlyTotalDPR += dpr * count;
        friendlyTotalAttackBonus += attackBonus * count;
        friendlyCount += count;
        continue;
      }
      
      // Handle traps differently from creatures
      if (creature.isTrap && creature.trapData) {
        console.log(`ü™§ TRAP DETECTED - Using trap-specific calculation`);
        const trapStats = await this.calculateTrapStats(creature.trapData);
        console.log(`Trap stats:`, trapStats);
        
        const hp = trapStats.hp;
        const ac = trapStats.ac;
        const dpr = trapStats.dpr;
        const attackBonus = trapStats.attackBonus;
        
        console.log(`Final trap stats: HP=${hp}, AC=${ac}, DPR=${dpr}, Attack=${attackBonus}, Effective CR=${trapStats.cr}`);
        console.log(`Total contribution (x${count}): HP=0 (traps don't contribute to HP pool), DPR=${dpr * count}`);
        
        // Traps don't add to HP pool (they're hazards, not damage sponges)
        // But they DO contribute DPR, AC (for difficulty calculation), and count as threats
        enemyTotalAC += ac * count;
        enemyTotalDPR += dpr * count;
        enemyTotalAttackBonus += attackBonus * count;
        enemyCount += count;
        continue;
      }
      
      // Try to get real stats from statblock if available
      let realStats = null;
      if (creature.path && typeof creature.path === 'string') {
        console.log(`Attempting to parse statblock: ${creature.path}`);
        realStats = await this.parseStatblockStats(creature.path);
        console.log(`Parsed stats:`, realStats);
      } else {
        console.log(`No valid path, using CR estimates`);
      }
      
      // Fall back to CR-based estimates if no statblock or parsing failed
      const crStats = this.getCRStats(creature.cr);
      console.log(`CR-based fallback stats:`, crStats);
      
      const hp = creature.hp || realStats?.hp || crStats.hp;
      const ac = creature.ac || realStats?.ac || crStats.ac;
      const dpr = realStats?.dpr || crStats.dpr;
      const attackBonus = realStats?.attackBonus || crStats.attackBonus;
      
      const dprSource = realStats?.dpr ? 'üìä STATBLOCK' : 'üìñ CR_TABLE';
      const hpSource = realStats?.hp ? 'üìä STATBLOCK' : creature.hp ? '‚úèÔ∏è MANUAL' : 'üìñ CR_TABLE';
      const acSource = realStats?.ac ? 'üìä STATBLOCK' : creature.ac ? '‚úèÔ∏è MANUAL' : 'üìñ CR_TABLE';
      
      console.log(`Final stats used: HP=${hp} (${hpSource}), AC=${ac} (${acSource}), DPR=${dpr} (${dprSource}), Attack=${attackBonus}`);
      console.log(`Total contribution (x${count}): HP=${hp * count}, DPR=${dpr * count}`);

      enemyTotalHP += hp * count;
      enemyTotalAC += ac * count;
      enemyTotalDPR += dpr * count;
      enemyTotalAttackBonus += attackBonus * count;
      enemyCount += count;
    }
    
    console.log(`\n=== TOTALS ===`);
    console.log(`Total Enemies: ${enemyCount}`);
    console.log(`Total Enemy HP: ${enemyTotalHP}`);
    console.log(`Total Enemy DPR: ${enemyTotalDPR}`);
    console.log(`Average Enemy AC: ${enemyCount > 0 ? (enemyTotalAC / enemyCount).toFixed(1) : 0}`);
    console.log(`Average Enemy Attack Bonus: ${enemyCount > 0 ? (enemyTotalAttackBonus / enemyCount).toFixed(1) : 0}`)

    const avgEnemyAC = enemyCount > 0 ? enemyTotalAC / enemyCount : 13;
    const avgEnemyAttackBonus = enemyCount > 0 ? enemyTotalAttackBonus / enemyCount : 3;

    // Get party stats
    const partyMembers = await this.getPartyForDifficulty();

    let partyTotalHP = 0;
    let partyTotalAC = 0;
    let partyTotalDPR = 0;
    let partyTotalAttackBonus = 0;
    let totalLevel = 0;

    for (const member of partyMembers) {
      const levelStats = this.getLevelStats(member.level);

      const memberHP = Number(member.hp) || 0;
      const memberAC = Number(member.ac) || 0;

      partyTotalHP += memberHP > 0 ? memberHP : levelStats.hp;
      partyTotalAC += memberAC > 0 ? memberAC : levelStats.ac;
      partyTotalDPR += levelStats.dpr;
      partyTotalAttackBonus += levelStats.attackBonus;
      totalLevel += member.level;
    }
    
    // Add friendly creatures to party totals
    console.log(`\n=== ADDING FRIENDLY CREATURES TO PARTY ===`);
    console.log(`Friendly creatures: ${friendlyCount}`);
    console.log(`Friendly HP contribution: ${friendlyTotalHP}`);
    console.log(`Friendly DPR contribution: ${friendlyTotalDPR}`);
    
    partyTotalHP += friendlyTotalHP;
    partyTotalAC += friendlyTotalAC;
    partyTotalDPR += friendlyTotalDPR;
    partyTotalAttackBonus += friendlyTotalAttackBonus;

    const memberCount = partyMembers.length + friendlyCount;
    const pcMemberCount = partyMembers.length;

    let avgPartyAC: number;
    let avgPartyAttackBonus: number;
    let avgLevel: number;

    if (memberCount > 0) {
      avgPartyAC = partyTotalAC / memberCount;
      avgPartyAttackBonus = partyTotalAttackBonus / memberCount;
      avgLevel = pcMemberCount > 0 ? totalLevel / pcMemberCount : 3;
    } else {
      const defaultStats = this.getLevelStats(3);
      partyTotalHP = defaultStats.hp * 4;
      partyTotalDPR = defaultStats.dpr * 4;
      avgPartyAC = defaultStats.ac;
      avgPartyAttackBonus = defaultStats.attackBonus;
      avgLevel = 3;
    }

    // Calculate hit chances
    const partyHitChance = this.calculateHitChance(avgPartyAttackBonus, avgEnemyAC);
    const enemyHitChance = this.calculateHitChance(avgEnemyAttackBonus, avgPartyAC);

    // Calculate effective DPR
    const partyEffectiveDPR = this.calculateEffectiveDPR(partyTotalDPR, partyHitChance);
    const enemyEffectiveDPR = this.calculateEffectiveDPR(enemyTotalDPR, enemyHitChance);

    // Calculate rounds to defeat
    const roundsToDefeatEnemies = this.calculateRoundsToDefeat(enemyTotalHP, partyEffectiveDPR);
    const roundsToDefeatParty = this.calculateRoundsToDefeat(partyTotalHP, enemyEffectiveDPR);

    // Survival ratio
    const survivalRatio = roundsToDefeatParty / roundsToDefeatEnemies;

    // Determine difficulty
    let difficulty: string;
    let difficultyColor: string;

    if (survivalRatio >= 4 || roundsToDefeatEnemies <= 1) {
      difficulty = "Trivial";
      difficultyColor = "#888888";
    } else if (survivalRatio >= 2.5) {
      difficulty = "Easy";
      difficultyColor = "#00aa00";
    } else if (survivalRatio >= 1.5) {
      difficulty = "Medium";
      difficultyColor = "#aaaa00";
    } else if (survivalRatio >= 1.0) {
      difficulty = "Hard";
      difficultyColor = "#ff8800";
    } else if (survivalRatio >= 0.6) {
      difficulty = "Deadly";
      difficultyColor = "#ff0000";
    } else {
      difficulty = "TPK Risk";
      difficultyColor = "#880000";
    }

    // Generate summary
    let summary = "";
    if (partyMembers.length === 0 && friendlyCount === 0) {
      summary = `‚ö†Ô∏è No party found. Using default 4-player party (Level 3).\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}.`;
    } else {
      const partyText = pcMemberCount > 0 ? `${pcMemberCount} PC${pcMemberCount !== 1 ? 's' : ''}` : '';
      const friendlyText = friendlyCount > 0 ? `${friendlyCount} friendly creature${friendlyCount !== 1 ? 's' : ''}` : '';
      const combatants = [partyText, friendlyText].filter(t => t).join(' + ');
      
      summary = `Party: ${combatants}`;
      if (pcMemberCount > 0) {
        summary += ` (Avg Level ${avgLevel.toFixed(1)})`;
      }
      summary += `\n`;
      summary += `Enemies: ${enemyCount} creatures\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}`;
    }

    return {
      enemyStats: {
        totalHP: enemyTotalHP,
        avgAC: avgEnemyAC,
        totalDPR: enemyTotalDPR,
        avgAttackBonus: avgEnemyAttackBonus,
        creatureCount: enemyCount
      },
      partyStats: {
        totalHP: partyTotalHP,
        avgAC: avgPartyAC,
        totalDPR: partyTotalDPR,
        avgAttackBonus: avgPartyAttackBonus,
        memberCount: memberCount,
        avgLevel: avgLevel
      },
      analysis: {
        partyHitChance,
        enemyHitChance,
        partyEffectiveDPR,
        enemyEffectiveDPR,
        roundsToDefeatEnemies,
        roundsToDefeatParty,
        survivalRatio,
        difficulty,
        difficultyColor,
        summary
      }
    };
  }

  async searchVaultCreatures(query: string): Promise<Array<{ name: string; path: string; hp: number; ac: number; cr?: string }>> {
    const creatures: Array<{ name: string; path: string; hp: number; ac: number; cr?: string }> = [];

    // Check multiple possible creature/monster folder locations
    const possiblePaths = [
      "z_Beastiarity",
      "My Vault/z_Beastiarity",
      "nvdh-ttrpg-vault/monsters",
      "monsters"
    ];

    const beastiaryFolders: TFolder[] = [];
    for (const path of possiblePaths) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder instanceof TFolder) {
        beastiaryFolders.push(folder);
      }
    }

    if (beastiaryFolders.length === 0) return creatures;

    const queryLower = query.toLowerCase();

    // Recursively search all files in beastiary
    const searchFolder = async (folder: TFolder) => {
      for (const child of folder.children) {
        if (child instanceof TFile && child.extension === "md") {
          try {
            const cache = this.app.metadataCache.getFileCache(child);

            // Check if file has statblock
            if (cache?.frontmatter && cache.frontmatter.statblock === true) {
              const name = cache.frontmatter.name || child.basename;

              // Filter by query
              if (!query || name.toLowerCase().includes(queryLower)) {
                creatures.push({
                  name: name,
                  path: child.path,
                  hp: cache.frontmatter.hp || 1,
                  ac: cache.frontmatter.ac || 10,
                  cr: cache.frontmatter.cr?.toString() || undefined
                });
              }
            }
          } catch (error) {
            console.error(`Error reading creature file ${child.path}:`, error);
          }
        } else if (child instanceof TFolder) {
          await searchFolder(child);
        }
      }
    };

    // Search all found beastiary folders
    for (const folder of beastiaryFolders) {
      await searchFolder(folder);
    }

    // Sort alphabetically
    creatures.sort((a, b) => a.name.localeCompare(b.name));

    return creatures;
  }

  async loadAllCreatures(): Promise<Array<{ name: string; path: string; hp: number; ac: number; cr?: string }>> {
    const vaultCreatures = await this.searchVaultCreatures("");
    const statblocksCreatures = await this.getStatblocksPluginCreatures();

    // Merge and deduplicate by name (vault takes priority)
    const allCreatures = [...vaultCreatures];
    const vaultNames = new Set(vaultCreatures.map(c => c.name.toLowerCase()));

    for (const creature of statblocksCreatures) {
      if (!vaultNames.has(creature.name.toLowerCase())) {
        allCreatures.push(creature);
      }
    }

    // Sort alphabetically
    allCreatures.sort((a, b) => a.name.localeCompare(b.name));

    return allCreatures;
  }

  async getStatblocksPluginCreatures(): Promise<Array<{ name: string; path: string; hp: number; ac: number; cr?: string }>> {
    const creatures: Array<{ name: string; path: string; hp: number; ac: number; cr?: string }> = [];

    try {
      const statblocksPlugin = (this.app as any).plugins?.plugins?.["obsidian-5e-statblocks"];
      if (!statblocksPlugin) {
        console.log("5e Statblocks plugin not found");
        return creatures;
      }

      let bestiaryCreatures: any[] = [];

      if (statblocksPlugin.api?.getBestiaryCreatures) {
        const apiCreatures = statblocksPlugin.api.getBestiaryCreatures();
        if (Array.isArray(apiCreatures)) {
          bestiaryCreatures = apiCreatures;
        }
      }

      if (bestiaryCreatures.length === 0 && statblocksPlugin.data?.monsters) {
        const monstersData = statblocksPlugin.data.monsters;
        if (Array.isArray(monstersData)) {
          bestiaryCreatures = monstersData;
        } else if (typeof monstersData === "object") {
          bestiaryCreatures = Object.values(monstersData);
        }
      }

      if (bestiaryCreatures.length === 0) {
        console.log("No creatures found via Statblocks API or data.monsters");
        return creatures;
      }

      console.log(`Loading ${bestiaryCreatures.length} creatures from 5e Statblocks plugin`);

      for (const monster of bestiaryCreatures) {
        if (!monster || typeof monster !== "object") continue;

        creatures.push({
          name: monster.name || "Unknown",
          path: monster.path || "[SRD]",
          hp: monster.hp || 1,
          ac: typeof monster.ac === "number" ? monster.ac : (parseInt(monster.ac) || 10),
          cr: monster.cr?.toString() || undefined
        });
      }

      console.log(`Loaded ${creatures.length} creatures from 5e Statblocks plugin`);
      if (creatures.length > 0) {
        console.log("First 5 creatures:", creatures.slice(0, 5).map(c => c.name));
      }
    } catch (error) {
      console.error("Error accessing 5e Statblocks plugin creatures:", error);
    }

    return creatures;
  }

  async createInitiativeTrackerEncounter(scenePath: string) {
    if (this.creatures.length === 0) return;

    try {
      const initiativePlugin = (this.app as any).plugins?.plugins?.["initiative-tracker"];
      if (!initiativePlugin) {
        new Notice("‚ö†Ô∏è Initiative Tracker plugin not found. Encounter data saved to scene frontmatter only.");
        console.log("Initiative Tracker plugin not found");
        return;
      }

      console.log("Initiative Tracker plugin found:", initiativePlugin);
      console.log("Available properties:", Object.keys(initiativePlugin));

      // Debug: Log creature data before building encounter
      console.log("Creatures to add:", this.creatures);

      // Helper function to generate unique IDs like Initiative Tracker does
      const generateId = () => {
        const chars = '0123456789abcdef';
        let id = 'ID_';
        for (let i = 0; i < 12; i++) {
          id += chars[Math.floor(Math.random() * chars.length)];
        }
        return id;
      };

      // Color names for duplicate creatures
      const colors = [
        "Red", "Blue", "Green", "Yellow", "Purple", "Orange",
        "Pink", "Brown", "Black", "White", "Gray", "Cyan",
        "Magenta", "Lime", "Teal", "Indigo", "Violet", "Gold",
        "Silver", "Bronze"
      ];

      // Get campaign party members if requested
      let partyMembers: any[] = [];
      if (this.includeParty) {
        partyMembers = await this.getCampaignPartyMembers(initiativePlugin);
      }

      // Build creature data in Initiative Tracker format
      const creatures = this.creatures.flatMap(c => {
        console.log(`Building creature: ${c.name}, HP: ${c.hp}, AC: ${c.ac}`);
        const instances = [];
        for (let i = 0; i < c.count; i++) {
          const hp = c.hp || 1;
          const ac = c.ac || 10;

          // Determine name and display based on useColorNames setting
          // IMPORTANT: 'name' must be unique to prevent auto-numbering
          // 'display' is used for visual representation in the tracker
          // Initiative Tracker will auto-number duplicate names
          let creatureName = c.name;  // Start with base name for bestiary lookup
          let displayName = c.name;  // Always show at least the creature name

          if (c.count > 1 && this.useColorNames) {
            const colorIndex = i % colors.length;
            // Make name unique to prevent Initiative Tracker from auto-numbering
            creatureName = `${c.name} (${colors[colorIndex]})`;
            displayName = creatureName;
          }
          // For single creatures or multiple without colors, name and display are just the creature name
          // Initiative Tracker will add numbers automatically for duplicates

          const creature = {
            name: creatureName,  // Unique name for each creature instance
            display: displayName,  // Display name (always has a value now)
            initiative: 0,
            static: false,
            modifier: 0,  // Initiative modifier
            hp: hp,
            currentMaxHP: hp,  // Initiative Tracker uses currentMaxHP, not max
            cr: c.cr || undefined,
            ac: ac,  // AC as number
            currentAC: ac,  // Initiative Tracker also tracks currentAC
            id: generateId(),  // CRITICAL: Unique ID for each creature instance
            currentHP: hp,  // Initiative Tracker uses currentHP, not hp
            tempHP: 0,  // Initiative Tracker uses tempHP, not temp
            status: [],  // Array of status effects
            enabled: true,
            active: false,  // Whether this creature is currently active in turn order
            hidden: false,  // Hidden from players
            friendly: false,  // Friendly to players
            rollHP: false,  // Whether to roll HP when adding to tracker
            note: c.path || "",  // Path to statblock file for Fantasy Statblock plugin
            path: c.path || ""   // Also store path field for compatibility
          };
          console.log(`Created creature instance:`, creature);
          instances.push(creature);
        }
        return instances;
      });

      // Save encounter to Initiative Tracker's data.encounters for later loading
      if (initiativePlugin.data && typeof initiativePlugin.data.encounters === 'object') {
        console.log("Saving encounter to Initiative Tracker data...");

        // Combine party members and creatures
        const allCombatants = [...partyMembers, ...creatures];

        // Initiative Tracker stores encounters as: data.encounters[name] = { creatures, state, name, round, ... }
        initiativePlugin.data.encounters[this.encounterName] = {
          creatures: allCombatants,
          state: false,
          name: this.encounterName,
          round: 1,
          logFile: null,
          rollHP: false
        };

        // Save settings to persist the encounter
        if (initiativePlugin.saveSettings) {
          await initiativePlugin.saveSettings();
          console.log(`Encounter "${this.encounterName}" saved to Initiative Tracker`);
          new Notice(`‚úÖ Encounter "${this.encounterName}" saved! Use "Load Encounter" in Initiative Tracker to start combat.`);
        }
      } else {
        console.log("Could not access Initiative Tracker data structure");
        new Notice(`‚ö†Ô∏è Encounter data saved to scene frontmatter only. Load manually in Initiative Tracker.`);
      }

      // Link encounter to scene
      await this.linkEncounterToScene(scenePath);

    } catch (error) {
      console.error("Error creating Initiative Tracker encounter:", error);
      new Notice("‚ö†Ô∏è Could not save encounter to Initiative Tracker. Check console for details.");
    }
  }

  async getCampaignPartyMembers(initiativePlugin: any): Promise<any[]> {
    try {
      // Get campaign name from adventure path
      const adventureFile = this.app.vault.getAbstractFileByPath(this.adventurePath);
      if (!(adventureFile instanceof TFile)) return [];

      const adventureContent = await this.app.vault.read(adventureFile);
      const campaignMatch = adventureContent.match(/^campaign:\s*([^\r\n]+)$/m);
      const campaignName = (campaignMatch?.[1]?.trim() || "Unknown").replace(/^["']|["']$/g, '');

      // Find the campaign's party
      const party = this.resolveParty(initiativePlugin, campaignName);

      if (!party || !party.players || party.players.length === 0) {
        console.log(`No party found for campaign "${campaignName}"`);
        return [];
      }

      // Get all player data for party members
      const partyMembers: any[] = [];
      const players = this.getPartyPlayersFromParty(initiativePlugin, party, true);
      for (const player of players) {
        partyMembers.push({
          ...player,
          initiative: 0,
          active: false,
          enabled: true
        });
      }

      console.log(`Found ${partyMembers.length} party members for "${campaignName}"`);
      return partyMembers;
    } catch (error) {
      console.error("Error fetching party members:", error);
      return [];
    }
  }

  async linkEncounterToScene(scenePath: string) {
    try {
      const sceneFile = this.app.vault.getAbstractFileByPath(scenePath);
      if (!(sceneFile instanceof TFile)) return;

      let content = await this.app.vault.read(sceneFile);

      // Update tracker_encounter field in frontmatter
      content = content.replace(
        /^tracker_encounter:\s*$/m,
        `tracker_encounter: "${this.encounterName}"`
      );

      await this.app.vault.modify(sceneFile, content);

    } catch (error) {
      console.error("Error linking encounter to scene:", error);
    }
  }
}

class SceneCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  encounterBuilder: EncounterBuilder;
  adventurePath = "";
  campaignPath = "";  // Track campaign for party resolution
  sceneName = "";
  act = "1";
  sceneNumber = "1";
  duration = "30min";
  type = "exploration";
  difficulty = "medium";
  
  // Encounter builder properties
  createEncounter = false;
  encounterName = "";
  useColorNames = false;
  includeParty = true;  // Include party members in encounter
  selectedPartyMembers: string[] = [];  // Selected party member names
  selectedPartyId = "";
  selectedPartyName = "";
  creatures: Array<{
    name: string;
    count: number;
    hp?: number;
    ac?: number;
    cr?: string;
    source?: string;
    path?: string;  // Path to creature file for statblock plugin
    isFriendly?: boolean;
    isHidden?: boolean;
  }> = [];
  
  // UI state
  encounterSection: HTMLElement | null = null;
  difficultyContainer: HTMLElement | null = null;
  creatureListContainer: HTMLElement | null = null;
  partySelectionContainer: HTMLElement | null = null;
  partyMemberListContainer: HTMLElement | null = null;
  
  // For editing existing scenes
  isEdit = false;
  originalScenePath = "";

  constructor(app: App, plugin: DndCampaignHubPlugin, adventurePath?: string, scenePath?: string) {
    super(app);
    this.plugin = plugin;
    this.encounterBuilder = new EncounterBuilder(app, plugin);
    if (adventurePath) {
      this.adventurePath = adventurePath;
    }
    if (scenePath) {
      this.isEdit = true;
      this.originalScenePath = scenePath;
    }
  }

  async loadSceneData() {
    try {
      const sceneFile = this.app.vault.getAbstractFileByPath(this.originalScenePath);
      if (!(sceneFile instanceof TFile)) {
        new Notice("Scene file not found!");
        return;
      }

      const cache = this.app.metadataCache.getFileCache(sceneFile);
      const frontmatter = cache?.frontmatter;

      if (!frontmatter) {
        new Notice("Could not read scene data!");
        return;
      }

      // Load basic scene properties
      // Extract scene name from filename (remove "Scene X - " prefix)
      let extractedName = sceneFile.basename;
      const nameMatch = sceneFile.basename.match(/^Scene\s+\d+\s+-\s+(.+)$/);
      if (nameMatch && nameMatch[1]) {
        extractedName = nameMatch[1];
      }
      
      this.sceneName = frontmatter.name || extractedName;
      this.act = String(frontmatter.act || "1");
      this.sceneNumber = String(frontmatter.scene_number || "1");
      this.duration = frontmatter.duration || "30min";
      this.type = frontmatter.scene_type || frontmatter.type || "exploration";
      this.difficulty = frontmatter.difficulty || "medium";

      // Load encounter properties if combat scene
      if (this.type === "combat") {
        this.createEncounter = !!frontmatter.tracker_encounter;
        this.encounterName = frontmatter.tracker_encounter || "";
        
        // Load creatures from encounter_creatures or YAML field
        const creaturesData = frontmatter.encounter_creatures;
        if (creaturesData && Array.isArray(creaturesData)) {
          this.creatures = await Promise.all(creaturesData.map(async (c: any) => {
            const creature: any = {
              name: c.name || "Unknown",
              count: c.count || 1,
              hp: c.hp,
              ac: c.ac,
              cr: c.cr,
              source: c.source || "vault",
              path: c.path,
              isTrap: c.is_trap || false,
              isFriendly: c.is_friendly === true || c.is_friendly === "true",
              isHidden: c.is_hidden === true || c.is_hidden === "true"
            };
            
            // If it's a trap, load the trap data from the trap file
            if (creature.isTrap && c.trap_path) {
              try {
                const trapFile = this.app.vault.getAbstractFileByPath(c.trap_path);
                if (trapFile instanceof TFile) {
                  const trapContent = await this.app.vault.read(trapFile);
                  const trapCache = this.app.metadataCache.getFileCache(trapFile);
                  if (trapCache?.frontmatter) {
                    const fm = trapCache.frontmatter;
                    creature.trapData = {
                      traptrapType: fm.trap_type || "simple",
                      threatLevel: fm.threat_level || "dangerous",
                      elements: fm.elements || []
                    };
                  }
                }
              } catch (error) {
                console.error(`Error loading trap data for ${creature.name}:`, error);
              }
            }
            
            return creature;
          }));
        }
        
        // Load party selection
        this.selectedPartyId = frontmatter.selected_party_id || "";
        if (frontmatter.selected_party_members && Array.isArray(frontmatter.selected_party_members)) {
          this.selectedPartyMembers = [...frontmatter.selected_party_members];
        }
        
        console.log(`[Scene Edit] Loaded party selection: id=${this.selectedPartyId}, members=${this.selectedPartyMembers.length}`);
      }

      // Extract adventure path from scene path
      // Path format: adventures/Adventure Name/Act 1 - Setup/Scene 1 - Name.md
      // or: adventures/Adventure Name - Scenes/Scene 1 - Name.md
      const pathParts = this.originalScenePath.split('/');
      let adventureIndex = -1;
      
      for (let i = 0; i < pathParts.length; i++) {
        if (pathParts[i] === "Adventures" || pathParts[i] === "adventures") {
          adventureIndex = i;
          break;
        }
      }
      
      if (adventureIndex >= 0 && pathParts.length > adventureIndex + 1) {
        const adventureName = pathParts[adventureIndex + 1]!.replace(/ - Scenes$/, '');
        // Try to find the adventure file
        const possiblePaths = [
          `${pathParts.slice(0, adventureIndex + 2).join('/')}/${adventureName}.md`,
          `${pathParts.slice(0, adventureIndex + 1).join('/')}/${adventureName}.md`
        ];
        
        for (const path of possiblePaths) {
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof TFile) {
            this.adventurePath = path;
            
            // Load campaignPath from adventure frontmatter
            try {
              const adventureContent = await this.app.vault.read(file);
              const campaignMatch = adventureContent.match(/^campaign:\s*([^\r\n]+)$/m);
              const campaignName = (campaignMatch?.[1]?.trim() || "Unknown").replace(/^["']|["']$/g, '');
              this.campaignPath = `ttrpgs/${campaignName}`;
              console.log(`[Scene Edit] Loaded campaignPath: ${this.campaignPath}`);
            } catch (err) {
              console.error("Error loading campaign from adventure:", err);
            }
            
            break;
          }
        }
      }

    } catch (error) {
      console.error("Error loading scene data:", error);
      new Notice("Error loading scene data");
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    // Load existing scene data if editing
    if (this.isEdit) {
      await this.loadSceneData();
    }

    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit Scene" : "üé¨ Create New Scene" });

    // Get all adventures from GM campaigns
    const allAdventures = await this.getAllAdventures();

    if (allAdventures.length === 0) {
      contentEl.createEl("p", {
        text: "‚ö†Ô∏è No adventures found. Create an adventure first.",
        cls: "mod-warning"
      });
      
      const closeBtn = contentEl.createEl("button", { text: "Close" });
      closeBtn.addEventListener("click", () => this.close());
      return;
    }

    // Set default adventure if provided, otherwise first one
    if (!this.adventurePath && allAdventures.length > 0 && allAdventures[0]) {
      this.adventurePath = allAdventures[0].path;
    }

    contentEl.createEl("p", {
      text: "Add a new scene to your adventure. The scene will be inserted at the specified number.",
      cls: "setting-item-description"
    });

    // Adventure Selection
    new Setting(contentEl)
      .setName("Adventure")
      .setDesc("Select the adventure to add this scene to")
      .addDropdown(dropdown => {
        allAdventures.forEach(adv => {
          dropdown.addOption(adv.path, adv.name);
        });
        dropdown.setValue(this.adventurePath);
        dropdown.onChange(value => {
          this.adventurePath = value;
          // Update suggested scene number based on existing scenes
          this.updateSceneNumberSuggestion();
        });
      });

    // Scene Name
    new Setting(contentEl)
      .setName("Scene Name")
      .setDesc("Give this scene a descriptive name")
      .addText(text => text
        .setPlaceholder("e.g., Tavern Ambush")
        .setValue(this.sceneName)
        .onChange(value => this.sceneName = value));

    // Act Selection
    new Setting(contentEl)
      .setName("Act")
      .setDesc("Which act does this scene belong to?")
      .addDropdown(dropdown => dropdown
        .addOption("1", "Act 1 - Setup")
        .addOption("2", "Act 2 - Rising Action")
        .addOption("3", "Act 3 - Climax")
        .setValue(this.act)
        .onChange(value => this.act = value));

    // Scene Number
    const sceneNumberSetting = new Setting(contentEl)
      .setName("Scene Number")
      .setDesc("Position in the adventure (existing scenes will be renumbered if needed)")
      .addText(text => text
        .setPlaceholder("e.g., 5")
        .setValue(this.sceneNumber)
        .onChange(value => this.sceneNumber = value));

    // Duration
    new Setting(contentEl)
      .setName("Duration")
      .setDesc("Estimated scene duration")
      .addDropdown(dropdown => dropdown
        .addOption("15min", "15 minutes")
        .addOption("20min", "20 minutes")
        .addOption("30min", "30 minutes")
        .addOption("40min", "40 minutes")
        .addOption("45min", "45 minutes")
        .addOption("60min", "60 minutes")
        .setValue(this.duration)
        .onChange(value => this.duration = value));

    // Type
    new Setting(contentEl)
      .setName("Type")
      .setDesc("Primary scene type")
      .addDropdown(dropdown => dropdown
        .addOption("social", "üó£Ô∏è Social - NPC interactions")
        .addOption("combat", "‚öîÔ∏è Combat - Fighting enemies")
        .addOption("exploration", "üîç Exploration - Discovery & investigation")
        .addOption("puzzle", "üß© Puzzle - Riddles & challenges")
        .addOption("montage", "üé¨ Montage - Skill challenge")
        .setValue(this.type)
        .onChange(value => {
          this.type = value;
          this.showEncounterBuilderIfCombat();
        }));

    // Difficulty
    new Setting(contentEl)
      .setName("Difficulty")
      .setDesc("Challenge level")
      .addDropdown(dropdown => dropdown
        .addOption("easy", "Easy")
        .addOption("medium", "Medium")
        .addOption("hard", "Hard")
        .addOption("deadly", "Deadly")
        .setValue(this.difficulty)
        .onChange(value => this.difficulty = value));

    // Encounter Builder Section (only for combat scenes)
    this.encounterSection = contentEl.createDiv({ cls: "dnd-encounter-section" });
    this.showEncounterBuilderIfCombat();

    // Create/Update button
    new Setting(contentEl)
      .addButton(btn => btn
        .setButtonText(this.isEdit ? "Save Changes" : "Create Scene")
        .setCta()
        .onClick(async () => {
          if (!this.sceneName) {
            new Notice("Please enter a scene name!");
            return;
          }

          this.close();
          await this.createSceneFile();
        }));
  }

  async updateSceneNumberSuggestion() {
    const existingScenes = await this.getExistingScenes(this.adventurePath);
    const nextNumber = existingScenes.length + 1;
    this.sceneNumber = nextNumber.toString();
  }

  async getAllAdventures(): Promise<Array<{ path: string; name: string }>> {
    const adventures: Array<{ path: string; name: string }> = [];
    const gmCampaigns = await this.getAllGMCampaigns();

    for (const campaign of gmCampaigns) {
      const adventuresFolder = this.app.vault.getAbstractFileByPath(`${campaign.path}/Adventures`);
      
      if (adventuresFolder instanceof TFolder) {
        for (const item of adventuresFolder.children) {
          if (item instanceof TFile && item.extension === 'md') {
            // Adventure file directly in Adventures folder (flat structure)
            adventures.push({
              path: item.path,
              name: item.basename
            });
          } else if (item instanceof TFolder) {
            // Adventure folder with main note inside (folder structure)
            const mainFile = this.app.vault.getAbstractFileByPath(`${item.path}/${item.name}.md`);
            if (mainFile instanceof TFile) {
              adventures.push({
                path: mainFile.path,
                name: item.name
              });
            }
          }
        }
      }
    }

    return adventures;
  }

  async getAllGMCampaigns(): Promise<Array<{ path: string; name: string }>> {
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
    const gmCampaigns: Array<{ path: string; name: string }> = [];

    if (ttrpgsFolder instanceof TFolder) {
      for (const child of ttrpgsFolder.children) {
        if (child instanceof TFolder) {
          const worldFile = this.app.vault.getAbstractFileByPath(`${child.path}/World.md`);
          if (worldFile instanceof TFile) {
            const worldContent = await this.app.vault.read(worldFile);
            const roleMatch = worldContent.match(/^role:\s*([^\r\n]\w*)$/m);
            if (roleMatch && roleMatch[1] && roleMatch[1].toLowerCase() === 'gm') {
              gmCampaigns.push({
                path: child.path,
                name: child.name
              });
            }
          }
        }
      }
    }

    return gmCampaigns;
  }

  async getExistingScenes(adventurePath: string): Promise<Array<{ path: string; number: number; name: string }>> {
    const scenes: Array<{ path: string; number: number; name: string }> = [];
    const adventureFile = this.app.vault.getAbstractFileByPath(adventurePath);
    
    if (!(adventureFile instanceof TFile)) return scenes;

    // Determine base path for scenes
    const adventureFolder = adventureFile.parent;
    if (!adventureFolder) return scenes;

    // Check for flat structure (Adventure - Scenes folder)
    const flatScenesFolder = this.app.vault.getAbstractFileByPath(
      `${adventureFolder.path}/${adventureFile.basename} - Scenes`
    );

    // Check for folder structure (Adventure/Scene files or Adventure/Act X folders)
    const folderScenesPath = `${adventureFolder.path}/${adventureFile.basename}`;
    const folderStructure = this.app.vault.getAbstractFileByPath(folderScenesPath);

    let sceneFolders: TFolder[] = [];

    if (flatScenesFolder instanceof TFolder) {
      // Flat structure
      sceneFolders.push(flatScenesFolder);
    } else if (folderStructure instanceof TFolder) {
      // Folder structure - check for Act folders or direct scenes
      for (const child of folderStructure.children) {
        if (child instanceof TFolder && child.name.startsWith("Act ")) {
          sceneFolders.push(child);
        }
      }
      // If no Act folders, the main folder contains scenes
      if (sceneFolders.length === 0) {
        sceneFolders.push(folderStructure);
      }
    }

    // Scan all scene folders for scene files
    for (const folder of sceneFolders) {
      for (const item of folder.children) {
        if (item instanceof TFile && item.extension === 'md') {
          // Extract scene number from filename: "Scene X - Name.md"
          const match = item.basename.match(/^Scene\s+(\d+)\s+-\s+(.+)$/);
          if (match && match[1] && match[2]) {
            scenes.push({
              path: item.path,
              number: parseInt(match[1]),
              name: match[2]
            });
          }
        }
      }
    }

    // Sort by scene number
    scenes.sort((a, b) => a.number - b.number);
    return scenes;
  }

  async createSceneFile() {
    try {
      const sceneNum = parseInt(this.sceneNumber);
      if (isNaN(sceneNum) || sceneNum < 1) {
        new Notice("Scene number must be a positive number!");
        return;
      }

      // Get adventure info
      const adventureFile = this.app.vault.getAbstractFileByPath(this.adventurePath);
      if (!(adventureFile instanceof TFile)) {
        new Notice("‚ùå Adventure file not found!");
        return;
      }

      const adventureContent = await this.app.vault.read(adventureFile);
      const campaignMatch = adventureContent.match(/^campaign:\s*([^\r\n]+)$/m);
      const worldMatch = adventureContent.match(/^world:\s*([^\r\n]+)$/m);
      const campaignName = (campaignMatch?.[1]?.trim() || "Unknown").replace(/^["']|["']$/g, '');
      const worldName = (worldMatch?.[1]?.trim() || campaignName).replace(/^["']|["']$/g, '');
      
      // Set campaignPath for party resolution
      this.campaignPath = `ttrpgs/${campaignName}`;

      // ====================
      // EDIT MODE: Update existing scene
      // ====================
      if (this.isEdit && this.originalScenePath) {
        new Notice(`Updating scene "${this.sceneName}"...`);
        
        const originalFile = this.app.vault.getAbstractFileByPath(this.originalScenePath);
        if (!(originalFile instanceof TFile)) {
          new Notice("‚ùå Original scene file not found!");
          return;
        }

        // Get original scene number from filename or frontmatter
        const originalBasename = originalFile.basename;
        const originalNumberMatch = originalBasename.match(/^Scene\s+(\d+)\s+-/);
        const originalSceneNum = (originalNumberMatch && originalNumberMatch[1]) ? parseInt(originalNumberMatch[1]) : sceneNum;

        // Check if scene number changed
        const numberChanged = originalSceneNum !== sceneNum;

        // Determine the target path
        const adventureFolder = adventureFile.parent;
        if (!adventureFolder) {
          new Notice("‚ùå Adventure folder not found!");
          return;
        }

        let targetPath: string;
        
        if (numberChanged) {
          // Scene number changed - need to determine new path and potentially renumber
          const flatScenesFolder = `${adventureFolder.path}/${adventureFile.basename} - Scenes`;
          const flatExists = this.app.vault.getAbstractFileByPath(flatScenesFolder) instanceof TFolder;
          const isFolderStructure = adventureFolder.name === adventureFile.basename;

          if (flatExists) {
            targetPath = `${flatScenesFolder}/Scene ${sceneNum} - ${this.sceneName}.md`;
          } else if (isFolderStructure) {
            const actFolderName = this.act === "1" ? "Act 1 - Setup" : 
                                  this.act === "2" ? "Act 2 - Rising Action" : "Act 3 - Climax";
            const actFolderPath = `${adventureFolder.path}/${actFolderName}`;
            const actFolder = this.app.vault.getAbstractFileByPath(actFolderPath);
            
            if (actFolder instanceof TFolder) {
              targetPath = `${actFolderPath}/Scene ${sceneNum} - ${this.sceneName}.md`;
            } else {
              // Check if any act folders exist
              const act1Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 1 - Setup`) instanceof TFolder;
              const act2Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 2 - Rising Action`) instanceof TFolder;
              const act3Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 3 - Climax`) instanceof TFolder;
              
              if (act1Exists || act2Exists || act3Exists) {
                await this.plugin.ensureFolderExists(actFolderPath);
                targetPath = `${actFolderPath}/Scene ${sceneNum} - ${this.sceneName}.md`;
              } else {
                targetPath = `${adventureFolder.path}/Scene ${sceneNum} - ${this.sceneName}.md`;
              }
            }
          } else {
            new Notice("‚ùå Could not determine scene folder structure!");
            return;
          }

          // Check if new number conflicts with existing scenes (excluding the current scene)
          const existingScenes = await this.getExistingScenes(this.adventurePath);
          const conflictingScenes = existingScenes.filter(s => 
            s.number === sceneNum && s.path !== this.originalScenePath
          );

          if (conflictingScenes.length > 0) {
            // Renumber conflicting scenes
            const scenesToRenumber = existingScenes.filter(s => 
              s.number >= sceneNum && s.path !== this.originalScenePath
            );
            await this.renumberScenes(scenesToRenumber, sceneNum);
          }
        } else {
          // Scene number didn't change - update in place, but handle name/act changes
          const parentPath = originalFile.parent?.path || "";
          targetPath = `${parentPath}/Scene ${sceneNum} - ${this.sceneName}.md`;
        }

        // Create the updated scene content
        const currentDate: string = new Date().toISOString().split('T')[0] || new Date().toISOString().substring(0, 10);
        const sceneData = {
          act: parseInt(this.act),
          num: sceneNum,
          name: this.sceneName,
          duration: this.duration,
          type: this.type,
          difficulty: this.difficulty
        };

        // Handle encounter file
        let encounterFilePath = "";
        if (this.createEncounter && this.creatures.length > 0) {
          const savedPath = await this.saveEncounterFile();
          if (savedPath) {
            encounterFilePath = savedPath;
          }
        }

        // Update or recreate the scene note
        const tempPath = targetPath + ".tmp";
        await this.createSceneNote(tempPath, sceneData, campaignName, worldName, adventureFile.basename, currentDate, encounterFilePath);

        // Read the new content
        const tempFile = this.app.vault.getAbstractFileByPath(tempPath);
        if (tempFile instanceof TFile) {
          const newContent = await this.app.vault.read(tempFile);
          await this.app.vault.delete(tempFile);

          if (originalFile.path === targetPath) {
            // Same path - just update content
            await this.app.vault.modify(originalFile, newContent);
          } else {
            // Path changed - create new and delete old
            await this.app.vault.create(targetPath, newContent);
            await this.app.vault.delete(originalFile);
          }
        }

        // Update Initiative Tracker encounter
        if (this.createEncounter && this.creatures.length > 0) {
          await this.encounterBuilder.createInitiativeTrackerEncounter(targetPath);
        }

        // Open the updated scene
        await this.app.workspace.openLinkText(targetPath, "", true);

        new Notice(`‚úÖ Scene "${this.sceneName}" updated!`);
        return;
      }

      // ====================
      // CREATE MODE: Create new scene
      // ====================
      new Notice(`Creating scene "${this.sceneName}"...`);

      // Determine folder structure
      const adventureFolder = adventureFile.parent;
      if (!adventureFolder) {
        new Notice("‚ùå Adventure folder not found!");
        return;
      }

      // Check which structure is being used
      // Flat structure: Adventures/Adventure Name.md with "Adventure Name - Scenes" folder
      // Folder structure: Adventures/Adventure Name/Adventure Name.md with scenes in that folder (or Act subfolders)
      
      const flatScenesFolder = `${adventureFolder.path}/${adventureFile.basename} - Scenes`;
      const flatExists = this.app.vault.getAbstractFileByPath(flatScenesFolder) instanceof TFolder;
      
      // For folder structure, check if we're in a dedicated adventure folder
      // (i.e., adventure file has same name as its parent folder)
      const isFolderStructure = adventureFolder.name === adventureFile.basename;

      let scenePath: string;
      let usesActFolders = false;

      if (flatExists) {
        // Flat structure
        scenePath = `${flatScenesFolder}/Scene ${sceneNum} - ${this.sceneName}.md`;
      } else if (isFolderStructure) {
        // Folder structure - scenes go in the adventure folder or act subfolders
        const actFolderName = this.act === "1" ? "Act 1 - Setup" : 
                              this.act === "2" ? "Act 2 - Rising Action" : "Act 3 - Climax";
        const actFolderPath = `${adventureFolder.path}/${actFolderName}`;
        const actFolder = this.app.vault.getAbstractFileByPath(actFolderPath);
        
        if (actFolder instanceof TFolder) {
          usesActFolders = true;
          scenePath = `${actFolderPath}/Scene ${sceneNum} - ${this.sceneName}.md`;
        } else {
          // Check if ANY act folders exist - if so, this is act-based structure
          const act1Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 1 - Setup`) instanceof TFolder;
          const act2Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 2 - Rising Action`) instanceof TFolder;
          const act3Exists = this.app.vault.getAbstractFileByPath(`${adventureFolder.path}/Act 3 - Climax`) instanceof TFolder;
          
          if (act1Exists || act2Exists || act3Exists) {
            // Act-based structure - create the missing act folder
            usesActFolders = true;
            await this.plugin.ensureFolderExists(actFolderPath);
            scenePath = `${actFolderPath}/Scene ${sceneNum} - ${this.sceneName}.md`;
          } else {
            // No act folders, scenes directly in adventure folder
            scenePath = `${adventureFolder.path}/Scene ${sceneNum} - ${this.sceneName}.md`;
          }
        }
      } else {
        new Notice("‚ùå Could not determine scene folder structure!");
        return;
      }

      // Check if we need to renumber existing scenes
      const existingScenes = await this.getExistingScenes(this.adventurePath);
      const scenesAtOrAfter = existingScenes.filter(s => s.number >= sceneNum);

      if (scenesAtOrAfter.length > 0) {
        // Renumber scenes
        await this.renumberScenes(scenesAtOrAfter, sceneNum);
      }

      // Ensure parent folder exists
      const parentPath = scenePath.substring(0, scenePath.lastIndexOf('/'));
      await this.plugin.ensureFolderExists(parentPath);

      // Create the scene file
      const currentDate: string = new Date().toISOString().split('T')[0] || new Date().toISOString().substring(0, 10);
      
      const sceneData = {
        act: parseInt(this.act),
        num: sceneNum,
        name: this.sceneName,
        duration: this.duration,
        type: this.type,
        difficulty: this.difficulty
      };

      // Create Initiative Tracker encounter and save encounter file if requested
      let encounterFilePath = "";
      if (this.createEncounter && this.creatures.length > 0) {
        const savedPath = await this.saveEncounterFile();
        if (savedPath) {
          encounterFilePath = savedPath;
        }
      }

      await this.createSceneNote(scenePath, sceneData, campaignName, worldName, adventureFile.basename, currentDate, encounterFilePath);

      // Save to Initiative Tracker after scene is created
      if (this.createEncounter && this.creatures.length > 0) {
        await this.encounterBuilder.createInitiativeTrackerEncounter(scenePath);
      }

      // Open the new scene
      await this.app.workspace.openLinkText(scenePath, "", true);

      new Notice(`‚úÖ Scene "${this.sceneName}" created!`);
    } catch (error) {
      new Notice(`‚ùå Error creating scene: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Scene creation error:", error);
    }
  }

  async renumberScenes(scenes: Array<{ path: string; number: number; name: string }>, insertAt: number) {
    // Renumber scenes from highest to lowest to avoid conflicts during rename
    const sorted = [...scenes].sort((a, b) => b.number - a.number);
    
    for (const scene of sorted) {
      const oldFile = this.app.vault.getAbstractFileByPath(scene.path);
      if (!(oldFile instanceof TFile)) continue;

      const newNumber = scene.number + 1;
      
      // Construct new filename preserving exact scene name
      const oldFilename = oldFile.basename; // e.g., "Scene 5 - Tavern Fight"
      const sceneNameMatch = oldFilename.match(/^Scene\s+\d+\s+-\s+(.+)$/);
      const sceneName = sceneNameMatch?.[1] || scene.name;
      const newFilename = `Scene ${newNumber} - ${sceneName}`;
      
      // Build new path
      const parentPath = oldFile.parent?.path || "";
      const newPath = `${parentPath}/${newFilename}.md`;

      // Skip if source and destination are the same (shouldn't happen, but safety check)
      if (oldFile.path === newPath) {
        console.warn(`Skipping rename: ${oldFile.path} already has correct name`);
        continue;
      }

      // Read and update content
      let content = await this.app.vault.read(oldFile);
      
      // Update scene_number in frontmatter
      content = content.replace(
        /^scene_number:\s*\d+$/m,
        `scene_number: ${newNumber}`
      );
      
      // Update the h1 header if it exists
      content = content.replace(
        /^# Scene\s+\d+:/m,
        `# Scene ${newNumber}:`
      );

      try {
        // Create new file with updated content
        await this.app.vault.create(newPath, content);
        
        // Delete old file only after successful creation
        await this.app.vault.delete(oldFile);
        
        console.log(`Renumbered: ${oldFile.path} ‚Üí ${newPath}`);
      } catch (error) {
        console.error(`Error renumbering scene ${oldFile.path}:`, error);
        new Notice(`‚ö†Ô∏è Could not renumber ${oldFilename}`);
      }
    }
  }

  async createSceneNote(
    filePath: string,
    scene: any,
    campaignName: string,
    worldName: string,
    adventureName: string,
    currentDate: string,
    encounterFilePath = ""
  ) {
    // Prepare encounter data for frontmatter
    const trackerEncounter = this.encounterName || "";
    const encounterFile = encounterFilePath ? `"[[${encounterFilePath}]]"` : '""';
    const encounterCreaturesJson = this.creatures.length > 0 
      ? JSON.stringify(this.creatures) 
      : "[]";
    
    // Calculate encounter difficulty if creatures exist
    let encounterDifficultyJson = "null";
    if (this.creatures.length > 0) {
      const diffResult = await this.calculateEncounterDifficulty();
      encounterDifficultyJson = JSON.stringify({
        difficulty: diffResult.analysis.difficulty,
        roundsToDefeat: diffResult.analysis.roundsToDefeatEnemies,
        survivalRatio: Math.round(diffResult.analysis.survivalRatio * 100) / 100,
        partyHP: diffResult.partyStats.totalHP,
        partyEffectiveDPR: Math.round(diffResult.analysis.partyEffectiveDPR),
        enemyHP: diffResult.enemyStats.totalHP,
        enemyEffectiveDPR: Math.round(diffResult.analysis.enemyEffectiveDPR),
        enemyCount: diffResult.enemyStats.creatureCount,
        partyCount: diffResult.partyStats.memberCount
      });
    }
    
    // Select the appropriate template based on scene type
    let templateToUse = SCENE_EXPLORATION_TEMPLATE; // Default
    switch (scene.type) {
      case 'social':
        templateToUse = SCENE_SOCIAL_TEMPLATE;
        break;
      case 'combat':
        templateToUse = SCENE_COMBAT_TEMPLATE;
        break;
      case 'exploration':
        templateToUse = SCENE_EXPLORATION_TEMPLATE;
        break;
      case 'puzzle':
        templateToUse = SCENE_PUZZLE_TEMPLATE;
        break;
      case 'montage':
        templateToUse = SCENE_MONTAGE_TEMPLATE;
        break;
    }
    
    // Calculate difficulty DC based on difficulty level
    const difficultyDCs: Record<string, string> = {
      'easy': '12',
      'medium': '15',
      'hard': '18',
      'deadly': '20'
    };
    const difficultyDC = difficultyDCs[scene.difficulty] || '15';
    
    const sceneContent = templateToUse
      .replace(/{{SCENE_NUMBER}}/g, scene.num.toString())
      .replace(/{{SCENE_NAME}}/g, scene.name)
      .replace(/{{ADVENTURE_NAME}}/g, adventureName)
      .replace(/{{ACT_NUMBER}}/g, scene.act.toString())
      .replace(/{{DURATION}}/g, scene.duration)
      .replace(/{{TYPE}}/g, scene.type)
      .replace(/{{DIFFICULTY}}/g, scene.difficulty)
      .replace(/{{DIFFICULTY_DC}}/g, difficultyDC)
      .replace(/{{CAMPAIGN}}/g, campaignName)
      .replace(/{{WORLD}}/g, worldName)
      .replace(/{{DATE}}/g, currentDate)
      .replace(/{{TRACKER_ENCOUNTER}}/g, trackerEncounter)
      .replace(/{{ENCOUNTER_FILE}}/g, encounterFile)
      .replace(/{{ENCOUNTER_CREATURES}}/g, encounterCreaturesJson)
      .replace(/{{ENCOUNTER_DIFFICULTY}}/g, encounterDifficultyJson)
      .replace(/{{SELECTED_PARTY_ID}}/g, this.selectedPartyId || "")
      .replace(/{{SELECTED_PARTY_MEMBERS}}/g, JSON.stringify(this.selectedPartyMembers));

    await this.app.vault.create(filePath, sceneContent);
  }

  syncEncounterBuilder() {
    this.encounterBuilder.encounterName = this.encounterName;
    this.encounterBuilder.creatures = [...this.creatures];
    this.encounterBuilder.includeParty = this.includeParty;
    this.encounterBuilder.useColorNames = this.useColorNames;
    this.encounterBuilder.selectedPartyMembers = [...this.selectedPartyMembers];
    this.encounterBuilder.selectedPartyId = this.selectedPartyId || "";
    this.encounterBuilder.adventurePath = this.adventurePath;
    this.encounterBuilder.campaignPath = this.campaignPath;
  }

  /**
   * Show/hide encounter builder section based on scene type
   */
  showEncounterBuilderIfCombat() {
    if (!this.encounterSection) return;
    
    this.encounterSection.empty();
    
    if (this.type !== "combat") {
      this.encounterSection.style.display = "none";
      return;
    }
    
    this.encounterSection.style.display = "block";
    
    // Header
    this.encounterSection.createEl("h3", { text: "‚öîÔ∏è Combat Encounter" });
    
    // Toggle to create encounter
    new Setting(this.encounterSection)
      .setName("Create Initiative Tracker Encounter")
      .setDesc("Build an encounter that will be ready to use in Initiative Tracker")
      .addToggle(toggle => toggle
        .setValue(this.createEncounter)
        .onChange(value => {
          this.createEncounter = value;
          // Re-render entire section to show/hide color option
          this.showEncounterBuilderIfCombat();
        }));
    
    // Color naming option (only show when encounter creation is enabled)
    if (this.createEncounter) {
      new Setting(this.encounterSection)
        .setName("Use Color Names")
        .setDesc("Name duplicate creatures with colors (Red Goblin, Blue Goblin) instead of numbers (Goblin 1, Goblin 2)")
        .addToggle(toggle => toggle
          .setValue(this.useColorNames)
          .onChange(value => {
            this.useColorNames = value;
          }));
      
      new Setting(this.encounterSection)
        .setName("Include Party Members")
        .setDesc("Add party members to this encounter for difficulty calculation")
        .addToggle(toggle => toggle
          .setValue(this.includeParty)
          .onChange(async (value) => {
            this.includeParty = value;
            await this.renderPartySelection();
            await this.renderPartyMemberList();
            this.updateDifficultyDisplay();
          }));
      
      // Party selection container
      this.partySelectionContainer = this.encounterSection.createDiv({ cls: "dnd-party-selection" });
      this.renderPartySelection();
      
      // Party member list container
      this.partyMemberListContainer = this.encounterSection.createDiv({ cls: "dnd-party-member-list" });
      this.renderPartyMemberList();
      
      // Show the builder fields
      this.showEncounterBuilderFields();
    }
  }

  /**
   * Show encounter builder input fields
   */
  async showEncounterBuilderFields() {
    if (!this.encounterSection) return;
    
    // Remove existing builder fields
    const existingBuilder = this.encounterSection.querySelector(".dnd-encounter-builder");
    if (existingBuilder) {
      existingBuilder.remove();
    }
    
    if (!this.createEncounter) return;
    
    const builderContainer = this.encounterSection.createDiv({ cls: "dnd-encounter-builder" });
    
    // Auto-fill encounter name based on scene name
    if (!this.encounterName && this.sceneName) {
      this.encounterName = `${this.sceneName} - Encounter`;
    }
    
    // Encounter Name
    new Setting(builderContainer)
      .setName("Encounter Name")
      .setDesc("Name for this encounter in Initiative Tracker")
      .addText(text => text
        .setPlaceholder("e.g., Goblin Ambush")
        .setValue(this.encounterName)
        .onChange(value => this.encounterName = value));
    
    // Creature management section
    builderContainer.createEl("h4", { text: "Creatures" });
    
    // Creature list container
    this.creatureListContainer = builderContainer.createDiv({ cls: "dnd-creature-list" });
    this.renderCreatureList();
    
    // === VAULT CREATURE SELECTION ===
    const vaultCreatureSection = builderContainer.createDiv({ cls: "dnd-add-creature-vault" });
    
    let selectedCreature: { name: string; path: string; hp: number; ac: number; cr?: string } | null = null;
    let vaultCreatureCount = "1";
    let searchResults: HTMLElement | null = null;
    
    // Load creatures from vault
    this.syncEncounterBuilder();
    const vaultCreatures = await this.encounterBuilder.loadAllCreatures();
    
    console.log("Loaded creatures:", vaultCreatures.length, vaultCreatures.slice(0, 3).map(c => c.name));
    
    if (vaultCreatures.length > 0) {
      const vaultCreatureSetting = new Setting(vaultCreatureSection)
        .setName("Add from Vault")
        .setDesc(`Search and select creatures from your vault (${vaultCreatures.length} available)`);
      
      // Create search input container
      const searchContainer = vaultCreatureSetting.controlEl.createDiv({ cls: "dnd-creature-search-container" });
      
      const searchInput = searchContainer.createEl("input", {
        type: "text",
        placeholder: "Search creatures...",
        cls: "dnd-creature-search-input"
      });
      
      // Search results container
      searchResults = searchContainer.createDiv({ cls: "dnd-creature-search-results" });
      searchResults.style.display = "none";
      
      // Filter and display results
      const showSearchResults = (query: string) => {
        console.log("showSearchResults called with query:", query, "Total creatures:", vaultCreatures.length);
        if (!searchResults) {
          console.log("No searchResults element!");
          return;
        }
        
        if (!query || query.length < 1) {
          searchResults.style.display = "none";
          return;
        }
        
        const queryLower = query.toLowerCase().trim();
        console.log("Searching for:", queryLower);
        console.log("Sample creature names:", vaultCreatures.slice(0, 5).map(c => ({name: c.name, lower: c.name.toLowerCase()})));
        
        const filtered = vaultCreatures.filter(c => {
          const matches = c.name.toLowerCase().includes(queryLower);
          if (queryLower.length <= 3 && matches) {
            console.log("Match found:", c.name, "matches query:", queryLower);
          }
          return matches;
        }).slice(0, 10); // Limit to 10 results
        
        console.log("Filtered results:", filtered.length, "matches");
        if (filtered.length > 0) {
          console.log("First 3 matches:", filtered.slice(0, 3).map(c => c.name));
        }
        
        searchResults.empty();
        
        if (filtered.length === 0) {
          searchResults.createEl("div", {
            text: "No creatures found",
            cls: "dnd-creature-search-no-results"
          });
          searchResults.style.display = "block";
          return;
        }
        
        filtered.forEach(creature => {
          const resultEl = searchResults!.createDiv({ cls: "dnd-creature-search-result" });
          
          const nameEl = resultEl.createDiv({ cls: "dnd-creature-search-result-name" });
          nameEl.setText(creature.name);
          
          const statsEl = resultEl.createDiv({ cls: "dnd-creature-search-result-stats" });
          const statsParts: string[] = [];
          if (creature.cr) statsParts.push(`CR ${creature.cr}`);
          statsParts.push(`HP ${creature.hp}`);
          statsParts.push(`AC ${creature.ac}`);
          statsEl.setText(statsParts.join(" | "));
          
          resultEl.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log("Creature clicked:", creature.name);
            selectedCreature = creature;
            searchInput.value = creature.name;
            if (searchResults) {
              searchResults.style.display = "none";
            }
          });
        });
        
        searchResults.style.display = "block";
      };
      
      // Search input events
      searchInput.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        console.log("Input event:", target.value);
        showSearchResults(target.value);
      });
      
      searchInput.addEventListener("focus", (e) => {
        const target = e.target as HTMLInputElement;
        if (target.value.length >= 2) {
          showSearchResults(target.value);
        }
      });
      
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && selectedCreature) {
          e.preventDefault();
          // Trigger add button
        }
      });
      
      // Close search results when clicking outside
      searchInput.addEventListener("blur", () => {
        setTimeout(() => {
          if (searchResults) {
            searchResults.style.display = "none";
          }
        }, 250); // Increased timeout to ensure click registers
      });
      
      // Count input
      vaultCreatureSetting.addText(text => {
        text.setPlaceholder("Count")
          .setValue("1")
          .onChange(value => vaultCreatureCount = value);
        text.inputEl.type = "number";
        text.inputEl.style.width = "60px";
      });
      
      // Add button
      vaultCreatureSetting.addButton(btn => btn
        .setButtonText("Add")
        .setCta()
        .onClick(() => {
          if (!selectedCreature) {
            new Notice("Please search and select a creature first!");
            return;
          }
          
          this.addCreature({
            name: selectedCreature.name,
            count: parseInt(vaultCreatureCount) || 1,
            hp: selectedCreature.hp,
            ac: selectedCreature.ac,
            cr: selectedCreature.cr,
            source: "vault",
            path: selectedCreature.path  // Include path for statblock plugin
          });
          
          new Notice(`Added ${vaultCreatureCount}x ${selectedCreature.name}`);
          
          // Clear search
          searchInput.value = "";
          selectedCreature = null;
        }));
    } else {
      vaultCreatureSection.createEl("p", {
        text: "‚ö†Ô∏è No creatures found in z_Beastiarity folder. Use manual entry below.",
        cls: "setting-item-description mod-warning"
      });
    }
    
    // === MANUAL CREATURE ENTRY ===
    const addCreatureSection = builderContainer.createDiv({ cls: "dnd-add-creature-manual" });
    
    let newCreatureName = "";
    let newCreatureCount = "1";
    let newCreatureHP = "";
    let newCreatureAC = "";
    let newCreatureCR = "";
    
    const addCreatureSetting = new Setting(addCreatureSection)
      .setName("Add Custom Creature")
      .setDesc("Enter creature details manually for custom or homebrew enemies");
    
    // Creature name input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("Name (e.g., Goblin)")
        .onChange(value => newCreatureName = value);
      text.inputEl.style.width = "120px";
    });
    
    // Count input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("Count")
        .setValue("1")
        .onChange(value => newCreatureCount = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // HP input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("HP")
        .onChange(value => newCreatureHP = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // AC input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("AC")
        .onChange(value => newCreatureAC = value);
      text.inputEl.type = "number";
      text.inputEl.style.width = "60px";
    });
    
    // CR input
    addCreatureSetting.addText(text => {
      text.setPlaceholder("CR")
        .onChange(value => newCreatureCR = value);
      text.inputEl.style.width = "60px";
    });
    
    // Add button
    addCreatureSetting.addButton(btn => btn
      .setButtonText("Add")
      .setCta()
      .onClick(() => {
        if (!newCreatureName.trim()) {
          new Notice("Please enter a creature name!");
          return;
        }
        
        this.addCreature({
          name: newCreatureName.trim(),
          count: parseInt(newCreatureCount) || 1,
          hp: newCreatureHP ? parseInt(newCreatureHP) : undefined,
          ac: newCreatureAC ? parseInt(newCreatureAC) : undefined,
          cr: newCreatureCR || undefined,
          source: "manual"
        });
        
        new Notice(`Added ${newCreatureCount}x ${newCreatureName}`);
        
        // Clear inputs
        newCreatureName = "";
        newCreatureCount = "1";
        newCreatureHP = "";
        newCreatureAC = "";
        newCreatureCR = "";
        
        // Re-render to clear fields
        this.showEncounterBuilderFields();
      }));
    
    // === ENCOUNTER DIFFICULTY CALCULATOR ===
    builderContainer.createEl("h4", { text: "‚öîÔ∏è Encounter Difficulty" });
    this.difficultyContainer = builderContainer.createDiv({ cls: "dnd-difficulty-container" });
    await this.updateDifficultyCalculation();
    
    // Info text
    builderContainer.createEl("p", {
      text: "üí° Tip: Select creatures from your vault or add custom enemies on the fly. You can edit stats later in Initiative Tracker.",
      cls: "setting-item-description"
    });
  }

  /**
   * Add a creature to the encounter
   */
  addCreature(creature: { name: string; count: number; hp?: number; ac?: number; cr?: string; source?: string; path?: string }) {
    this.creatures.push(creature);
    this.renderCreatureList();
  }

  /**
   * Remove a creature from the encounter
   */
  removeCreature(index: number) {
    this.creatures.splice(index, 1);
    this.renderCreatureList();
  }

  /**
   * Render the list of creatures in the encounter
   */
  renderCreatureList() {
    if (!this.creatureListContainer) return;
    
    this.creatureListContainer.empty();
    
    if (this.creatures.length === 0) {
      this.creatureListContainer.createEl("p", {
        text: "No creatures added yet. Add creatures below.",
        cls: "setting-item-description"
      });
      return;
    }
    
    this.creatures.forEach((creature, index) => {
      const creatureItem = this.creatureListContainer!.createDiv({ 
        cls: `dnd-creature-item${creature.isFriendly ? ' friendly' : ''}` 
      });
      
      const nameEl = creatureItem.createSpan({ cls: "dnd-creature-name" });
      const friendlyIndicator = creature.isFriendly ? "ü§ù " : "";
      const hiddenIndicator = creature.isHidden ? "üëÅÔ∏è‚Äçüó®Ô∏è " : "";
      nameEl.setText(`${friendlyIndicator}${hiddenIndicator}${creature.name} x${creature.count}`);
      
      const statsEl = creatureItem.createSpan({ cls: "dnd-creature-stats" });
      const stats: string[] = [];
      if (creature.hp) stats.push(`HP: ${creature.hp}`);
      if (creature.ac) stats.push(`AC: ${creature.ac}`);
      if (creature.cr) stats.push(`CR: ${creature.cr}`);
      if (creature.isFriendly) stats.push("ü§ù Friendly");
      if (creature.isHidden) stats.push("üëÅÔ∏è‚Äçüó®Ô∏è Hidden");
      statsEl.setText(stats.length > 0 ? ` | ${stats.join(" | ")}` : "");
      
      // Friendly toggle button
      const friendlyBtn = creatureItem.createEl("button", {
        text: "Friendly",
        cls: `dnd-creature-friendly-toggle${creature.isFriendly ? ' active' : ''}`
      });
      friendlyBtn.addEventListener("click", () => {
        creature.isFriendly = !creature.isFriendly;
        this.renderCreatureList();
      });
      
      // Hidden toggle button
      const hiddenBtn = creatureItem.createEl("button", {
        text: "Hidden",
        cls: `dnd-creature-hidden-toggle${creature.isHidden ? ' active' : ''}`
      });
      hiddenBtn.addEventListener("click", () => {
        creature.isHidden = !creature.isHidden;
        this.renderCreatureList();
      });
      
      const removeBtn = creatureItem.createEl("button", {
        text: "Remove",
        cls: "dnd-creature-remove"
      });
      removeBtn.addEventListener("click", () => {
        this.removeCreature(index);
      });
    });
    
    // Update difficulty calculation after creature list changes
    this.updateDifficultyCalculation();
  }

  /**
   * CR to combat stats mapping (D&D 5e approximations)
   * Returns: { dpr, attackBonus, ac, hp }
   */
  getCRStats(cr: string | undefined): { dpr: number; attackBonus: number; ac: number; hp: number } {
    this.syncEncounterBuilder();
    const stats = this.encounterBuilder.getCRStats(cr);
    return {
      dpr: stats.dpr,
      attackBonus: stats.attackBonus,
      ac: stats.ac,
      hp: stats.hp
    };
  }

  /**
   * Player level to combat stats mapping (D&D 5e approximations)
   * Returns: { dpr, attackBonus, ac, hp }
   */
  getLevelStats(level: number): { dpr: number; attackBonus: number; ac: number; hp: number } {
    this.syncEncounterBuilder();
    const stats = this.encounterBuilder.getLevelStats(level);
    return {
      dpr: stats.dpr,
      attackBonus: stats.attackBonus,
      ac: stats.ac,
      hp: stats.hp
    };
  }

  /**
   * Parse CR string to numeric value
   */
  parseCR(cr: string | undefined): number {
    if (!cr) return 0;
    
    const crStr = cr.toString().trim().toLowerCase();
    
    // Handle fractions
    if (crStr === "1/8") return 0.125;
    if (crStr === "1/4") return 0.25;
    if (crStr === "1/2") return 0.5;
    
    const parsed = parseFloat(crStr);
    return isNaN(parsed) ? 0 : parsed;
  }

  /**
   * Calculate hit probability (bounded between 5% and 95%)
   */
  calculateHitChance(attackBonus: number, targetAC: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateHitChance(attackBonus, targetAC);
  }

  /**
   * Calculate expected damage per round considering hit chance
   */
  calculateEffectiveDPR(baseDPR: number, hitChance: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateEffectiveDPR(baseDPR, hitChance);
  }

  /**
   * Calculate rounds to defeat a group (HP pool / effective DPR)
   */
  calculateRoundsToDefeat(totalHP: number, effectiveDPR: number): number {
    this.syncEncounterBuilder();
    return this.encounterBuilder.calculateRoundsToDefeat(totalHP, effectiveDPR);
  }

  async renderPartySelection() {
    if (!this.partySelectionContainer) return;
    this.partySelectionContainer.empty();

    if (!this.includeParty) return;

    try {
      this.syncEncounterBuilder();
      const parties = await this.encounterBuilder.getAvailableParties();

      if (parties.length === 0) {
        this.partySelectionContainer.createEl("p", {
          text: "‚ö†Ô∏è No parties found in Initiative Tracker",
          attr: { style: "color: var(--text-warning); font-style: italic; margin: 10px 0;" }
        });
        return;
      }

      if (!this.selectedPartyId) {
        const defaultParty = await this.encounterBuilder.getResolvedParty();
        if (defaultParty?.id) this.selectedPartyId = defaultParty.id;
        if (defaultParty?.name) this.selectedPartyName = defaultParty.name;
      }

      const partySetting = new Setting(this.partySelectionContainer)
        .setName("Party")
        .setDesc("Choose which party to use for difficulty calculations");

      partySetting.addDropdown((dropdown) => {
        parties.forEach(party => {
          dropdown.addOption(party.id, party.name);
        });
        dropdown.setValue(this.selectedPartyId || parties[0]!.id);
        dropdown.onChange((value) => {
          this.selectedPartyId = value;
          const selected = parties.find(p => p.id === value);
          this.selectedPartyName = selected?.name || "";
          this.selectedPartyMembers = [];
        });
      });

      partySetting.addButton((button) =>
        button
          .setButtonText("Apply Party")
          .onClick(async () => {
            await this.renderPartySelection();
            await this.renderPartyMemberList();
            this.updateDifficultyDisplay();
          })
      );

      const partyMembers = await this.encounterBuilder.getAvailablePartyMembers();
      
      if (partyMembers.length === 0) {
        this.partySelectionContainer.createEl("p", {
          text: "‚ö†Ô∏è No party members found in Initiative Tracker",
          attr: { style: "color: var(--text-warning); font-style: italic; margin: 10px 0;" }
        });
        return;
      }

      const selectionDiv = this.partySelectionContainer.createDiv();
      selectionDiv.style.border = "1px solid var(--background-modifier-border)";
      selectionDiv.style.padding = "10px";
      selectionDiv.style.borderRadius = "5px";
      selectionDiv.style.marginBottom = "10px";

      selectionDiv.createEl("h4", { text: "Select Party Members", attr: { style: "margin-top: 0;" } });

      for (const member of partyMembers) {
        const checkboxDiv = selectionDiv.createDiv();
        checkboxDiv.style.marginBottom = "5px";

        const checkbox = checkboxDiv.createEl("input", { type: "checkbox" });
        checkbox.checked = this.selectedPartyMembers.includes(member.name);
        checkbox.style.marginRight = "10px";
        checkbox.onchange = () => {
          if (checkbox.checked) {
            if (!this.selectedPartyMembers.includes(member.name)) {
              this.selectedPartyMembers.push(member.name);
            }
          } else {
            this.selectedPartyMembers = this.selectedPartyMembers.filter(n => n !== member.name);
          }
          this.renderPartyMemberList();
          this.updateDifficultyDisplay();
        };

        const label = checkboxDiv.createEl("span", { 
          text: `${member.name} (Level ${member.level}, HP: ${member.hp}, AC: ${member.ac})`
        });
        label.style.cursor = "pointer";
        label.onclick = () => {
          checkbox.checked = !checkbox.checked;
          checkbox.onchange?.(new Event('change'));
        };
      }

      // Select All / Deselect All / Refresh buttons
      const buttonsDiv = selectionDiv.createDiv();
      buttonsDiv.style.marginTop = "10px";
      buttonsDiv.style.display = "flex";
      buttonsDiv.style.gap = "10px";

      const selectAllBtn = buttonsDiv.createEl("button", { text: "Select All" });
      selectAllBtn.style.fontSize = "0.85em";
      selectAllBtn.onclick = () => {
        this.selectedPartyMembers = partyMembers.map(m => m.name);
        this.renderPartySelection();
        this.renderPartyMemberList();
        this.updateDifficultyDisplay();
      };

      const deselectAllBtn = buttonsDiv.createEl("button", { text: "Deselect All" });
      deselectAllBtn.style.fontSize = "0.85em";
      deselectAllBtn.onclick = () => {
        this.selectedPartyMembers = [];
        this.renderPartySelection();
        this.renderPartyMemberList();
        this.updateDifficultyDisplay();
      };

      const refreshBtn = buttonsDiv.createEl("button", { text: "üîÑ Refresh Stats" });
      refreshBtn.style.fontSize = "0.85em";
      refreshBtn.title = "Reload party stats from Initiative Tracker";
      refreshBtn.onclick = async () => {
        const success = await this.encounterBuilder.refreshPartyData();
        if (success) {
          this.renderPartySelection();
          this.renderPartyMemberList();
          this.updateDifficultyDisplay();
        }
      };
    } catch (error) {
      console.error("Error rendering party selection:", error);
    }
  }

  async renderPartyMemberList() {
    if (!this.partyMemberListContainer) return;
    this.partyMemberListContainer.empty();

    if (!this.includeParty || this.selectedPartyMembers.length === 0) {
      return;
    }

    try {
      const partyMembers = await this.encounterBuilder.getAvailablePartyMembers();
      const memberByName = new Map(partyMembers.map(m => [m.name, m]));

      const headerDiv = this.partyMemberListContainer.createDiv({ cls: "dnd-party-member-header" });
      headerDiv.style.marginBottom = "10px";
      headerDiv.style.fontWeight = "600";
      headerDiv.setText(`Selected Party Members (${this.selectedPartyMembers.length})`);

      for (const memberName of this.selectedPartyMembers) {
        const memberData = memberByName.get(memberName);
        if (!memberData) continue;

        const memberItem = this.partyMemberListContainer.createDiv({ cls: "dnd-creature-item" });
        
        const nameEl = memberItem.createSpan({ cls: "dnd-creature-name" });
        nameEl.setText(memberName);
        
        const statsEl = memberItem.createSpan({ cls: "dnd-creature-stats" });
        const stats: string[] = [];
        stats.push(`Level: ${memberData.level}`);
        stats.push(`HP: ${memberData.hp}`);
        stats.push(`AC: ${memberData.ac}`);
        statsEl.setText(` | ${stats.join(" | ")}`);
        
        const removeBtn = memberItem.createEl("button", {
          text: "Remove",
          cls: "dnd-creature-remove"
        });
        removeBtn.addEventListener("click", () => {
          this.removePartyMember(memberName);
        });
      }
    } catch (error) {
      console.error("Error rendering party member list:", error);
    }
  }

  removePartyMember(memberName: string) {
    this.selectedPartyMembers = this.selectedPartyMembers.filter(n => n !== memberName);
    this.renderPartySelection();
    this.renderPartyMemberList();
    this.updateDifficultyDisplay();
  }

  async getAvailablePartyMembers(): Promise<Array<{ name: string; level: number; hp: number; ac: number }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getAvailablePartyMembers();
  }

  /**
   * Get party members from Initiative Tracker for difficulty calculation
   */
  async getPartyForDifficulty(): Promise<Array<{ name: string; hp: number; ac: number; level: number }>> {
    this.syncEncounterBuilder();
    const members = await this.encounterBuilder.getAvailablePartyMembers();
    return members.map(member => ({
      name: member.name,
      hp: member.hp,
      ac: member.ac,
      level: member.level
    }));
  }

  /**
   * Calculate comprehensive encounter difficulty
   */
  async calculateEncounterDifficulty(): Promise<{
    enemyStats: {
      totalHP: number;
      avgAC: number;
      totalDPR: number;
      avgAttackBonus: number;
      creatureCount: number;
    };
    partyStats: {
      totalHP: number;
      avgAC: number;
      totalDPR: number;
      avgAttackBonus: number;
      memberCount: number;
      avgLevel: number;
    };
    analysis: {
      partyHitChance: number;
      enemyHitChance: number;
      partyEffectiveDPR: number;
      enemyEffectiveDPR: number;
      roundsToDefeatEnemies: number;
      roundsToDefeatParty: number;
      survivalRatio: number;
      difficulty: "Trivial" | "Easy" | "Medium" | "Hard" | "Deadly" | "TPK Risk";
      difficultyColor: string;
      summary: string;
    };
  }> {
    // Calculate enemy stats
    let enemyTotalHP = 0;
    let enemyTotalAC = 0;
    let enemyTotalDPR = 0;
    let enemyTotalAttackBonus = 0;
    let enemyCount = 0;
    
    for (const creature of this.creatures) {
      const crStats = this.getCRStats(creature.cr);
      const count = creature.count || 1;
      
      // Use actual HP/AC if provided, otherwise use CR-based estimates
      const hp = creature.hp || crStats.hp;
      const ac = creature.ac || crStats.ac;
      
      enemyTotalHP += hp * count;
      enemyTotalAC += ac * count;
      enemyTotalDPR += crStats.dpr * count;
      enemyTotalAttackBonus += crStats.attackBonus * count;
      enemyCount += count;
    }
    
    const avgEnemyAC = enemyCount > 0 ? enemyTotalAC / enemyCount : 13;
    const avgEnemyAttackBonus = enemyCount > 0 ? enemyTotalAttackBonus / enemyCount : 3;
    
    // Get party stats
    const partyMembers = await this.getPartyForDifficulty();
    
    let partyTotalHP = 0;
    let partyTotalAC = 0;
    let partyTotalDPR = 0;
    let partyTotalAttackBonus = 0;
    let totalLevel = 0;
    
    for (const member of partyMembers) {
      const levelStats = this.getLevelStats(member.level);
      
      // Use actual HP/AC if available, otherwise use level-based estimates
      // Ensure numeric conversion to prevent string concatenation bugs
      const memberHP = Number(member.hp) || 0;
      const memberAC = Number(member.ac) || 0;
      
      partyTotalHP += memberHP > 0 ? memberHP : levelStats.hp;
      partyTotalAC += memberAC > 0 ? memberAC : levelStats.ac;
      partyTotalDPR += levelStats.dpr;
      partyTotalAttackBonus += levelStats.attackBonus;
      totalLevel += member.level;
    }
    
    const memberCount = partyMembers.length;
    
    // Calculate averages with proper fallbacks
    let avgPartyAC: number;
    let avgPartyAttackBonus: number;
    let avgLevel: number;
    
    if (memberCount > 0) {
      avgPartyAC = partyTotalAC / memberCount;
      avgPartyAttackBonus = partyTotalAttackBonus / memberCount;
      avgLevel = totalLevel / memberCount;
    } else {
      // Use defaults for a level 3 party of 4
      const defaultStats = this.getLevelStats(3);
      partyTotalHP = defaultStats.hp * 4;
      partyTotalDPR = defaultStats.dpr * 4;
      avgPartyAC = defaultStats.ac;
      avgPartyAttackBonus = defaultStats.attackBonus;
      avgLevel = 3;
    }
    
    // Calculate hit chances
    const partyHitChance = this.calculateHitChance(avgPartyAttackBonus, avgEnemyAC);
    const enemyHitChance = this.calculateHitChance(avgEnemyAttackBonus, avgPartyAC);
    
    // Calculate effective DPR (considering hit chance)
    const partyEffectiveDPR = this.calculateEffectiveDPR(partyTotalDPR, partyHitChance);
    const enemyEffectiveDPR = this.calculateEffectiveDPR(enemyTotalDPR, enemyHitChance);
    
    // Calculate rounds to defeat
    const roundsToDefeatEnemies = this.calculateRoundsToDefeat(enemyTotalHP, partyEffectiveDPR);
    const roundsToDefeatParty = this.calculateRoundsToDefeat(partyTotalHP, enemyEffectiveDPR);
    
    // Survival ratio: how many more rounds the party can survive vs enemies
    const survivalRatio = roundsToDefeatParty / roundsToDefeatEnemies;
    
    // Determine difficulty based on survival ratio and rounds
    let difficulty: "Trivial" | "Easy" | "Medium" | "Hard" | "Deadly" | "TPK Risk";
    let difficultyColor: string;
    
    if (survivalRatio >= 4 || roundsToDefeatEnemies <= 1) {
      difficulty = "Trivial";
      difficultyColor = "#888888";
    } else if (survivalRatio >= 2.5) {
      difficulty = "Easy";
      difficultyColor = "#00aa00";
    } else if (survivalRatio >= 1.5) {
      difficulty = "Medium";
      difficultyColor = "#aaaa00";
    } else if (survivalRatio >= 1.0) {
      difficulty = "Hard";
      difficultyColor = "#ff8800";
    } else if (survivalRatio >= 0.6) {
      difficulty = "Deadly";
      difficultyColor = "#ff0000";
    } else {
      difficulty = "TPK Risk";
      difficultyColor = "#880000";
    }
    
    // Generate summary
    let summary = "";
    if (enemyCount === 0) {
      summary = "Add creatures to calculate difficulty.";
    } else if (partyMembers.length === 0) {
      summary = `‚ö†Ô∏è No party found. Using default 4-player party (Level 3).\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}.`;
    } else {
      summary = `Party of ${memberCount} (Avg Lvl ${avgLevel.toFixed(1)}) vs ${enemyCount} creature${enemyCount !== 1 ? 's' : ''}.\n`;
      summary += `Expected duration: ~${roundsToDefeatEnemies} round${roundsToDefeatEnemies !== 1 ? 's' : ''}.`;
      
      if (difficulty === "TPK Risk") {
        summary += "\n‚ö†Ô∏è HIGH RISK: Party may not survive this encounter!";
      } else if (difficulty === "Deadly") {
        summary += "\n‚ö†Ô∏è Deadly encounter - expect possible character deaths.";
      }
    }
    
    return {
      enemyStats: {
        totalHP: enemyTotalHP,
        avgAC: avgEnemyAC,
        totalDPR: enemyTotalDPR,
        avgAttackBonus: avgEnemyAttackBonus,
        creatureCount: enemyCount
      },
      partyStats: {
        totalHP: partyTotalHP,
        avgAC: avgPartyAC,
        totalDPR: partyTotalDPR,
        avgAttackBonus: avgPartyAttackBonus,
        memberCount: memberCount,
        avgLevel: avgLevel
      },
      analysis: {
        partyHitChance,
        enemyHitChance,
        partyEffectiveDPR,
        enemyEffectiveDPR,
        roundsToDefeatEnemies,
        roundsToDefeatParty,
        survivalRatio,
        difficulty,
        difficultyColor,
        summary
      }
    };
  }

  /**
   * Update and render the difficulty calculation display
   */
  async updateDifficultyCalculation() {
    if (!this.difficultyContainer) return;
    
    this.difficultyContainer.empty();
    
    if (this.creatures.length === 0) {
      this.difficultyContainer.createEl("p", {
        text: "Add creatures to see encounter difficulty analysis.",
        cls: "setting-item-description"
      });
      return;
    }
    
    // Show loading
    const loadingEl = this.difficultyContainer.createEl("p", { text: "Calculating difficulty..." });
    
    this.syncEncounterBuilder();
    const result = await this.encounterBuilder.calculateEncounterDifficulty();
    
    loadingEl.remove();
    
    // Create difficulty display
    const difficultyCard = this.difficultyContainer.createDiv({ cls: "dnd-difficulty-card" });
    
    // Header with difficulty rating
    const header = difficultyCard.createDiv({ cls: "dnd-difficulty-header" });
    
    const difficultyBadge = header.createEl("span", {
      text: result.analysis.difficulty,
      cls: "dnd-difficulty-badge"
    });
    difficultyBadge.style.backgroundColor = result.analysis.difficultyColor;
    difficultyBadge.style.color = "#ffffff";
    difficultyBadge.style.padding = "4px 12px";
    difficultyBadge.style.borderRadius = "12px";
    difficultyBadge.style.fontWeight = "bold";
    difficultyBadge.style.fontSize = "14px";
    
    const roundsEstimate = header.createEl("span", {
      text: ` ~${result.analysis.roundsToDefeatEnemies} round${result.analysis.roundsToDefeatEnemies !== 1 ? 's' : ''}`,
      cls: "dnd-rounds-estimate"
    });
    roundsEstimate.style.marginLeft = "10px";
    roundsEstimate.style.opacity = "0.8";
    
    // Stats comparison grid
    const statsGrid = difficultyCard.createDiv({ cls: "dnd-difficulty-stats-grid" });
    statsGrid.style.display = "grid";
    statsGrid.style.gridTemplateColumns = "1fr 1fr";
    statsGrid.style.gap = "15px";
    statsGrid.style.marginTop = "15px";
    
    // Party stats
    const partyCol = statsGrid.createDiv({ cls: "dnd-stats-column" });
    partyCol.createEl("h5", { text: `‚öîÔ∏è Party (${result.partyStats.memberCount})` });
    const partyStats = partyCol.createDiv();
    partyStats.innerHTML = `
      <div>HP Pool: <strong>${result.partyStats.totalHP}</strong></div>
      <div>Avg AC: <strong>${result.partyStats.avgAC.toFixed(0)}</strong></div>
      <div>Total DPR: <strong>${result.partyStats.totalDPR.toFixed(0)}</strong></div>
      <div>Hit Chance: <strong>${(result.analysis.partyHitChance * 100).toFixed(0)}%</strong></div>
      <div>Effective DPR: <strong>${result.analysis.partyEffectiveDPR.toFixed(0)}</strong></div>
    `;
    
    // Enemy stats
    const enemyCol = statsGrid.createDiv({ cls: "dnd-stats-column" });
    enemyCol.createEl("h5", { text: `üëπ Enemies (${result.enemyStats.creatureCount})` });
    const enemyStats = enemyCol.createDiv();
    enemyStats.innerHTML = `
      <div>HP Pool: <strong>${result.enemyStats.totalHP}</strong></div>
      <div>Avg AC: <strong>${result.enemyStats.avgAC.toFixed(0)}</strong></div>
      <div>Total DPR: <strong>${result.enemyStats.totalDPR.toFixed(0)}</strong></div>
      <div>Hit Chance: <strong>${(result.analysis.enemyHitChance * 100).toFixed(0)}%</strong></div>
      <div>Effective DPR: <strong>${result.analysis.enemyEffectiveDPR.toFixed(0)}</strong></div>
    `;
    
    // Analysis summary
    const analysisSummary = difficultyCard.createDiv({ cls: "dnd-difficulty-analysis" });
    analysisSummary.style.marginTop = "15px";
    analysisSummary.style.padding = "10px";
    analysisSummary.style.backgroundColor = "var(--background-secondary)";
    analysisSummary.style.borderRadius = "6px";
    analysisSummary.style.fontSize = "12px";
    
    // Calculate damage over 3 rounds
    const partyDamage3Rounds = result.analysis.partyEffectiveDPR * 3;
    const enemyDamage3Rounds = result.analysis.enemyEffectiveDPR * 3;
    const partyHPAfter3 = Math.max(0, result.partyStats.totalHP - enemyDamage3Rounds);
    const enemyHPAfter3 = Math.max(0, result.enemyStats.totalHP - partyDamage3Rounds);
    
    analysisSummary.innerHTML = `
      <div style="margin-bottom: 8px;"><strong>üìä 3-Round Analysis:</strong></div>
      <div>Party deals: <strong>${partyDamage3Rounds.toFixed(0)}</strong> damage ‚Üí Enemies at <strong>${enemyHPAfter3.toFixed(0)}</strong> HP (${((enemyHPAfter3 / result.enemyStats.totalHP) * 100).toFixed(0)}%)</div>
      <div>Enemies deal: <strong>${enemyDamage3Rounds.toFixed(0)}</strong> damage ‚Üí Party at <strong>${partyHPAfter3.toFixed(0)}</strong> HP (${((partyHPAfter3 / result.partyStats.totalHP) * 100).toFixed(0)}%)</div>
      <div style="margin-top: 8px; opacity: 0.8;">
        Survival Ratio: ${result.analysis.survivalRatio.toFixed(2)} 
        (Party can survive ${result.analysis.roundsToDefeatParty} rounds, enemies survive ${result.analysis.roundsToDefeatEnemies} rounds)
      </div>
    `;
    
    // Warning for no party
    if (result.partyStats.memberCount === 0 || (await this.getPartyForDifficulty()).length === 0) {
      const warningEl = difficultyCard.createDiv({ cls: "dnd-difficulty-warning" });
      warningEl.style.marginTop = "10px";
      warningEl.style.padding = "8px";
      warningEl.style.backgroundColor = "#ff880033";
      warningEl.style.borderRadius = "4px";
      warningEl.style.fontSize = "12px";
      warningEl.innerHTML = `‚ö†Ô∏è <strong>No party registered!</strong> Using default estimates for 4 Level-3 PCs. 
        <br>Register PCs via "Create PC" to get accurate calculations.`;
    }
  }

  /**
   * Alias for updateDifficultyCalculation to match EncounterBuilderModal interface
   */
  async updateDifficultyDisplay() {
    return this.updateDifficultyCalculation();
  }

  /**
   * Search vault for creature files in z_Beastiarity
   * Parses creature statblocks from frontmatter
   */
  async searchVaultCreatures(query: string): Promise<Array<{
    name: string;
    path: string;
    hp: number;
    ac: number;
    cr?: string;
  }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.searchVaultCreatures(query);
  }
  
  /**
   * Load all creatures from vault for dropdown
   */
  async loadAllCreatures(): Promise<Array<{
    name: string;
    path: string;
    hp: number;
    ac: number;
    cr?: string;
  }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.loadAllCreatures();
  }
  
  /**
   * Get creatures from the 5e Statblocks plugin (includes SRD monsters)
   */
  async getStatblocksPluginCreatures(): Promise<Array<{
    name: string;
    path: string;
    hp: number;
    ac: number;
    cr?: string;
  }>> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getStatblocksPluginCreatures();
  }

  /**
   * Create encounter in Initiative Tracker and link to scene
   * Note: The encounter file is saved earlier in createSceneFile
   */
  async createInitiativeTrackerEncounter(scenePath: string) {
    if (!this.createEncounter || this.creatures.length === 0) return;

    this.syncEncounterBuilder();
    
    // Save to Initiative Tracker plugin
    await this.encounterBuilder.createInitiativeTrackerEncounter(scenePath);
  }

  /**
   * Save encounter file to z_Encounters folder
   * Uses the same proven approach as EncounterBuilderModal.saveEncounter()
   */
  async saveEncounterFile() {
    if (!this.encounterName || this.creatures.length === 0) {
      console.log("[SceneCreation - saveEncounterFile] Skipping - no encounter name or creatures");
      return null;
    }

    if (!this.campaignPath) {
      console.error("[SceneCreation - saveEncounterFile] No campaignPath set!");
      new Notice("‚ö†Ô∏è Cannot save encounter: campaign path not found");
      return null;
    }

    try {
      // Use vault's root z_Encounters folder (same as EncounterBuilderModal)
      const encounterFolder = "z_Encounters";
      
      console.log("[SceneCreation - saveEncounterFile] Saving encounter:", this.encounterName);
      console.log("[SceneCreation - saveEncounterFile] Campaign:", this.campaignPath);
      console.log("[SceneCreation - saveEncounterFile] Folder:", encounterFolder);
      
      // Create folder if it doesn't exist
      const folderExists = this.app.vault.getAbstractFileByPath(encounterFolder);
      if (!folderExists) {
        console.log("[SceneCreation - saveEncounterFile] Creating folder...");
        await this.app.vault.createFolder(encounterFolder);
      }

      // Generate encounter file content (same as EncounterBuilderModal)
      this.syncEncounterBuilder();
      const diffResult = await this.encounterBuilder.calculateEncounterDifficulty();
      const encounterContent = await this.generateEncounterContent(diffResult);

      // Save encounter file
      const fileName = `${this.encounterName}.md`;
      const encounterPath = `${encounterFolder}/${fileName}`;
      
      console.log("[SceneCreation - saveEncounterFile] File path:", encounterPath);

      const existingFile = this.app.vault.getAbstractFileByPath(encounterPath);
      if (existingFile instanceof TFile) {
        console.log("[SceneCreation - saveEncounterFile] Updating existing file");
        await this.app.vault.modify(existingFile, encounterContent);
      } else {
        console.log("[SceneCreation - saveEncounterFile] Creating new file");
        await this.app.vault.create(encounterPath, encounterContent);
      }

      console.log(`[SceneCreation - saveEncounterFile] ‚úÖ Success! Path: ${encounterPath}`);
      new Notice(`‚úÖ Encounter "${this.encounterName}" saved to z_Encounters`);
      
      return encounterPath;
    } catch (error) {
      console.error("[SceneCreation - saveEncounterFile] ERROR:", error);
      const errorMsg = error instanceof Error ? error.message : String(error);
      new Notice(`‚ö†Ô∏è Could not save encounter file: ${errorMsg}`);
      return null;
    }
  }

  escapeYamlString(str: string): string {
    if (!str) return '""';
    // Use single quotes for YAML strings - only need to escape single quotes within
    // Single quotes are safer as they don't interpret escape sequences
    if (str.includes("'")) {
      // If string contains single quotes, double them (YAML escaping for single quotes)
      return "'" + str.replace(/'/g, "''") + "'";
    }
    // If no single quotes, just wrap in single quotes
    return "'" + str + "'";
  }


  /**
   * Generate encounter file content using the EXACT same format as EncounterBuilderModal
   */
  async generateEncounterContent(diffResult: any): Promise<string> {
    const currentDate = window.moment().format("YYYY-MM-DD");

    let frontmatter = `---
type: encounter
name: ${this.escapeYamlString(this.encounterName)}
creatures:`;

    for (const creature of this.creatures) {
      frontmatter += `\n  - name: ${this.escapeYamlString(creature.name)}
    count: ${creature.count}`;
      if (creature.hp) frontmatter += `\n    hp: ${creature.hp}`;
      if (creature.ac) frontmatter += `\n    ac: ${creature.ac}`;
      if (creature.cr) frontmatter += `\n    cr: ${this.escapeYamlString(creature.cr)}`;
      if (creature.source) frontmatter += `\n    source: ${this.escapeYamlString(creature.source)}`;
      if (creature.path) frontmatter += `\n    path: ${this.escapeYamlString(creature.path)}`;
      if (creature.isFriendly) frontmatter += `\n    is_friendly: ${creature.isFriendly}`;
      if (creature.isHidden) frontmatter += `\n    is_hidden: ${creature.isHidden}`;
    }

    frontmatter += `
include_party: ${this.includeParty}
use_color_names: ${this.useColorNames}`;

    if (this.selectedPartyId) frontmatter += `\nselected_party_id: ${this.escapeYamlString(this.selectedPartyId)}`;
    if (this.selectedPartyMembers.length > 0) {
      const selectedPartyName = this.selectedPartyMembers.join(", ");
      frontmatter += `\nselected_party_name: ${this.escapeYamlString(selectedPartyName)}`;
    }

    if (this.adventurePath) frontmatter += `\nadventure_path: ${this.escapeYamlString(this.adventurePath)}`;
    if (this.campaignPath) frontmatter += `\ncampaign_path: ${this.escapeYamlString(this.campaignPath)}`;

    frontmatter += `
difficulty:
  rating: ${this.escapeYamlString(diffResult.analysis.difficulty)}
  color: ${this.escapeYamlString(diffResult.analysis.difficultyColor)}
  party_count: ${diffResult.partyStats.memberCount}
  party_avg_level: ${diffResult.partyStats.avgLevel.toFixed(1)}
  party_total_hp: ${diffResult.partyStats.totalHP}
  party_avg_ac: ${diffResult.partyStats.avgAC.toFixed(1)}
  party_total_dpr: ${diffResult.partyStats.totalDPR.toFixed(1)}
  party_hit_chance: ${(diffResult.analysis.partyHitChance * 100).toFixed(0)}
  party_effective_dpr: ${diffResult.analysis.partyEffectiveDPR.toFixed(0)}
  enemy_count: ${diffResult.enemyStats.creatureCount}
  enemy_total_hp: ${diffResult.enemyStats.totalHP}
  enemy_avg_ac: ${diffResult.enemyStats.avgAC.toFixed(1)}
  enemy_total_dpr: ${diffResult.enemyStats.totalDPR.toFixed(1)}
  enemy_hit_chance: ${(diffResult.analysis.enemyHitChance * 100).toFixed(0)}
  enemy_effective_dpr: ${diffResult.analysis.enemyEffectiveDPR.toFixed(0)}
  rounds_to_defeat: ${diffResult.analysis.roundsToDefeatEnemies}
  rounds_party_survives: ${diffResult.analysis.roundsToDefeatParty}
  survival_ratio: ${diffResult.analysis.survivalRatio.toFixed(2)}
date: ${currentDate}
---`;

    // Use EXACT same content structure as EncounterBuilderModal
    const content = `${frontmatter}

# ${this.encounterName}

\`\`\`dataviewjs
// Create action buttons
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Open Initiative Tracker and load encounter button
const openTrackerBtn = buttonContainer.createEl("button", { 
  text: "‚öîÔ∏è Open & Load in Tracker",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px; background-color: var(--interactive-accent); color: var(--text-on-accent);" }
});
openTrackerBtn.addEventListener("click", async () => {
  const encounterName = dv.current().name;
  const initiativeTracker = app.plugins?.plugins?.["initiative-tracker"];
  
  if (!initiativeTracker) {
    new Notice("Initiative Tracker plugin not found");
    return;
  }
  
  const encounter = initiativeTracker.data?.encounters?.[encounterName];
  if (!encounter) {
    new Notice("Encounter \\"" + encounterName + "\\" not found. Try recreating it.");
    return;
  }
  
  // Use Initiative Tracker's internal tracker API to load the encounter
  try {
    if (initiativeTracker.tracker?.new) {
      initiativeTracker.tracker.new(initiativeTracker, encounter);
      new Notice("‚úÖ Loaded encounter: " + encounterName);
    } else {
      new Notice("‚ö†Ô∏è Could not load encounter. Try using Load Encounter from Initiative Tracker menu.");
    }
  } catch (e) {
    console.error("Error loading encounter:", e);
    new Notice("‚ö†Ô∏è Could not load encounter: " + e.message);
  }
  
  // Open Initiative Tracker view
  app.commands.executeCommandById("initiative-tracker:open-tracker");
});

// Edit button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-encounter");
});

// Delete button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-encounter");
});
\`\`\`

---

## Difficulty Analysis

\`\`\`dataviewjs
const diff = dv.current().difficulty;
if (!diff) {
  dv.paragraph("*No difficulty data available.*");
} else {
  // Create difficulty card
  const card = dv.el("div", "", { cls: "dnd-difficulty-card" });
  
  // Header with difficulty badge and rounds
  const header = dv.el("div", "", { cls: "dnd-difficulty-header", container: card });
  const badge = dv.el("span", diff.rating, { cls: "dnd-difficulty-badge", container: header });
  badge.style.backgroundColor = diff.color;
  dv.el("span", \` ~\${diff.rounds_to_defeat} round\${diff.rounds_to_defeat !== 1 ? 's' : ''}\`, { cls: "dnd-rounds-estimate", container: header });
  
  // Stats grid
  const grid = dv.el("div", "", { cls: "dnd-difficulty-stats-grid", container: card });
  
  // Party column
  const partyCol = dv.el("div", "", { cls: "dnd-stats-column", container: grid });
  dv.el("h5", \`‚öîÔ∏è Party (\${diff.party_count})\`, { container: partyCol });
  const partyStats = dv.el("div", "", { container: partyCol });
  partyStats.innerHTML = \`
    <div>HP Pool: <strong>\${diff.party_total_hp}</strong></div>
    <div>Avg AC: <strong>\${Math.round(diff.party_avg_ac)}</strong></div>
    <div>Total DPR: <strong>\${Math.round(diff.party_total_dpr)}</strong></div>
    <div>Hit Chance: <strong>\${diff.party_hit_chance}%</strong></div>
    <div>Effective DPR: <strong>\${diff.party_effective_dpr}</strong></div>
  \`;
  
  // Enemy column
  const enemyCol = dv.el("div", "", { cls: "dnd-stats-column", container: grid });
  dv.el("h5", \`üëπ Enemies (\${diff.enemy_count})\`, { container: enemyCol });
  const enemyStats = dv.el("div", "", { container: enemyCol });
  enemyStats.innerHTML = \`
    <div>HP Pool: <strong>\${diff.enemy_total_hp}</strong></div>
    <div>Avg AC: <strong>\${Math.round(diff.enemy_avg_ac)}</strong></div>
    <div>Total DPR: <strong>\${Math.round(diff.enemy_total_dpr)}</strong></div>
    <div>Hit Chance: <strong>\${diff.enemy_hit_chance}%</strong></div>
    <div>Effective DPR: <strong>\${diff.enemy_effective_dpr}</strong></div>
  \`;
  
  // 3-round analysis
  const analysis = dv.el("div", "", { cls: "dnd-difficulty-analysis", container: card });
  const partyDamage3 = diff.party_effective_dpr * 3;
  const enemyDamage3 = diff.enemy_effective_dpr * 3;
  const partyHPAfter3 = Math.max(0, diff.party_total_hp - enemyDamage3);
  const enemyHPAfter3 = Math.max(0, diff.enemy_total_hp - partyDamage3);
  const partyHPPercent = Math.round((partyHPAfter3 / diff.party_total_hp) * 100);
  const enemyHPPercent = Math.round((enemyHPAfter3 / diff.enemy_total_hp) * 100);
  
  analysis.innerHTML = \`
    <div style="margin-bottom: 8px;"><strong>üìä 3-Round Analysis:</strong></div>
    <div>Party deals: <strong>\${Math.round(partyDamage3)}</strong> damage ‚Üí Enemies at <strong>\${Math.round(enemyHPAfter3)}</strong> HP (\${enemyHPPercent}%)</div>
    <div>Enemies deal: <strong>\${Math.round(enemyDamage3)}</strong> damage ‚Üí Party at <strong>\${Math.round(partyHPAfter3)}</strong> HP (\${partyHPPercent}%)</div>
    <div style="margin-top: 8px; opacity: 0.8;">
      Survival Ratio: \${diff.survival_ratio}
      (Party can survive \${diff.rounds_party_survives} rounds, enemies survive \${diff.rounds_to_defeat} rounds)
    </div>
  \`;
}
\`\`\`

---

## Creatures

\`\`\`dataviewjs
const creatures = dv.current().creatures || [];

if (creatures.length === 0) {
  dv.paragraph("*No creatures in this encounter.*");
} else {
  const table = creatures.map(c => {
    return [
      c.name,
      c.count || 1,
      c.cr || "?",
      c.hp || "?",
      c.ac || "?"
    ];
  });
  
  dv.table(["Creature", "Count", "CR", "HP", "AC"], table);
}
\`\`\`

---

## GM Notes

_Add notes about tactics, environment, or special conditions here._
`;

    return content;
  }

  /**
   * Get party members for the current campaign
   */
  async getCampaignPartyMembers(initiativePlugin: any): Promise<any[]> {
    this.syncEncounterBuilder();
    return this.encounterBuilder.getCampaignPartyMembers(initiativePlugin);
  }

  /**
   * Link encounter to scene by updating tracker_encounter frontmatter field
   */
  async linkEncounterToScene(scenePath: string) {
    this.syncEncounterBuilder();
    return this.encounterBuilder.linkEncounterToScene(scenePath);
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class TrapCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  trapName = "";
  trapType: 'simple' | 'complex' = 'simple';
  threatLevel: 'setback' | 'dangerous' | 'deadly' = 'setback';
  minLevel = 1;
  maxLevel = 5;
  trigger = "";
  adventurePath = "";
  scenePath = "";
  
  elements: TrapElement[] = [];
  countermeasures: TrapCountermeasure[] = [];
  
  // UI containers
  elementsContainer: HTMLElement | null = null;
  countermeasuresContainer: HTMLElement | null = null;

  // For editing existing traps
  isEdit = false;
  originalTrapPath = "";
  originalTrapName = "";
  originalElements: TrapElement[] = [];

  constructor(app: App, plugin: DndCampaignHubPlugin, adventurePath?: string, scenePath?: string, trapPath?: string) {
    super(app);
    this.plugin = plugin;
    if (adventurePath) this.adventurePath = adventurePath;
    if (scenePath) this.scenePath = scenePath;
    if (trapPath) {
      this.isEdit = true;
      this.originalTrapPath = trapPath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    
    // Load existing trap data if editing
    if (this.isEdit) {
      await this.loadTrapData();
    }
    
    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit Trap" : "Create New Trap" });

    // Trap Name
    new Setting(contentEl)
      .setName("Trap Name")
      .setDesc("Name of the trap")
      .addText((text) =>
        text
          .setPlaceholder("Thundering Squall")
          .setValue(this.trapName)
          .onChange((value) => {
            this.trapName = value;
          })
      );

    // Trap Type
    new Setting(contentEl)
      .setName("Trap Type")
      .setDesc("Simple traps have basic effects. Complex traps have multiple initiatives and elements.")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("simple", "Simple")
          .addOption("complex", "Complex")
          .setValue(this.trapType)
          .onChange((value) => {
            this.trapType = value as 'simple' | 'complex';
            this.refreshUI();
          })
      );

    // Threat Level
    new Setting(contentEl)
      .setName("Threat Level")
      .setDesc("How dangerous is this trap?")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("setback", "Setback")
          .addOption("dangerous", "Dangerous")
          .addOption("deadly", "Deadly")
          .setValue(this.threatLevel)
          .onChange((value: any) => {
            this.threatLevel = value;
          })
      );

    // Level Range
    new Setting(contentEl)
      .setName("Level Range")
      .setDesc("Minimum and maximum character levels for this trap")
      .addText((text) =>
        text
          .setPlaceholder("1")
          .setValue(this.minLevel.toString())
          .onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num >= 1 && num <= 20) {
              this.minLevel = num;
            }
          })
      )
      .addText((text) =>
        text
          .setPlaceholder("5")
          .setValue(this.maxLevel.toString())
          .onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num >= 1 && num <= 20) {
              this.maxLevel = num;
            }
          })
      );

    // Trigger
    new Setting(contentEl)
      .setName("Trigger")
      .setDesc("What activates this trap?")
      .addTextArea((text) => {
        text
          .setPlaceholder("A creature enters the area without the cult insignia...")
          .setValue(this.trigger)
          .onChange((value) => {
            this.trigger = value;
          });
        text.inputEl.rows = 3;
        text.inputEl.style.width = "100%";
      });

    // Elements Section
    contentEl.createEl("h3", { text: "Trap Elements" });
    this.elementsContainer = contentEl.createDiv();
    this.renderElements();

    new Setting(contentEl)
      .addButton((button) =>
        button
          .setButtonText("+ Add Element")
          .onClick(() => {
            this.addElement();
          })
      );

    // Countermeasures Section
    contentEl.createEl("h3", { text: "Countermeasures" });
    this.countermeasuresContainer = contentEl.createDiv();
    this.renderCountermeasures();

    new Setting(contentEl)
      .addButton((button) =>
        button
          .setButtonText("+ Add Countermeasure")
          .onClick(() => {
            this.addCountermeasure();
          })
      );

    // Adventure/Scene Link
    const adventureDisplay = this.adventurePath 
      ? this.adventurePath.split('/').pop()?.replace('.md', '') || 'None'
      : 'None';

    const sceneDisplay = this.scenePath
      ? this.scenePath.split('/').pop()?.replace('.md', '') || 'None'
      : 'None';

    contentEl.createEl("p", { 
      text: `Adventure: ${adventureDisplay} | Scene: ${sceneDisplay}`,
      attr: { style: "margin-top: 1em; font-size: 0.9em; color: var(--text-muted);" }
    });

    // Create Button
    new Setting(contentEl).addButton((button) =>
      button
        .setButtonText(this.isEdit ? "Update Trap" : "Create Trap")
        .setCta()
        .onClick(() => {
          this.createTrap();
        })
    );
  }

  refreshUI() {
    this.renderElements();
  }

  addElement() {
    const newElement: TrapElement = {
      name: "",
      element_type: this.trapType === 'simple' ? 'active' : 'active',
      initiative: this.trapType === 'complex' ? 20 : undefined,
      effect: ""
    };
    this.elements.push(newElement);
    this.renderElements();
  }

  removeElement(index: number) {
    this.elements.splice(index, 1);
    this.renderElements();
  }

  renderElements() {
    if (!this.elementsContainer) return;
    this.elementsContainer.empty();

    if (this.elements.length === 0) {
      this.elementsContainer.createEl("p", { 
        text: "No elements added yet. Click '+ Add Element' to add trap effects.",
        attr: { style: "color: var(--text-muted); font-style: italic;" }
      });
      return;
    }

    this.elements.forEach((element, index) => {
      const elementContainer = this.elementsContainer!.createDiv({ cls: "trap-element" });
      elementContainer.style.border = "1px solid var(--background-modifier-border)";
      elementContainer.style.padding = "10px";
      elementContainer.style.marginBottom = "10px";
      elementContainer.style.borderRadius = "5px";

      // Element header with remove button
      const headerDiv = elementContainer.createDiv();
      headerDiv.style.display = "flex";
      headerDiv.style.justifyContent = "space-between";
      headerDiv.style.alignItems = "center";
      headerDiv.style.marginBottom = "10px";

      headerDiv.createEl("h4", { text: `Element ${index + 1}`, attr: { style: "margin: 0;" } });
      
      const removeBtn = headerDiv.createEl("button", { text: "Remove" });
      removeBtn.style.padding = "2px 8px";
      removeBtn.style.fontSize = "0.8em";
      removeBtn.onclick = () => this.removeElement(index);

      // Name
      new Setting(elementContainer)
        .setName("Name")
        .addText((text) =>
          text
            .setPlaceholder("Thunderous Slam")
            .setValue(element.name)
            .onChange((value) => {
              element.name = value;
            })
        );

      // Element Type (for complex traps)
      if (this.trapType === 'complex') {
        new Setting(elementContainer)
          .setName("Element Type")
          .addDropdown((dropdown) =>
            dropdown
              .addOption("active", "Active (on initiative)")
              .addOption("dynamic", "Dynamic (conditional)")
              .addOption("constant", "Constant (ongoing)")
              .setValue(element.element_type)
              .onChange((value: any) => {
                element.element_type = value;
                this.renderElements();
              })
          );

        // Initiative (for active elements)
        if (element.element_type === 'active') {
          new Setting(elementContainer)
            .setName("Initiative")
            .addText((text) =>
              text
                .setPlaceholder("20")
                .setValue(element.initiative?.toString() || "")
                .onChange((value) => {
                  const num = parseInt(value);
                  if (!isNaN(num)) {
                    element.initiative = num;
                  }
                })
            );
        }

        // Condition (for dynamic elements)
        if (element.element_type === 'dynamic') {
          new Setting(elementContainer)
            .setName("Condition")
            .addTextArea((text) => {
              text
                .setPlaceholder("On each initiative count 10...")
                .setValue(element.condition || "")
                .onChange((value) => {
                  element.condition = value;
                });
              text.inputEl.rows = 2;
              text.inputEl.style.width = "100%";
            });
        }
      }

      // Attack Bonus
      new Setting(elementContainer)
        .setName("Attack Bonus (optional)")
        .addText((text) =>
          text
            .setPlaceholder("+8")
            .setValue(element.attack_bonus?.toString() || "")
            .onChange((value) => {
              const num = parseInt(value);
              if (!isNaN(num)) {
                element.attack_bonus = num;
              } else if (value === "") {
                element.attack_bonus = undefined;
              }
            })
        );

      // Range
      new Setting(elementContainer)
        .setName("Range (optional)")
        .addText((text) =>
          text
            .setPlaceholder("60 ft. or Touch or Melee")
            .setValue(element.range || "")
            .onChange((value) => {
              element.range = value || undefined;
            })
        );

      // Save DC
      new Setting(elementContainer)
        .setName("Save DC (optional)")
        .addText((text) =>
          text
            .setPlaceholder("15")
            .setValue(element.save_dc?.toString() || "")
            .onChange((value) => {
              const num = parseInt(value);
              if (!isNaN(num)) {
                element.save_dc = num;
              } else if (value === "") {
                element.save_dc = undefined;
              }
            })
        )
        .addDropdown((dropdown) =>
          dropdown
            .addOption("DEX", "DEX")
            .addOption("STR", "STR")
            .addOption("CON", "CON")
            .addOption("INT", "INT")
            .addOption("WIS", "WIS")
            .addOption("CHA", "CHA")
            .setValue(element.save_ability || "DEX")
            .onChange((value) => {
              element.save_ability = value;
            })
        );

      // Damage
      new Setting(elementContainer)
        .setName("Damage (optional)")
        .addText((text) =>
          text
            .setPlaceholder("4d10 thunder")
            .setValue(element.damage || "")
            .onChange((value) => {
              element.damage = value || undefined;
            })
        );

      // Additional Damage
      new Setting(elementContainer)
        .setName("Additional Damage (optional)")
        .addText((text) =>
          text
            .setPlaceholder("2d6 fire (ongoing)")
            .setValue(element.additional_damage || "")
            .onChange((value) => {
              element.additional_damage = value || undefined;
            })
        );

      // Save Success/Failure (only if save_dc is set)
      if (element.save_dc) {
        new Setting(elementContainer)
          .setName("On Successful Save")
          .addTextArea((text) => {
            text
              .setPlaceholder("Takes half damage...")
              .setValue(element.on_success || "")
              .onChange((value) => {
                element.on_success = value || undefined;
              });
            text.inputEl.rows = 2;
            text.inputEl.style.width = "100%";
          });

        new Setting(elementContainer)
          .setName("On Failed Save")
          .addTextArea((text) => {
            text
              .setPlaceholder("Takes full damage and is knocked prone...")
              .setValue(element.on_failure || "")
              .onChange((value) => {
                element.on_failure = value || undefined;
              });
            text.inputEl.rows = 2;
            text.inputEl.style.width = "100%";
          });
      }

      // Effect
      new Setting(elementContainer)
        .setName("Effect")
        .addTextArea((text) => {
          text
            .setPlaceholder("The target is pushed 10 feet and knocked prone...")
            .setValue(element.effect || "")
            .onChange((value) => {
              element.effect = value;
            });
          text.inputEl.rows = 3;
          text.inputEl.style.width = "100%";
        });
    });
  }

  addCountermeasure() {
    const newCM: TrapCountermeasure = {
      method: "",
      dc: 15,
      checks_needed: 1
    };
    this.countermeasures.push(newCM);
    this.renderCountermeasures();
  }

  removeCountermeasure(index: number) {
    this.countermeasures.splice(index, 1);
    this.renderCountermeasures();
  }

  renderCountermeasures() {
    if (!this.countermeasuresContainer) return;
    this.countermeasuresContainer.empty();

    if (this.countermeasures.length === 0) {
      this.countermeasuresContainer.createEl("p", { 
        text: "No countermeasures added yet. Click '+ Add Countermeasure' to add ways to disable the trap.",
        attr: { style: "color: var(--text-muted); font-style: italic;" }
      });
      return;
    }

    this.countermeasures.forEach((cm, index) => {
      const cmContainer = this.countermeasuresContainer!.createDiv({ cls: "trap-countermeasure" });
      cmContainer.style.border = "1px solid var(--background-modifier-border)";
      cmContainer.style.padding = "10px";
      cmContainer.style.marginBottom = "10px";
      cmContainer.style.borderRadius = "5px";

      // Header with remove button
      const headerDiv = cmContainer.createDiv();
      headerDiv.style.display = "flex";
      headerDiv.style.justifyContent = "space-between";
      headerDiv.style.alignItems = "center";
      headerDiv.style.marginBottom = "10px";

      headerDiv.createEl("h4", { text: `Countermeasure ${index + 1}`, attr: { style: "margin: 0;" } });
      
      const removeBtn = headerDiv.createEl("button", { text: "Remove" });
      removeBtn.style.padding = "2px 8px";
      removeBtn.style.fontSize = "0.8em";
      removeBtn.onclick = () => this.removeCountermeasure(index);

      // Method
      new Setting(cmContainer)
        .setName("Method")
        .addText((text) =>
          text
            .setPlaceholder("Force open the door")
            .setValue(cm.method)
            .onChange((value) => {
              cm.method = value;
            })
        );

      // DC
      new Setting(cmContainer)
        .setName("DC")
        .addText((text) =>
          text
            .setPlaceholder("15")
            .setValue(cm.dc?.toString() || "")
            .onChange((value) => {
              const num = parseInt(value);
              if (!isNaN(num)) {
                cm.dc = num;
              }
            })
        );

      // Checks Needed
      new Setting(cmContainer)
        .setName("Checks Needed")
        .setDesc("How many successful checks to complete?")
        .addText((text) =>
          text
            .setPlaceholder("1")
            .setValue(cm.checks_needed?.toString() || "1")
            .onChange((value) => {
              const num = parseInt(value);
              if (!isNaN(num) && num >= 1) {
                cm.checks_needed = num;
              }
            })
        );

      // Description
      new Setting(cmContainer)
        .setName("Description")
        .addTextArea((text) => {
          text
            .setPlaceholder("Three DC 20 Strength checks required to force the door...")
            .setValue(cm.description || "")
            .onChange((value) => {
              cm.description = value;
            });
          text.inputEl.rows = 2;
          text.inputEl.style.width = "100%";
        });

      // Effect
      new Setting(cmContainer)
        .setName("Effect on Success")
        .addTextArea((text) => {
          text
            .setPlaceholder("The trap is disabled...")
            .setValue(cm.effect || "")
            .onChange((value) => {
              cm.effect = value;
            });
          text.inputEl.rows = 2;
          text.inputEl.style.width = "100%";
        });
    });
  }

  async loadTrapData() {
    try {
      const trapFile = this.app.vault.getAbstractFileByPath(this.originalTrapPath);
      if (!(trapFile instanceof TFile)) {
        new Notice("Trap file not found!");
        return;
      }

      const cache = this.app.metadataCache.getFileCache(trapFile);
      const frontmatter = cache?.frontmatter;

      if (!frontmatter) {
        new Notice("Could not read trap data!");
        return;
      }

      // Load basic trap properties
      this.trapName = frontmatter.trap_name || trapFile.basename;
      this.originalTrapName = this.trapName; // Store original name for statblock updates
      this.trapType = frontmatter.trap_type || 'simple';
      this.threatLevel = frontmatter.threat_level || 'setback';
      this.minLevel = frontmatter.min_level || 1;
      this.maxLevel = frontmatter.max_level || 5;
      this.trigger = frontmatter.trigger || "";
      this.adventurePath = frontmatter.adventure || "";
      this.scenePath = frontmatter.scene || "";

      // Load elements
      if (frontmatter.elements && Array.isArray(frontmatter.elements)) {
        this.elements = frontmatter.elements.map((e: any) => ({
          name: e.name || "",
          element_type: e.element_type || 'active',
          initiative: e.initiative,
          attack_bonus: e.attack_bonus,
          save_dc: e.save_dc,
          save_ability: e.save_ability,
          damage: e.damage,
          additional_damage: e.additional_damage,
          range: e.range,
          on_success: e.on_success,
          on_failure: e.on_failure,
          effect: e.effect || "",
          condition: e.condition
        }));
        // Store original elements to track deletions
        this.originalElements = JSON.parse(JSON.stringify(this.elements));
      }

      // Load countermeasures
      if (frontmatter.countermeasures && Array.isArray(frontmatter.countermeasures)) {
        this.countermeasures = frontmatter.countermeasures.map((cm: any) => ({
          method: cm.method || "",
          description: cm.description,
          dc: cm.dc,
          checks_needed: cm.checks_needed || 1,
          effect: cm.effect
        }));
      }

      console.log(`[Trap Edit] Loaded trap data: ${this.trapName}, ${this.elements.length} elements`);
    } catch (error) {
      console.error("Error loading trap data:", error);
      new Notice("Error loading trap data. Check console for details.");
    }
  }

  async createTrap() {
    if (!this.trapName) {
      new Notice("Please enter a trap name");
      return;
    }

    if (this.elements.length === 0) {
      new Notice("Please add at least one trap element");
      return;
    }

    try {
      // Get campaign and world info
      let campaignName = "";
      let worldName = "";

      if (this.adventurePath) {
        const adventureFile = this.app.vault.getAbstractFileByPath(this.adventurePath);
        if (adventureFile instanceof TFile) {
          const content = await this.app.vault.read(adventureFile);
          const campaignMatch = content.match(/^campaign:\s*(.+)$/m);
          const worldMatch = content.match(/^world:\s*(.+)$/m);
          
          if (campaignMatch && campaignMatch[1]) campaignName = campaignMatch[1].trim();
          if (worldMatch && worldMatch[1]) worldName = worldMatch[1].trim();
        }
      }

      let trapPath: string;
      let trapFile: TFile | null = null;

      if (this.isEdit) {
        // Editing existing trap
        trapFile = this.app.vault.getAbstractFileByPath(this.originalTrapPath) as TFile;
        if (!trapFile) {
          new Notice("Original trap file not found!");
          return;
        }
        trapPath = this.originalTrapPath;

        // If trap name changed, handle file rename and statblock updates
        if (this.trapName !== this.originalTrapName) {
          // Delete old statblocks
          await this.plugin.deleteTrapStatblocks(this.originalTrapName);
          
          // Rename file if name changed
          const folder = trapPath.substring(0, trapPath.lastIndexOf('/'));
          const newPath = `${folder}/${this.trapName}.md`;
          
          // Check if new name conflicts
          if (await this.app.vault.adapter.exists(newPath)) {
            new Notice(`A trap named "${this.trapName}" already exists!`);
            return;
          }
          
          await this.app.fileManager.renameFile(trapFile, newPath);
          trapPath = newPath;
          trapFile = this.app.vault.getAbstractFileByPath(newPath) as TFile;
        } else {
          // Same name - delete old statblocks and we'll recreate
          await this.plugin.deleteTrapStatblocks(this.originalTrapName);
        }

        // Track removed elements for complex traps
        if (this.trapType === 'complex') {
          // Find elements that were removed
          const currentElementNames = new Set(this.elements.map(e => e.name));
          const removedElements = this.originalElements.filter(e => !currentElementNames.has(e.name));
          
          if (removedElements.length > 0) {
            console.log(`[Trap Edit] Removed ${removedElements.length} elements, will delete their statblocks`);
            // Note: We already deleted all statblocks above, so this is just logging
          }
        }
      } else {
        // Creating new trap
        // Create trap file path in z_Traps folder
        let trapsFolder = "z_Traps";
        
        // If we have a campaign, create in campaign's z_Traps folder
        if (campaignName) {
          trapsFolder = `${campaignName}/z_Traps`;
        }
        
        // Ensure z_Traps folder exists
        if (!(await this.app.vault.adapter.exists(trapsFolder))) {
          await this.app.vault.createFolder(trapsFolder);
        }
        
        trapPath = `${trapsFolder}/${this.trapName}.md`;

        // Check if file already exists
        if (await this.app.vault.adapter.exists(trapPath)) {
          new Notice(`A trap named "${this.trapName}" already exists!`);
          return;
        }
      }

      // Create trap content with statblocks
      const trapContent = this.createTrapContent(campaignName, worldName);

      // Create or update the file
      if (this.isEdit && trapFile) {
        await this.app.vault.modify(trapFile, trapContent);
        new Notice(`Trap "${this.trapName}" updated!`);
      } else {
        await this.app.vault.create(trapPath, trapContent);
        new Notice(`Trap "${this.trapName}" created!`);
        trapFile = this.app.vault.getAbstractFileByPath(trapPath) as TFile;
      }

      // Save statblocks to Fantasy Statblocks plugin
      await this.saveStatblocks();

      this.close();

      // Open the trap file
      if (trapFile) {
        await this.app.workspace.getLeaf().openFile(trapFile);
      }
    } catch (error) {
      console.error("Error creating/editing trap:", error);
      new Notice("Failed to save trap. Check console for details.");
    }
  }

  createTrapContent(campaignName: string, worldName: string): string {
    const now = new Date().toISOString().split('T')[0];
    
    // Generate statblock content
    const statblockContent = this.generateStatblockContent();
    
    // Convert elements and countermeasures to YAML
    const elementsYaml = JSON.stringify(this.elements, null, 2)
      .split('\n')
      .map((line, idx) => idx === 0 ? line : '  ' + line)
      .join('\n');

    const countermeasuresYaml = JSON.stringify(this.countermeasures, null, 2)
      .split('\n')
      .map((line, idx) => idx === 0 ? line : '  ' + line)
      .join('\n');

    return `---
type: trap
template_version: 1.1.0
campaign: ${campaignName}
adventure: ${this.adventurePath?.split('/').pop()?.replace('.md', '') || ''}
world: ${worldName}
scene: ${this.scenePath?.split('/').pop()?.replace('.md', '') || ''}
trap_name: ${this.trapName}
trap_type: ${this.trapType}
threat_level: ${this.threatLevel}
min_level: ${this.minLevel}
max_level: ${this.maxLevel}
trigger: ${this.trigger}
elements: ${elementsYaml}
countermeasures: ${countermeasuresYaml}
date: ${now}
---

# ${this.trapName}

\`\`\`dataviewjs
// Action buttons for trap management
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Edit Trap button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit Trap",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-trap");
});

// Delete Trap button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete Trap",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-trap");
});
\`\`\`

## Trap Details

**Type:** ${this.trapType.charAt(0).toUpperCase() + this.trapType.slice(1)} Trap  
**Threat Level:** ${this.threatLevel.charAt(0).toUpperCase() + this.threatLevel.slice(1)}  
**Level Range:** ${this.minLevel}-${this.maxLevel}

### Trigger Condition
${this.trigger || "Not specified"}

---

## Statblocks

${statblockContent}

---

## Trap Elements & Effects

\`\`\`dataviewjs
const elements = dv.current().elements || [];
const trapType = dv.current().trap_type || 'simple';

if (elements.length === 0) {
  dv.paragraph("*No trap elements defined.*");
} else {
  if (trapType === 'simple') {
    for (const element of elements) {
      dv.header(4, element.name || "Effect");
      if (element.attack_bonus !== undefined) {
        dv.paragraph(\`**Attack:** +\${element.attack_bonus} to hit\${element.range ? \`, \${element.range}\` : ""}\`);
      }
      if (element.save_dc !== undefined) {
        dv.paragraph(\`**Save:** DC \${element.save_dc} \${element.save_ability || "DEX"}\`);
      }
      if (element.damage) {
        dv.paragraph(\`**Damage:** \${element.damage}\`);
      }
      if (element.additional_damage) {
        dv.paragraph(\`**Additional Damage:** \${element.additional_damage}\`);
      }
      if (element.on_success) {
        dv.paragraph(\`**On Success:** \${element.on_success}\`);
      }
      if (element.on_failure) {
        dv.paragraph(\`**On Failure:** \${element.on_failure}\`);
      }
      if (element.effect) {
        dv.paragraph(\`**Effect:** \${element.effect}\`);
      }
      dv.paragraph("");
    }
  } else {
    const byInitiative = new Map();
    const constant = [];
    const dynamic = [];
    
    for (const element of elements) {
      if (element.element_type === 'constant') {
        constant.push(element);
      } else if (element.element_type === 'dynamic') {
        dynamic.push(element);
      } else if (element.initiative !== undefined) {
        if (!byInitiative.has(element.initiative)) {
          byInitiative.set(element.initiative, []);
        }
        byInitiative.get(element.initiative).push(element);
      }
    }
    
    if (byInitiative.size > 0) {
      dv.header(3, "Initiative Actions");
      const sortedInit = Array.from(byInitiative.keys()).sort((a, b) => b - a);
      for (const init of sortedInit) {
        dv.header(4, \`Initiative \${init}\`);
        for (const element of byInitiative.get(init)) {
          dv.paragraph(\`**\${element.name || "Effect"}**\`);
          if (element.attack_bonus !== undefined) {
            dv.paragraph(\`  Attack: +\${element.attack_bonus} to hit\${element.range ? \`, \${element.range}\` : ""}\`);
          }
          if (element.save_dc !== undefined) {
            dv.paragraph(\`  Save: DC \${element.save_dc} \${element.save_ability || "DEX"}\`);
          }
          if (element.damage) {
            dv.paragraph(\`  Damage: \${element.damage}\`);
          }
          if (element.additional_damage) {
            dv.paragraph(\`  Additional Damage: \${element.additional_damage}\`);
          }
          if (element.on_success) {
            dv.paragraph(\`  On Success: \${element.on_success}\`);
          }
          if (element.on_failure) {
            dv.paragraph(\`  On Failure: \${element.on_failure}\`);
          }
          if (element.effect) {
            dv.paragraph(\`  Effect: \${element.effect}\`);
          }
          dv.paragraph("");
        }
      }
    }
    
    if (dynamic.length > 0) {
      dv.header(3, "Dynamic Elements");
      for (const element of dynamic) {
        dv.paragraph(\`**\${element.name || "Dynamic Effect"}**\`);
        if (element.condition) {
          dv.paragraph(\`  Condition: \${element.condition}\`);
        }
        if (element.effect) {
          dv.paragraph(\`  Effect: \${element.effect}\`);
        }
        dv.paragraph("");
      }
    }
    
    if (constant.length > 0) {
      dv.header(3, "Constant Effects");
      for (const element of constant) {
        dv.paragraph(\`**\${element.name || "Constant Effect"}**\`);
        if (element.effect) {
          dv.paragraph(\`  \${element.effect}\`);
        }
        dv.paragraph("");
      }
    }
  }
}
\`\`\`

---

## Countermeasures

\`\`\`dataviewjs
const countermeasures = dv.current().countermeasures || [];

if (countermeasures.length === 0) {
  dv.paragraph("*No countermeasures defined.*");
} else {
  for (const cm of countermeasures) {
    dv.header(4, cm.method || "Countermeasure");
    
    if (cm.dc !== undefined) {
      dv.paragraph(\`**DC:** \${cm.dc}\`);
    }
    if (cm.checks_needed !== undefined && cm.checks_needed > 1) {
      dv.paragraph(\`**Checks Needed:** \${cm.checks_needed}\`);
    }
    if (cm.description) {
      dv.paragraph(\`**Description:** \${cm.description}\`);
    }
    if (cm.effect) {
      dv.paragraph(\`**Effect on Success:** \${cm.effect}\`);
    }
    dv.paragraph("");
  }
}
\`\`\`

---

## GM Notes

### Setup
*How to describe and introduce this trap*

### Running the Trap
*Tips for managing the trap in combat*

### Disabling
*Additional notes on countermeasures and player creativity*

---

## Session History

**Created:** ${now}

*Record when this trap was encountered and what happened*
`;
  }

  async saveStatblocks() {
    try {
      const statblocksPlugin = (this.app as any).plugins.getPlugin("obsidian-5e-statblocks");
      if (!statblocksPlugin) {
        console.warn("Fantasy Statblocks plugin not found. Statblocks will not be saved to bestiary.");
        return;
      }

      const homebrewSource = `Trap: ${this.trapName}`;
      const homebrewCreatures: any[] = [];

      if (this.trapType === 'simple') {
        // Create single statblock for simple trap
        const statblock = this.createSimpleStatblock(homebrewSource);
        homebrewCreatures.push(statblock);
      } else {
        // Create multiple statblocks for complex trap
        const statblocks = this.createComplexStatblocks(homebrewSource);
        homebrewCreatures.push(...statblocks);
      }

      // Save to Fantasy Statblocks bestiary
      if (homebrewCreatures.length > 0) {
        console.log("Attempting to save trap statblocks:", homebrewCreatures);
        
        // Try multiple methods to save the monsters
        if (statblocksPlugin.saveMonsters) {
          // Method 1: Direct saveMonsters API
          await statblocksPlugin.saveMonsters(homebrewCreatures);
          console.log(`Saved ${homebrewCreatures.length} trap statblock(s) via saveMonsters`);
        } else if (statblocksPlugin.api?.saveMonsters) {
          // Method 2: API object saveMonsters
          await statblocksPlugin.api.saveMonsters(homebrewCreatures);
          console.log(`Saved ${homebrewCreatures.length} trap statblock(s) via api.saveMonsters`);
        } else if (statblocksPlugin.data?.monsters) {
          // Method 3: Direct data manipulation
          if (!Array.isArray(statblocksPlugin.data.monsters)) {
            statblocksPlugin.data.monsters = [];
          }
          
          // Add each creature to the monsters array
          for (const creature of homebrewCreatures) {
            // Check if creature already exists (by name and source)
            const existingIndex = statblocksPlugin.data.monsters.findIndex(
              (m: any) => m.name === creature.name && m.source === creature.source
            );
            
            if (existingIndex >= 0) {
              // Replace existing creature
              statblocksPlugin.data.monsters[existingIndex] = creature;
              console.log(`Updated existing trap statblock: ${creature.name}`);
            } else {
              // Add new creature
              statblocksPlugin.data.monsters.push(creature);
              console.log(`Added new trap statblock: ${creature.name}`);
            }
          }
          
          // Save plugin data
          await statblocksPlugin.saveData(statblocksPlugin.data);
          console.log(`Saved ${homebrewCreatures.length} trap statblock(s) via data.monsters`);
        } else {
          console.warn("No valid method found to save monsters to Fantasy Statblocks plugin");
          console.warn("Available plugin methods:", Object.keys(statblocksPlugin));
          console.warn("Available plugin.api methods:", statblocksPlugin.api ? Object.keys(statblocksPlugin.api) : "No API");
        }
      }
    } catch (error) {
      console.error("Error saving trap statblocks:", error);
      console.error("Error details:", error instanceof Error ? error.message : String(error));
      // Don't fail the trap creation if statblock saving fails
    }
  }

  createSimpleStatblock(source: string): any {
    const element = this.elements[0]; // Use first element for simple trap
    
    // Build actions from trap element
    const actions: any[] = [];
    
    if (element) {
      const action: any = {
        name: element.name || "Trap Effect",
        desc: ""
      };

      if (element.attack_bonus !== undefined) {
        const range = element.range || "reach 5 ft. or range 60 ft.";
        action.desc += `Melee or Ranged Weapon Attack: +${element.attack_bonus} to hit, ${range}, one target. `;
      }

      if (element.save_dc !== undefined) {
        action.desc += `DC ${element.save_dc} ${element.save_ability || "DEX"} saving throw. `;
      }

      if (element.damage) {
        if (element.attack_bonus !== undefined) {
          action.desc += `Hit: ${element.damage} damage. `;
        } else if (element.save_dc !== undefined) {
          // Use custom success/failure text if provided
          if (element.on_failure) {
            action.desc += `On a failed save: ${element.on_failure} `;
          } else {
            action.desc += `On a failed save: ${element.damage} damage`;
            if (element.on_success) {
              action.desc += `, ${element.on_success} `;
            } else {
              action.desc += `, or half as much damage on a successful one. `;
            }
          }
        }
      } else if (element.save_dc && (element.on_failure || element.on_success)) {
        // No damage but has success/failure effects
        if (element.on_failure) {
          action.desc += `On a failed save: ${element.on_failure} `;
        }
        if (element.on_success) {
          action.desc += `On a successful save: ${element.on_success} `;
        }
      }

      if (element.additional_damage) {
        action.desc += `Additional: ${element.additional_damage}. `;
      }

      if (element.effect) {
        action.desc += element.effect;
      }

      actions.push(action);
    }

    // Build traits from countermeasures
    const traits: any[] = this.countermeasures.map(cm => ({
      name: `Countermeasure: ${cm.method}`,
      desc: `${cm.description || cm.method}${cm.dc ? ` (DC ${cm.dc})` : ''}${cm.checks_needed && cm.checks_needed > 1 ? ` Requires ${cm.checks_needed} successful checks.` : ''} ${cm.effect || ''}`
    }));

    return {
      name: this.trapName,
      source: source,
      type: "trap",
      size: "Large",
      alignment: "unaligned",
      ac: 15,
      hp: 50,
      speed: "0 ft.",
      stats: [10, 10, 10, 10, 10, 10],
      senses: "‚Äî",
      languages: "‚Äî",
      cr: this.calculateTrapCR(),
      traits: traits,
      actions: actions,
      layout: "Basic 5e Layout"
    };
  }

  createComplexStatblocks(source: string): any[] {
    const statblocks: any[] = [];

    // Group elements by initiative
    const byInitiative = new Map<number, TrapElement[]>();
    const constantElements: TrapElement[] = [];
    const dynamicElements: TrapElement[] = [];

    for (const element of this.elements) {
      if (element.element_type === 'constant') {
        constantElements.push(element);
      } else if (element.element_type === 'dynamic') {
        dynamicElements.push(element);
      } else if (element.initiative !== undefined) {
        if (!byInitiative.has(element.initiative)) {
          byInitiative.set(element.initiative, []);
        }
        byInitiative.get(element.initiative)!.push(element);
      }
    }

    console.log(`[createComplexStatblocks] Processing ${this.elements.length} elements`);
    console.log(`[createComplexStatblocks] Initiative groups: ${byInitiative.size}`);
    console.log(`[createComplexStatblocks] Constant elements: ${constantElements.length}`);
    console.log(`[createComplexStatblocks] Dynamic elements: ${dynamicElements.length}`);

    // Create statblock for each initiative group
    for (const [initiative, elements] of byInitiative.entries()) {
      console.log(`[createComplexStatblocks] Creating statblock for initiative ${initiative} with ${elements.length} elements`);
      
      const actions: any[] = elements.map(element => {
        let desc = "";

        if (element.attack_bonus !== undefined) {
          const range = element.range || "reach 5 ft. or range 60 ft.";
          desc += `Melee or Ranged Weapon Attack: +${element.attack_bonus} to hit, ${range}, one target. `;
        }

        if (element.save_dc !== undefined) {
          desc += `DC ${element.save_dc} ${element.save_ability || "DEX"} saving throw. `;
        }

        if (element.damage) {
          if (element.attack_bonus !== undefined) {
            desc += `Hit: ${element.damage} damage. `;
          } else if (element.save_dc !== undefined) {
            // Use custom success/failure text if provided
            if (element.on_failure) {
              desc += `On a failed save: ${element.on_failure} `;
            } else {
              desc += `On a failed save: ${element.damage} damage`;
              if (element.on_success) {
                desc += `, ${element.on_success} `;
              } else {
                desc += `, or half as much damage on a successful one. `;
              }
            }
          }
        } else if (element.save_dc && (element.on_failure || element.on_success)) {
          // No damage but has success/failure effects
          if (element.on_failure) {
            desc += `On a failed save: ${element.on_failure} `;
          }
          if (element.on_success) {
            desc += `On a successful save: ${element.on_success} `;
          }
        }

        if (element.additional_damage) {
          desc += `Additional: ${element.additional_damage}. `;
        }

        if (element.effect) {
          desc += element.effect;
        }

        return {
          name: element.name || "Effect",
          desc: desc
        };
      });

      const initTraits: any[] = [
        {
          name: "Fixed Initiative",
          desc: `This trap element acts on initiative count ${initiative}. Do not roll initiative for this creature.`
        }
      ];

      statblocks.push({
        name: `${this.trapName} (Initiative ${initiative})`,
        source: source,
        type: "trap",
        size: "Large",
        alignment: "unaligned",
        ac: 15,
        hp: 1,
        speed: "0 ft.",
        stats: [10, 10, 10, 10, 10, 10],
        senses: "‚Äî",
        languages: "‚Äî",
        cr: 0,
        modifier: initiative,
        initiative: initiative,  // Fixed initiative value
        traits: initTraits,
        actions: actions,
        layout: "Basic 5e Layout"
      });
      
      console.log(`[createComplexStatblocks] Added statblock: ${this.trapName} (Initiative ${initiative})`);
    }

    console.log(`[createComplexStatblocks] Total statblocks created: ${statblocks.length}`);
    
    // Create constant effects statblock if any
    if (constantElements.length > 0) {
      const traits: any[] = constantElements.map(element => ({
        name: element.name || "Constant Effect",
        desc: element.effect || ""
      }));

      statblocks.push({
        name: `${this.trapName} (Constant)`,
        source: source,
        type: "trap",
        size: "Large",
        alignment: "unaligned",
        ac: 15,
        hp: 1,
        speed: "0 ft.",
        stats: [10, 10, 10, 10, 10, 10],
        senses: "‚Äî",
        languages: "‚Äî",
        cr: 0,
        traits: traits,
        actions: [],
        layout: "Basic 5e Layout"
      });
    }

    // Create dynamic effects statblock if any
    if (dynamicElements.length > 0) {
      const traits: any[] = dynamicElements.map(element => ({
        name: element.name || "Dynamic Effect",
        desc: `${element.condition ? 'Condition: ' + element.condition + '. ' : ''}${element.effect || ''}`
      }));

      statblocks.push({
        name: `${this.trapName} (Dynamic)`,
        source: source,
        type: "trap",
        size: "Large",
        alignment: "unaligned",
        ac: 15,
        hp: 1,
        speed: "0 ft.",
        stats: [10, 10, 10, 10, 10, 10],
        senses: "‚Äî",
        languages: "‚Äî",
        cr: 0,
        traits: traits,
        actions: [],
        layout: "Basic 5e Layout"
      });
    }

    // Add countermeasures to first statblock
    if (statblocks.length > 0 && this.countermeasures.length > 0) {
      const counterTraits = this.countermeasures.map(cm => ({
        name: `Countermeasure: ${cm.method}`,
        desc: `${cm.description || cm.method}${cm.dc ? ` (DC ${cm.dc})` : ''}${cm.checks_needed && cm.checks_needed > 1 ? ` Requires ${cm.checks_needed} successful checks.` : ''} ${cm.effect || ''}`
      }));
      statblocks[0].traits = [...statblocks[0].traits, ...counterTraits];
    }

    return statblocks;
  }

  calculateTrapCR(): number {
    // Calculate average damage per activation
    let totalDamage = 0;
    let maxDC = 0;
    let maxAttackBonus = 0;
    let elementCount = 0;

    for (const element of this.elements) {
      if (element.damage) {
        // Parse damage string to get average (e.g., "4d10" -> 22, "2d6+3" -> 10)
        const avgDamage = this.parseDamageAverage(element.damage);
        totalDamage += avgDamage;
        elementCount++;
      }

      if (element.save_dc && element.save_dc > maxDC) {
        maxDC = element.save_dc;
      }

      if (element.attack_bonus && element.attack_bonus > maxAttackBonus) {
        maxAttackBonus = element.attack_bonus;
      }
    }

    // If no damage, return CR 0
    if (totalDamage === 0) {
      return 0;
    }

    // For complex traps, consider how many elements activate per round
    let dpr = totalDamage;
    if (this.trapType === 'complex') {
      // Count unique initiatives (elements that can activate in same round)
      const initiatives = new Set(
        this.elements
          .filter(e => e.element_type === 'active' && e.initiative !== undefined)
          .map(e => e.initiative)
      );
      
      // If multiple initiatives, trap deals damage over multiple rounds
      // Average DPR is lower
      if (initiatives.size > 1) {
        dpr = totalDamage / initiatives.size;
      }
    }

    // Find CR based on DPR using existing CR tables
    let estimatedCR = this.findCRByDPR(dpr);

    // Adjust based on save DC or attack bonus
    const dcOrAttack = maxDC > 0 ? maxDC : maxAttackBonus;
    if (dcOrAttack > 0) {
      const crByDC = this.findCRByDC(dcOrAttack);
      // Average the two estimates
      estimatedCR = Math.round((estimatedCR + crByDC) / 2);
    }

    // Apply threat level modifier
    if (this.threatLevel === 'dangerous') {
      estimatedCR = Math.ceil(estimatedCR * 1.25);
    } else if (this.threatLevel === 'deadly') {
      estimatedCR = Math.ceil(estimatedCR * 1.5);
    } else if (this.threatLevel === 'setback') {
      estimatedCR = Math.max(0, Math.floor(estimatedCR * 0.75));
    }

    // Clamp to reasonable range based on level range
    const minCR = Math.max(0, Math.floor(this.minLevel / 4));
    const maxCR = Math.ceil(this.maxLevel / 2);
    estimatedCR = Math.max(minCR, Math.min(maxCR, estimatedCR));

    return estimatedCR;
  }

  parseDamageAverage(damageStr: string | undefined): number {
    // Parse damage strings like "4d10", "2d6+3", "22", etc.
    if (!damageStr) return 0;
    
    let cleanDamage = damageStr.trim().toLowerCase();
    
    // Remove damage type (e.g., "4d10 fire" -> "4d10")
    const parts = cleanDamage.split(' ');
    cleanDamage = parts[0] || cleanDamage;

    // Check if it's just a number
    const staticDamage = parseInt(cleanDamage);
    if (!isNaN(staticDamage)) {
      return staticDamage;
    }

    // Parse dice notation: XdY+Z or XdY-Z or XdY
    const diceMatch = cleanDamage.match(/(\d+)d(\d+)([+-]\d+)?/);
    if (diceMatch) {
      const numDice = parseInt(diceMatch[1]!);
      const dieSize = parseInt(diceMatch[2]!);
      const modifier = diceMatch[3] ? parseInt(diceMatch[3]) : 0;
      
      // Average of XdY is X * (Y+1)/2
      const avgRoll = numDice * (dieSize + 1) / 2;
      return Math.floor(avgRoll + modifier);
    }

    // Couldn't parse, return 0
    return 0;
  }

  findCRByDPR(dpr: number): number {
    // Use existing CR table to find closest CR by DPR
    // CR table from getCRStats function
    const crDPRTable = [
      { cr: 0, dpr: 1 },
      { cr: 0.125, dpr: 2 },
      { cr: 0.25, dpr: 3 },
      { cr: 0.5, dpr: 5 },
      { cr: 1, dpr: 8 },
      { cr: 2, dpr: 15 },
      { cr: 3, dpr: 21 },
      { cr: 4, dpr: 27 },
      { cr: 5, dpr: 33 },
      { cr: 6, dpr: 39 },
      { cr: 7, dpr: 45 },
      { cr: 8, dpr: 51 },
      { cr: 9, dpr: 57 },
      { cr: 10, dpr: 63 },
      { cr: 11, dpr: 69 },
      { cr: 12, dpr: 75 },
      { cr: 13, dpr: 81 },
      { cr: 14, dpr: 87 },
      { cr: 15, dpr: 93 },
      { cr: 16, dpr: 99 },
      { cr: 17, dpr: 105 },
      { cr: 18, dpr: 111 },
      { cr: 19, dpr: 117 },
      { cr: 20, dpr: 123 },
      { cr: 21, dpr: 140 },
      { cr: 22, dpr: 150 },
      { cr: 23, dpr: 160 },
      { cr: 24, dpr: 170 },
      { cr: 25, dpr: 180 },
      { cr: 26, dpr: 190 },
      { cr: 27, dpr: 200 },
      { cr: 28, dpr: 210 },
      { cr: 29, dpr: 220 },
      { cr: 30, dpr: 230 }
    ];

    // Find closest CR
    let closestCR = 0;
    let minDiff = Infinity;

    for (const entry of crDPRTable) {
      const diff = Math.abs(entry.dpr - dpr);
      if (diff < minDiff) {
        minDiff = diff;
        closestCR = entry.cr;
      }
    }

    return Math.floor(closestCR);
  }

  findCRByDC(dc: number): number {
    // Find CR based on save DC or attack bonus
    // From DMG: DC starts at 13 for CR 0, increases by ~1 every 2-3 CR
    const crDCTable = [
      { cr: 0, dc: 13 },
      { cr: 1, dc: 13 },
      { cr: 2, dc: 13 },
      { cr: 3, dc: 13 },
      { cr: 4, dc: 14 },
      { cr: 5, dc: 15 },
      { cr: 6, dc: 15 },
      { cr: 7, dc: 15 },
      { cr: 8, dc: 16 },
      { cr: 9, dc: 16 },
      { cr: 10, dc: 16 },
      { cr: 11, dc: 17 },
      { cr: 12, dc: 17 },
      { cr: 13, dc: 18 },
      { cr: 14, dc: 18 },
      { cr: 15, dc: 18 },
      { cr: 16, dc: 18 },
      { cr: 17, dc: 19 },
      { cr: 18, dc: 19 },
      { cr: 19, dc: 19 },
      { cr: 20, dc: 19 },
      { cr: 21, dc: 20 },
      { cr: 22, dc: 20 },
      { cr: 23, dc: 20 },
      { cr: 24, dc: 21 },
      { cr: 25, dc: 22 },
      { cr: 26, dc: 22 },
      { cr: 27, dc: 22 },
      { cr: 28, dc: 23 },
      { cr: 29, dc: 23 },
      { cr: 30, dc: 24 }
    ];

    // Find closest CR
    let closestCR = 0;
    let minDiff = Infinity;

    for (const entry of crDCTable) {
      const diff = Math.abs(entry.dc - dc);
      if (diff < minDiff) {
        minDiff = diff;
        closestCR = entry.cr;
      }
    }

    return Math.floor(closestCR);
  }

  generateStatblockContent(): string {
    if (this.trapType === 'simple') {
      return this.generateSimpleStatblockContent();
    } else {
      return this.generateComplexStatblockContent();
    }
  }

  generateSimpleStatblockContent(): string {
    const element = this.elements[0];
    const homebrewSource = `Trap: ${this.trapName}`;

    let actionsContent = '';
    if (element) {
      let actionDesc = '';
      
      if (element.attack_bonus !== undefined) {
        const range = element.range || "reach 5 ft. or range 60 ft.";
        actionDesc += `Melee or Ranged Weapon Attack: +${element.attack_bonus} to hit, ${range}, one target. `;
      }
      
      if (element.save_dc !== undefined) {
        actionDesc += `DC ${element.save_dc} ${element.save_ability || "DEX"} saving throw. `;
      }
      
      if (element.damage) {
        if (element.attack_bonus !== undefined) {
          actionDesc += `Hit: ${element.damage} damage. `;
        } else if (element.save_dc !== undefined) {
          // Use custom success/failure text if provided
          if (element.on_failure) {
            actionDesc += `On a failed save: ${element.on_failure} `;
          } else {
            actionDesc += `On a failed save: ${element.damage} damage`;
            if (element.on_success) {
              actionDesc += `, ${element.on_success} `;
            } else {
              actionDesc += `, or half as much damage on a successful one. `;
            }
          }
        }
      } else if (element.save_dc && (element.on_failure || element.on_success)) {
        // No damage but has success/failure effects
        if (element.on_failure) {
          actionDesc += `On a failed save: ${element.on_failure} `;
        }
        if (element.on_success) {
          actionDesc += `On a successful save: ${element.on_success} `;
        }
      }
      
      if (element.additional_damage) {
        actionDesc += `Additional: ${element.additional_damage}. `;
      }
      
      if (element.effect) {
        actionDesc += element.effect;
      }

      actionsContent = `actions:
  - name: "${element.name || "Trap Effect"}"
    desc: "${actionDesc}"`;
    }

    let traitsContent = '';
    if (this.countermeasures.length > 0) {
      traitsContent = 'traits:\n';
      for (const cm of this.countermeasures) {
        const dcText = cm.dc ? ` (DC ${cm.dc})` : '';
        const checksText = cm.checks_needed && cm.checks_needed > 1 ? ` Requires ${cm.checks_needed} successful checks.` : '';
        const traitDesc = `${cm.description || cm.method}${dcText}${checksText} ${cm.effect || ''}`;
        traitsContent += `  - name: "Countermeasure: ${cm.method}"\n    desc: "${traitDesc}"\n`;
      }
    }

    return `\`\`\`statblock
layout: Basic 5e Layout
source: "${homebrewSource}"
name: "${this.trapName}"
type: trap
size: Large
alignment: unaligned
ac: 15
hp: 50
speed: "0 ft."
stats: [10, 10, 10, 10, 10, 10]
senses: "‚Äî"
languages: "‚Äî"
cr: ${this.calculateTrapCR()}
${traitsContent}${actionsContent}
\`\`\``;
  }

  generateComplexStatblockContent(): string {
    const homebrewSource = `Trap: ${this.trapName}`;
    let statblockContent = '';

    // Group elements by initiative
    const byInitiative = new Map<number, TrapElement[]>();
    const constantElements: TrapElement[] = [];
    const dynamicElements: TrapElement[] = [];

    for (const element of this.elements) {
      if (element.element_type === 'constant') {
        constantElements.push(element);
      } else if (element.element_type === 'dynamic') {
        dynamicElements.push(element);
      } else if (element.initiative !== undefined) {
        if (!byInitiative.has(element.initiative)) {
          byInitiative.set(element.initiative, []);
        }
        byInitiative.get(element.initiative)!.push(element);
      }
    }

    // Create statblock for each initiative
    const sortedInits = Array.from(byInitiative.keys()).sort((a, b) => b - a);
    for (const initiative of sortedInits) {
      const elements = byInitiative.get(initiative)!;
      
      let actionsContent = '';
      if (elements.length > 0) {
        actionsContent = 'actions:\n';
        for (const element of elements) {
          let actionDesc = '';
          
          if (element.attack_bonus !== undefined) {
            const range = element.range || "reach 5 ft. or range 60 ft.";
            actionDesc += `Melee or Ranged Weapon Attack: +${element.attack_bonus} to hit, ${range}, one target. `;
          }
          
          if (element.save_dc !== undefined) {
            actionDesc += `DC ${element.save_dc} ${element.save_ability || "DEX"} saving throw. `;
          }
          
          if (element.damage) {
            if (element.attack_bonus !== undefined) {
              actionDesc += `Hit: ${element.damage} damage. `;
            } else if (element.save_dc !== undefined) {
              // Use custom success/failure text if provided
              if (element.on_failure) {
                actionDesc += `On a failed save: ${element.on_failure} `;
              } else {
                actionDesc += `On a failed save: ${element.damage} damage`;
                if (element.on_success) {
                  actionDesc += `, ${element.on_success} `;
                } else {
                  actionDesc += `, or half as much damage on a successful one. `;
                }
              }
            }
          } else if (element.save_dc && (element.on_failure || element.on_success)) {
            // No damage but has success/failure effects
            if (element.on_failure) {
              actionDesc += `On a failed save: ${element.on_failure} `;
            }
            if (element.on_success) {
              actionDesc += `On a successful save: ${element.on_success} `;
            }
          }
          
          if (element.additional_damage) {
            actionDesc += `Additional: ${element.additional_damage}. `;
          }
          
          if (element.effect) {
            actionDesc += element.effect;
          }

          actionsContent += `  - name: "${element.name || "Effect"}"\n    desc: "${actionDesc}"\n`;
        }
      }

      const traitsContent = `traits:
  - name: "Fixed Initiative"
    desc: "This trap element acts on initiative count ${initiative}. Do not roll initiative for this creature."
`;

      statblockContent += `\n\`\`\`statblock
layout: Basic 5e Layout
source: "${homebrewSource}"
name: "${this.trapName} (Initiative ${initiative})"
type: trap
size: Large
alignment: unaligned
ac: 15
hp: 1
modifier: ${initiative}
initiative: ${initiative}
speed: "0 ft."
stats: [10, 10, 10, 10, 10, 10]
senses: "‚Äî"
languages: "‚Äî"
cr: 0
${traitsContent}${actionsContent}\`\`\`\n`;
    }

    // Add constant effects statblock
    if (constantElements.length > 0) {
      let traitsContent = 'traits:\n';
      for (const element of constantElements) {
        traitsContent += `  - name: "${element.name || "Constant Effect"}"\n    desc: "${element.effect || ""}"\n`;
      }

      statblockContent += `\n\`\`\`statblock
layout: Basic 5e Layout
source: "${homebrewSource}"
name: "${this.trapName} (Constant)"
type: trap
size: Large
alignment: unaligned
ac: 15
hp: 1
speed: "0 ft."
stats: [10, 10, 10, 10, 10, 10]
senses: "‚Äî"
languages: "‚Äî"
cr: 0
${traitsContent}\`\`\`\n`;
    }

    // Add dynamic effects statblock
    if (dynamicElements.length > 0) {
      let traitsContent = 'traits:\n';
      for (const element of dynamicElements) {
        const traitDesc = `${element.condition ? 'Condition: ' + element.condition + '. ' : ''}${element.effect || ''}`;
        traitsContent += `  - name: "${element.name || "Dynamic Effect"}"\n    desc: "${traitDesc}"\n`;
      }

      statblockContent += `\n\`\`\`statblock
layout: Basic 5e Layout
source: "${homebrewSource}"
name: "${this.trapName} (Dynamic)"
type: trap
size: Large
alignment: unaligned
ac: 15
hp: 1
speed: "0 ft."
stats: [10, 10, 10, 10, 10, 10]
senses: "‚Äî"
languages: "‚Äî"
cr: 0
${traitsContent}\`\`\`\n`;
    }

    // Add countermeasures to first statblock or as separate section
    if (this.countermeasures.length > 0) {
      statblockContent += '\n## Countermeasures\n\n';
      for (const cm of this.countermeasures) {
        const dcText = cm.dc ? ` (DC ${cm.dc})` : '';
        const checksText = cm.checks_needed && cm.checks_needed > 1 ? ` Requires ${cm.checks_needed} successful checks.` : '';
        const cmDesc = `${cm.description || cm.method}${dcText}${checksText} ${cm.effect || ''}`;
        statblockContent += `- **${cm.method}:** ${cmDesc}\n`;
      }
    }

    return statblockContent;
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class ItemCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  itemName = "";
  itemType: 'simple' | 'evolving' = 'simple';
  rarity: 'common' | 'uncommon' | 'rare' | 'very rare' | 'legendary' | 'artifact' = 'common';
  requiresAttunement = false;
  attunementRequirement = "";
  category: 'weapon' | 'armor' | 'wondrous' | 'potion' | 'scroll' | 'ring' | 'rod' | 'staff' | 'wand' | 'other' = 'other';
  
  // Simple item properties
  description = "";
  weight = "";
  value = "";
  
  // Evolving item properties
  evolvesWithLevel = false;
  levelThresholds: { level: number; description: string }[] = [];
  
  // Container for level thresholds UI
  levelThresholdsContainer: HTMLElement | null = null;

  // For editing existing items
  isEdit = false;
  originalItemPath = "";
  originalItemName = "";

  constructor(app: App, plugin: DndCampaignHubPlugin, itemPath?: string) {
    super(app);
    this.plugin = plugin;
    if (itemPath) {
      this.isEdit = true;
      this.originalItemPath = itemPath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    
    // Load existing item data if editing
    if (this.isEdit) {
      await this.loadItemData();
    }
    
    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit Item" : "‚öîÔ∏è Create New Item" });

    // Item Name
    new Setting(contentEl)
      .setName("Item Name")
      .setDesc("Name of the item")
      .addText((text) =>
        text
          .setPlaceholder("Sword of the Planes")
          .setValue(this.itemName)
          .onChange((value) => {
            this.itemName = value;
          })
      );

    // Item Type
    new Setting(contentEl)
      .setName("Item Type")
      .setDesc("Simple items are standard D&D items. Evolving items grow with the character's level.")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("simple", "Simple D&D 5e Item")
          .addOption("evolving", "Evolving Homebrew Item")
          .setValue(this.itemType)
          .onChange((value) => {
            this.itemType = value as 'simple' | 'evolving';
            this.refreshUI();
          })
      );

    // Category
    new Setting(contentEl)
      .setName("Category")
      .setDesc("Type of item")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("weapon", "Weapon")
          .addOption("armor", "Armor")
          .addOption("wondrous", "Wondrous Item")
          .addOption("potion", "Potion")
          .addOption("scroll", "Scroll")
          .addOption("ring", "Ring")
          .addOption("rod", "Rod")
          .addOption("staff", "Staff")
          .addOption("wand", "Wand")
          .addOption("other", "Other")
          .setValue(this.category)
          .onChange((value: any) => {
            this.category = value;
          })
      );

    // Rarity
    new Setting(contentEl)
      .setName("Rarity")
      .setDesc("How rare is this item?")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("common", "Common")
          .addOption("uncommon", "Uncommon")
          .addOption("rare", "Rare")
          .addOption("very rare", "Very Rare")
          .addOption("legendary", "Legendary")
          .addOption("artifact", "Artifact")
          .setValue(this.rarity)
          .onChange((value: any) => {
            this.rarity = value;
          })
      );

    // Requires Attunement
    new Setting(contentEl)
      .setName("Requires Attunement")
      .setDesc("Does this item require attunement?")
      .addToggle((toggle) =>
        toggle
          .setValue(this.requiresAttunement)
          .onChange((value) => {
            this.requiresAttunement = value;
            this.refreshUI();
          })
      );

    // Attunement Requirement (conditional)
    if (this.requiresAttunement) {
      new Setting(contentEl)
        .setName("Attunement Requirement")
        .setDesc("e.g., 'by a spellcaster', 'by a paladin', leave empty for no specific requirement")
        .addText((text) => {
          text
            .setPlaceholder("by a wizard")
            .setValue(this.attunementRequirement)
            .onChange((value) => {
              this.attunementRequirement = value;
            });
          text.inputEl.style.width = "100%";
        });
    }

    // Weight and Value
    new Setting(contentEl)
      .setName("Weight")
      .setDesc("Item weight (e.g., '3 lb.')")
      .addText((text) =>
        text
          .setPlaceholder("3 lb.")
          .setValue(this.weight)
          .onChange((value) => {
            this.weight = value;
          })
      );

    new Setting(contentEl)
      .setName("Value")
      .setDesc("Item value (e.g., '500 gp')")
      .addText((text) =>
        text
          .setPlaceholder("500 gp")
          .setValue(this.value)
          .onChange((value) => {
            this.value = value;
          })
      );

    // Description
    new Setting(contentEl)
      .setName(this.itemType === 'simple' ? "Description" : "Base Description")
      .setDesc(this.itemType === 'simple' ? "Full description of the item and its properties" : "Base properties of the item before it evolves")
      .addTextArea((text) => {
        text
          .setPlaceholder(
            this.itemType === 'simple' 
              ? "This magical sword glows with an inner light..." 
              : "This blade contains dormant power that awakens as its wielder grows stronger..."
          )
          .setValue(this.description)
          .onChange((value) => {
            this.description = value;
          });
        text.inputEl.rows = 8;
        text.inputEl.style.width = "100%";
      });

    // Evolving Item Section
    if (this.itemType === 'evolving') {
      contentEl.createEl("h3", { text: "Evolution Thresholds" });
      contentEl.createEl("p", { 
        text: "Define how the item evolves at different character levels",
        cls: "setting-item-description"
      });
      
      this.levelThresholdsContainer = contentEl.createDiv();
      this.renderLevelThresholds();

      new Setting(contentEl)
        .addButton((button) =>
          button
            .setButtonText("+ Add Level Threshold")
            .onClick(() => {
              this.addLevelThreshold();
            })
        );
    }

    // Campaign Selection
    const campaigns = await this.getAllCampaigns();
    if (campaigns.length > 0) {
      let selectedCampaign = campaigns[0]?.path || "";
      
      contentEl.createEl("h3", { text: "Save Location" });
      new Setting(contentEl)
        .setName("Campaign")
        .setDesc("Which campaign should this item be saved to?")
        .addDropdown((dropdown) => {
          campaigns.forEach(campaign => {
            dropdown.addOption(campaign.path, campaign.name);
          });
          dropdown.setValue(selectedCampaign)
            .onChange((value) => {
              selectedCampaign = value;
            });
          
          // Add create/update button
          new Setting(contentEl)
            .addButton((button) =>
              button
                .setButtonText(this.isEdit ? "Update Item" : "Create Item")
                .setCta()
                .onClick(async () => {
                  await this.createItem(selectedCampaign);
                })
            );
        });
    } else {
      contentEl.createEl("p", { 
        text: "‚ö†Ô∏è No campaigns found. Please create a campaign first.",
        cls: "mod-warning"
      });
    }
  }

  refreshUI() {
    this.onOpen();
  }

  addLevelThreshold() {
    this.levelThresholds.push({
      level: this.levelThresholds.length > 0 
        ? Math.max(...this.levelThresholds.map(t => t.level)) + 1 
        : 5,
      description: ""
    });
    this.renderLevelThresholds();
  }

  removeLevelThreshold(index: number) {
    this.levelThresholds.splice(index, 1);
    this.renderLevelThresholds();
  }

  renderLevelThresholds() {
    if (!this.levelThresholdsContainer) return;
    
    this.levelThresholdsContainer.empty();

    this.levelThresholds.forEach((threshold, index) => {
      const thresholdEl = this.levelThresholdsContainer!.createDiv({ cls: "trap-element-item" });
      
      const heading = thresholdEl.createEl("h4", { text: `Level Threshold` });

      new Setting(thresholdEl)
        .setName("Character Level")
        .addText((text) =>
          text
            .setValue(threshold.level.toString())
            .onChange((value) => {
              const num = parseInt(value);
              if (!isNaN(num) && num >= 1 && num <= 20) {
                threshold.level = num;
                heading.textContent = `Level ${num} Threshold`;
              }
            })
        );

      new Setting(thresholdEl)
        .setName("Evolution Description")
        .setDesc("What new abilities or properties does the item gain at this level?")
        .addTextArea((text) => {
          text
            .setPlaceholder("The weapon gains +1 to attack and damage rolls...")
            .setValue(threshold.description)
            .onChange((value) => {
              threshold.description = value;
            });
          text.inputEl.rows = 4;
          text.inputEl.style.width = "100%";
        });

      new Setting(thresholdEl)
        .addButton((button) =>
          button
            .setButtonText("Remove")
            .setWarning()
            .onClick(() => {
              this.removeLevelThreshold(index);
            })
        );
    });
  }

  async getAllCampaigns(): Promise<Array<{ path: string; name: string }>> {
    const campaigns: Array<{ path: string; name: string }> = [];
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");

    if (ttrpgsFolder instanceof TFolder) {
      for (const child of ttrpgsFolder.children) {
        if (child instanceof TFolder) {
          campaigns.push({
            path: child.path,
            name: child.name
          });
        }
      }
    }

    return campaigns;
  }

  async loadItemData() {
    try {
      const itemFile = this.app.vault.getAbstractFileByPath(this.originalItemPath);
      if (!(itemFile instanceof TFile)) {
        new Notice("Item file not found!");
        return;
      }

      const cache = this.app.metadataCache.getFileCache(itemFile);
      const frontmatter = cache?.frontmatter;

      if (!frontmatter) {
        new Notice("Could not read item data!");
        return;
      }

      // Load basic item properties
      this.itemName = frontmatter.name || itemFile.basename;
      this.originalItemName = this.itemName; // Store original name
      this.itemType = frontmatter.item_type || 'simple';
      this.category = frontmatter.category || 'other';
      this.rarity = frontmatter.rarity || 'common';
      this.requiresAttunement = frontmatter.requires_attunement || false;
      this.attunementRequirement = frontmatter.attunement_requirement || "";
      this.weight = frontmatter.weight || "";
      this.value = frontmatter.value || "";

      // Load description from file content
      const content = await this.app.vault.read(itemFile);
      
      // Extract description based on item type
      if (this.itemType === 'simple') {
        const descMatch = content.match(/##\s*Description\s*\n\n([\s\S]*?)(?:\n##|$)/);
        if (descMatch && descMatch[1]) {
          this.description = descMatch[1].trim();
        }
      } else {
        const basePropsMatch = content.match(/##\s*Base Properties\s*\n\n([\s\S]*?)(?:\n##|$)/);
        if (basePropsMatch && basePropsMatch[1]) {
          this.description = basePropsMatch[1].trim();
        }
        
        // Load level thresholds
        const evolutionMatch = content.match(/##\s*Evolution\s*\n\n[\s\S]*?(?=\n##|$)/);
        if (evolutionMatch) {
          const levelMatches = content.matchAll(/###\s*Level\s*(\d+)\s*\n\n([\s\S]*?)(?=\n###|\n##|$)/g);
          this.levelThresholds = [];
          for (const match of levelMatches) {
            if (match[1] && match[2]) {
              this.levelThresholds.push({
                level: parseInt(match[1]),
                description: match[2].trim()
              });
            }
          }
        }
      }

      console.log(`[Item Edit] Loaded item data: ${this.itemName}`);
    } catch (error) {
      console.error("Error loading item data:", error);
      new Notice("Error loading item data. Check console for details.");
    }
  }

  async createItem(campaignPath: string) {
    if (!this.itemName.trim()) {
      new Notice("Please enter an item name");
      return;
    }

    try {
      // Determine campaign name and world
      const campaignName = campaignPath.split('/').pop() || "Unknown";
      let worldName = campaignName;
      
      const worldFile = this.app.vault.getAbstractFileByPath(`${campaignPath}/World.md`);
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const worldMatch = worldContent.match(/^world:\s*([^\r\n]+)$/m);
        if (worldMatch && worldMatch[1]) {
          worldName = worldMatch[1].trim();
        }
      }

      let itemPath: string;
      let itemFile: TFile | null = null;

      if (this.isEdit) {
        // Editing existing item
        itemFile = this.app.vault.getAbstractFileByPath(this.originalItemPath) as TFile;
        if (!itemFile) {
          new Notice("Original item file not found!");
          return;
        }
        itemPath = this.originalItemPath;

        // If item name changed, rename the file
        if (this.itemName !== this.originalItemName) {
          const folder = itemPath.substring(0, itemPath.lastIndexOf('/'));
          const newPath = `${folder}/${this.itemName}.md`;
          
          // Check if new name conflicts
          if (await this.app.vault.adapter.exists(newPath)) {
            new Notice(`An item named "${this.itemName}" already exists!`);
            return;
          }
          
          await this.app.fileManager.renameFile(itemFile, newPath);
          itemPath = newPath;
          itemFile = this.app.vault.getAbstractFileByPath(newPath) as TFile;
        }
      } else {
        // Creating new item
        // Create Items folder if it doesn't exist
        const itemsFolder = `${campaignPath}/Items`;
        if (!(await this.app.vault.adapter.exists(itemsFolder))) {
          await this.app.vault.createFolder(itemsFolder);
        }

        itemPath = `${itemsFolder}/${this.itemName}.md`;

        // Check if item already exists
        if (await this.app.vault.adapter.exists(itemPath)) {
          new Notice(`An item named "${this.itemName}" already exists!`);
          return;
        }
      }

      // Create item content
      const itemContent = this.createItemContent(campaignName, worldName);

      // Create or update the file
      if (this.isEdit && itemFile) {
        await this.app.vault.modify(itemFile, itemContent);
        new Notice(`Item "${this.itemName}" updated!`);
      } else {
        await this.app.vault.create(itemPath, itemContent);
        new Notice(`Item "${this.itemName}" created!`);
        itemFile = this.app.vault.getAbstractFileByPath(itemPath) as TFile;
      }

      this.close();

      // Open the file
      if (itemFile) {
        await this.app.workspace.openLinkText(itemPath, "", false);
      }
    } catch (error) {
      console.error("Error creating/editing item:", error);
      new Notice("Failed to save item. Check console for details.");
    }
  }

  createItemContent(campaignName: string, worldName: string): string {
    const currentDate = window.moment().format("YYYY-MM-DD");
    
    // Build attunement string
    let attunementText = "";
    if (this.requiresAttunement) {
      attunementText = this.attunementRequirement 
        ? `requires attunement ${this.attunementRequirement}`
        : "requires attunement";
    }

    // Create frontmatter
    let frontmatter = `---
type: item
name: '${this.itemName}'
item_type: ${this.itemType}
category: ${this.category}
rarity: ${this.rarity}
requires_attunement: ${this.requiresAttunement}`;

    if (this.attunementRequirement) {
      frontmatter += `\nattunement_requirement: '${this.attunementRequirement}'`;
    }

    if (this.weight) {
      frontmatter += `\nweight: '${this.weight}'`;
    }

    if (this.value) {
      frontmatter += `\nvalue: '${this.value}'`;
    }

    frontmatter += `\ncampaign: '${campaignName}'
world: '${worldName}'
date: ${currentDate}
template_version: '1.1.0'
---

`;

    // Create content body
    let content = `# ${this.itemName}\n\n`;

    // Add edit/delete buttons
    content += `\`\`\`dataviewjs
// Action buttons for item management
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Edit Item button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit Item",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-item");
});

// Delete Item button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete Item",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-item");
});
\`\`\`

`;

    // Item header with rarity and attunement
    const rarityCapitalized = this.rarity.charAt(0).toUpperCase() + this.rarity.slice(1);
    const categoryText = this.category !== 'other' ? this.category : 'item';
    content += `*${rarityCapitalized} ${categoryText}`;
    if (attunementText) {
      content += ` (${attunementText})`;
    }
    content += `*\n\n`;

    // Properties
    if (this.weight || this.value) {
      content += `## Properties\n\n`;
      if (this.weight) content += `- **Weight:** ${this.weight}\n`;
      if (this.value) content += `- **Value:** ${this.value}\n`;
      content += `\n`;
    }

    // Description
    if (this.itemType === 'simple') {
      content += `## Description\n\n${this.description}\n\n`;
    } else {
      content += `## Base Properties\n\n${this.description}\n\n`;
      
      // Evolution section
      if (this.levelThresholds.length > 0) {
        content += `## Evolution\n\n`;
        content += `This item evolves as its attuned owner gains levels, unlocking new abilities:\n\n`;
        
        // Sort by level
        const sortedThresholds = [...this.levelThresholds].sort((a, b) => a.level - b.level);
        
        for (const threshold of sortedThresholds) {
          content += `### Level ${threshold.level}\n\n`;
          content += `${threshold.description}\n\n`;
        }
      }
    }

    // Notes section
    content += `## Notes\n\n_Add any additional notes about the item's history, lore, or usage here._\n`;

    return frontmatter + content;
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class CreatureCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  
  // For editing existing creatures
  isEdit = false;
  originalCreaturePath = "";
  originalCreatureName = "";
  
  // Token ID for map markers
  tokenId = "";
  
  // Creature properties
  creatureName = "";
  size: 'Tiny' | 'Small' | 'Medium' | 'Large' | 'Huge' | 'Gargantuan' = 'Medium';
  type = "";
  subtype = "";
  alignment = "";
  ac = "";
  hp = "";
  hitDice = "";
  speed = "";
  
  // Ability scores
  str = 10;
  dex = 10;
  con = 10;
  int = 10;
  wis = 10;
  cha = 10;
  
  // Optional fields
  saves: string[] = [];
  skills: string[] = [];
  vulnerabilities = "";
  resistances = "";
  immunities = "";
  conditionImmunities = "";
  senses = "";
  languages = "";
  cr = "";
  
  // Features and actions
  traits: Array<{name: string, desc: string}> = [];
  actions: Array<{name: string, desc: string}> = [];
  bonusActions: Array<{name: string, desc: string}> = [];
  reactions: Array<{name: string, desc: string}> = [];
  legendaryActions: Array<{name: string, desc: string}> = [];
  
  // Description
  description = "";

  constructor(app: App, plugin: DndCampaignHubPlugin, creaturePath?: string) {
    super(app);
    this.plugin = plugin;
    if (creaturePath) {
      this.isEdit = true;
      this.originalCreaturePath = creaturePath;
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("creature-creation-modal");
    
    // Load existing creature data if editing
    if (this.isEdit) {
      await this.loadCreatureData();
    }
    
    contentEl.createEl("h2", { text: this.isEdit ? "‚úèÔ∏è Edit Creature" : "üêâ Create New Creature" });

    // Import section
    contentEl.createEl("h3", { text: "Import from Text" });
    contentEl.createEl("p", { 
      text: "Paste a D&D Beyond or similar statblock below to auto-fill the form:",
      cls: "setting-item-description"
    });

    const importContainer = contentEl.createDiv({ cls: "creature-import-container" });
    const importTextArea = importContainer.createEl("textarea", {
      placeholder: "Paste creature statblock here (e.g., from D&D Beyond)...",
      attr: { rows: "8", style: "width: 100%; margin-bottom: 10px;" }
    });

    const importButton = importContainer.createEl("button", {
      text: "üì• Parse Statblock",
      cls: "mod-cta"
    });

    importButton.addEventListener("click", () => {
      this.parseStatblockText(importTextArea.value);
      this.refreshUI();
      new Notice("Statblock parsed! Review and adjust fields below.");
    });

    contentEl.createEl("hr");
    contentEl.createEl("h3", { text: "Creature Details" });

    // Basic Info
    new Setting(contentEl)
      .setName("Creature Name")
      .setDesc("Name of the creature")
      .addText((text) =>
        text
          .setPlaceholder("Frost Giant Zombie")
          .setValue(this.creatureName)
          .onChange((value) => {
            this.creatureName = value;
          })
      );

    new Setting(contentEl)
      .setName("Size")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("Tiny", "Tiny")
          .addOption("Small", "Small")
          .addOption("Medium", "Medium")
          .addOption("Large", "Large")
          .addOption("Huge", "Huge")
          .addOption("Gargantuan", "Gargantuan")
          .setValue(this.size)
          .onChange((value) => {
            this.size = value as any;
          })
      );

    new Setting(contentEl)
      .setName("Type")
      .setDesc("Creature type (e.g., undead, elemental, humanoid)")
      .addText((text) =>
        text
          .setPlaceholder("undead")
          .setValue(this.type)
          .onChange((value) => {
            this.type = value;
          })
      );

    new Setting(contentEl)
      .setName("Subtype/Tags")
      .setDesc("Optional subtype or tags (e.g., goblinoid, shapechanger)")
      .addText((text) =>
        text
          .setPlaceholder("giant")
          .setValue(this.subtype)
          .onChange((value) => {
            this.subtype = value;
          })
      );

    new Setting(contentEl)
      .setName("Alignment")
      .addText((text) =>
        text
          .setPlaceholder("neutral evil")
          .setValue(this.alignment)
          .onChange((value) => {
            this.alignment = value;
          })
      );

    // Combat Stats
    contentEl.createEl("h3", { text: "Combat Statistics" });

    new Setting(contentEl)
      .setName("Armor Class")
      .addText((text) =>
        text
          .setPlaceholder("15")
          .setValue(this.ac)
          .onChange((value) => {
            this.ac = value;
          })
      );

    new Setting(contentEl)
      .setName("Hit Points")
      .addText((text) =>
        text
          .setPlaceholder("138")
          .setValue(this.hp)
          .onChange((value) => {
            this.hp = value;
          })
      );

    new Setting(contentEl)
      .setName("Hit Dice")
      .setDesc("Format: XdY + Z (e.g., 12d12 + 60)")
      .addText((text) =>
        text
          .setPlaceholder("12d12 + 60")
          .setValue(this.hitDice)
          .onChange((value) => {
            this.hitDice = value;
          })
      );

    new Setting(contentEl)
      .setName("Speed")
      .setDesc("All movement speeds (e.g., 40 ft., fly 30 ft.)")
      .addText((text) =>
        text
          .setPlaceholder("40 ft.")
          .setValue(this.speed)
          .onChange((value) => {
            this.speed = value;
          })
      );

    // Ability Scores
    contentEl.createEl("h3", { text: "Ability Scores" });
    
    const abilityScoresContainer = contentEl.createDiv({ cls: "ability-scores-grid" });
    abilityScoresContainer.style.display = "grid";
    abilityScoresContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
    abilityScoresContainer.style.gap = "10px";

    this.createAbilityScore(abilityScoresContainer, "STR", this.str, (val) => this.str = val);
    this.createAbilityScore(abilityScoresContainer, "DEX", this.dex, (val) => this.dex = val);
    this.createAbilityScore(abilityScoresContainer, "CON", this.con, (val) => this.con = val);
    this.createAbilityScore(abilityScoresContainer, "INT", this.int, (val) => this.int = val);
    this.createAbilityScore(abilityScoresContainer, "WIS", this.wis, (val) => this.wis = val);
    this.createAbilityScore(abilityScoresContainer, "CHA", this.cha, (val) => this.cha = val);

    // Additional Stats
    contentEl.createEl("h3", { text: "Additional Statistics" });

    new Setting(contentEl)
      .setName("Saving Throws")
      .setDesc("Comma-separated (e.g., WIS +2, CON +5)")
      .addText((text) =>
        text
          .setPlaceholder("WIS +2")
          .setValue(this.saves.join(", "))
          .onChange((value) => {
            this.saves = value ? value.split(",").map(s => s.trim()) : [];
          })
      );

    new Setting(contentEl)
      .setName("Skills")
      .setDesc("Comma-separated (e.g., Perception +4, Stealth +6)")
      .addText((text) =>
        text
          .setPlaceholder("Perception +4")
          .setValue(this.skills.join(", "))
          .onChange((value) => {
            this.skills = value ? value.split(",").map(s => s.trim()) : [];
          })
      );

    new Setting(contentEl)
      .setName("Damage Vulnerabilities")
      .addText((text) =>
        text
          .setPlaceholder("Fire")
          .setValue(this.vulnerabilities)
          .onChange((value) => {
            this.vulnerabilities = value;
          })
      );

    new Setting(contentEl)
      .setName("Damage Resistances")
      .addText((text) =>
        text
          .setPlaceholder("Lightning, Poison")
          .setValue(this.resistances)
          .onChange((value) => {
            this.resistances = value;
          })
      );

    new Setting(contentEl)
      .setName("Damage Immunities")
      .addText((text) =>
        text
          .setPlaceholder("Poison, Cold")
          .setValue(this.immunities)
          .onChange((value) => {
            this.immunities = value;
          })
      );

    new Setting(contentEl)
      .setName("Condition Immunities")
      .addText((text) =>
        text
          .setPlaceholder("Poisoned")
          .setValue(this.conditionImmunities)
          .onChange((value) => {
            this.conditionImmunities = value;
          })
      );

    new Setting(contentEl)
      .setName("Senses")
      .addText((text) =>
        text
          .setPlaceholder("Darkvision 60 ft.")
          .setValue(this.senses)
          .onChange((value) => {
            this.senses = value;
          })
      );

    new Setting(contentEl)
      .setName("Languages")
      .addText((text) =>
        text
          .setPlaceholder("understands Giant but can't speak")
          .setValue(this.languages)
          .onChange((value) => {
            this.languages = value;
          })
      );

    new Setting(contentEl)
      .setName("Challenge Rating")
      .addText((text) =>
        text
          .setPlaceholder("9")
          .setValue(this.cr)
          .onChange((value) => {
            this.cr = value;
          })
      );

    // Traits
    contentEl.createEl("h3", { text: "Traits & Features" });
    contentEl.createEl("p", { 
      text: "Passive abilities and special features",
      cls: "setting-item-description"
    });

    const traitsContainer = contentEl.createDiv({ cls: "creature-features-container" });
    this.renderFeatureList(traitsContainer, this.traits, "Trait");

    new Setting(contentEl)
      .addButton((button) =>
        button
          .setButtonText("+ Add Trait")
          .onClick(() => {
            this.traits.push({ name: "", desc: "" });
            this.refreshUI();
          })
      );

    // Actions
    contentEl.createEl("h3", { text: "Actions" });
    const actionsContainer = contentEl.createDiv({ cls: "creature-features-container" });
    this.renderFeatureList(actionsContainer, this.actions, "Action");

    new Setting(contentEl)
      .addButton((button) =>
        button
          .setButtonText("+ Add Action")
          .onClick(() => {
            this.actions.push({ name: "", desc: "" });
            this.refreshUI();
          })
      );

    // Description
    contentEl.createEl("h3", { text: "Description" });
    new Setting(contentEl)
      .setName("Creature Description")
      .setDesc("Lore, appearance, and behavior")
      .addTextArea((text) => {
        text
          .setPlaceholder("Describe the creature...")
          .setValue(this.description)
          .onChange((value) => {
            this.description = value;
          });
        text.inputEl.rows = 6;
        text.inputEl.style.width = "100%";
      });

    // Create/Update Button
    new Setting(contentEl)
      .addButton((button) =>
        button
          .setButtonText(this.isEdit ? "Update Creature" : "Create Creature")
          .setCta()
          .onClick(async () => {
            await this.saveCreature();
          })
      );
  }

  createAbilityScore(container: HTMLElement, ability: string, value: number, onChange: (val: number) => void) {
    const abilityDiv = container.createDiv({ cls: "ability-score" });
    abilityDiv.createEl("label", { text: ability, attr: { style: "font-weight: bold;" } });
    const input = abilityDiv.createEl("input", {
      type: "number",
      value: value.toString(),
      attr: { min: "1", max: "30", style: "width: 100%;" }
    });
    
    const modifier = Math.floor((value - 10) / 2);
    const modText = abilityDiv.createEl("span", { 
      text: ` (${modifier >= 0 ? '+' : ''}${modifier})`,
      attr: { style: "font-size: 0.9em; color: #888;" }
    });

    input.addEventListener("change", () => {
      const val = parseInt(input.value);
      if (!isNaN(val) && val >= 1 && val <= 30) {
        onChange(val);
        const newMod = Math.floor((val - 10) / 2);
        modText.textContent = ` (${newMod >= 0 ? '+' : ''}${newMod})`;
      }
    });
  }

  renderFeatureList(container: HTMLElement, features: Array<{name: string, desc: string}>, type: string) {
    container.empty();
    
    features.forEach((feature, index) => {
      const featureDiv = container.createDiv({ cls: "creature-feature-item" });
      featureDiv.style.marginBottom = "15px";
      featureDiv.style.padding = "10px";
      featureDiv.style.border = "1px solid #ccc";
      featureDiv.style.borderRadius = "4px";

      new Setting(featureDiv)
        .setName(`${type} Name`)
        .addText((text) =>
          text
            .setPlaceholder("Feature name")
            .setValue(feature.name)
            .onChange((value) => {
              feature.name = value;
            })
        );

      new Setting(featureDiv)
        .setName(`${type} Description`)
        .addTextArea((text) => {
          text
            .setPlaceholder("Feature description...")
            .setValue(feature.desc)
            .onChange((value) => {
              feature.desc = value;
            });
          text.inputEl.rows = 3;
          text.inputEl.style.width = "100%";
        });

      new Setting(featureDiv)
        .addButton((button) =>
          button
            .setButtonText("Remove")
            .setWarning()
            .onClick(() => {
              features.splice(index, 1);
              this.refreshUI();
            })
        );
    });
  }

  parseStatblockText(text: string) {
    if (!text || text.trim().length === 0) {
      new Notice("Please paste a statblock first");
      return;
    }

    // Extract creature name (first line)
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
    if (lines.length > 0 && lines[0]) {
      this.creatureName = lines[0];
    }

    // Extract size, type, alignment
    const sizeTypeLine = text.match(/^(Tiny|Small|Medium|Large|Huge|Gargantuan)\s+(.+?),\s*(.+)$/m);
    if (sizeTypeLine && sizeTypeLine[1] && sizeTypeLine[2] && sizeTypeLine[3]) {
      this.size = sizeTypeLine[1] as any;
      this.type = sizeTypeLine[2].trim();
      this.alignment = sizeTypeLine[3].trim();
    }

    // Extract AC
    const acMatch = text.match(/Armor Class\s+(\d+)/i);
    if (acMatch && acMatch[1]) this.ac = acMatch[1];

    // Extract HP
    const hpMatch = text.match(/Hit Points\s+(\d+)/i);
    if (hpMatch && hpMatch[1]) this.hp = hpMatch[1];

    // Extract Hit Dice
    const hitDiceMatch = text.match(/Hit Points\s+\d+\s+\(([^)]+)\)/i);
    if (hitDiceMatch && hitDiceMatch[1]) this.hitDice = hitDiceMatch[1];

    // Extract Speed
    const speedMatch = text.match(/Speed\s+(.+?)(?:\n|STR)/i);
    if (speedMatch && speedMatch[1]) this.speed = speedMatch[1].trim();

    // Extract ability scores
    const strMatch = text.match(/STR\s*\n?\s*(\d+)/i);
    const dexMatch = text.match(/DEX\s*\n?\s*(\d+)/i);
    const conMatch = text.match(/CON\s*\n?\s*(\d+)/i);
    const intMatch = text.match(/INT\s*\n?\s*(\d+)/i);
    const wisMatch = text.match(/WIS\s*\n?\s*(\d+)/i);
    const chaMatch = text.match(/CHA\s*\n?\s*(\d+)/i);

    if (strMatch && strMatch[1]) this.str = parseInt(strMatch[1]);
    if (dexMatch && dexMatch[1]) this.dex = parseInt(dexMatch[1]);
    if (conMatch && conMatch[1]) this.con = parseInt(conMatch[1]);
    if (intMatch && intMatch[1]) this.int = parseInt(intMatch[1]);
    if (wisMatch && wisMatch[1]) this.wis = parseInt(wisMatch[1]);
    if (chaMatch && chaMatch[1]) this.cha = parseInt(chaMatch[1]);

    // Extract saving throws
    const savesMatch = text.match(/Saving Throws\s+(.+?)(?:\n|Damage|Skills|Senses)/i);
    if (savesMatch && savesMatch[1]) {
      this.saves = savesMatch[1].trim().split(',').map(s => s.trim());
    }

    // Extract skills
    const skillsMatch = text.match(/Skills\s+(.+?)(?:\n|Damage|Senses|Languages)/i);
    if (skillsMatch && skillsMatch[1]) {
      this.skills = skillsMatch[1].trim().split(',').map(s => s.trim());
    }

    // Extract vulnerabilities
    const vulnMatch = text.match(/Damage Vulnerabilities\s+(.+?)(?:\n|Damage|Condition|Senses)/i);
    if (vulnMatch && vulnMatch[1]) this.vulnerabilities = vulnMatch[1].trim();

    // Extract resistances
    const resistMatch = text.match(/Damage Resistances\s+(.+?)(?:\n|Damage|Condition|Senses)/i);
    if (resistMatch && resistMatch[1]) this.resistances = resistMatch[1].trim();

    // Extract immunities
    const immuneMatch = text.match(/Damage Immunities\s+(.+?)(?:\n|Condition|Senses|Languages)/i);
    if (immuneMatch && immuneMatch[1]) this.immunities = immuneMatch[1].trim();

    // Extract condition immunities
    const condImmuneMatch = text.match(/Condition Immunities\s+(.+?)(?:\n|Senses|Languages|Challenge)/i);
    if (condImmuneMatch && condImmuneMatch[1]) this.conditionImmunities = condImmuneMatch[1].trim();

    // Extract senses
    const sensesMatch = text.match(/Senses\s+(.+?)(?:\n|Languages|Challenge)/i);
    if (sensesMatch && sensesMatch[1]) this.senses = sensesMatch[1].trim();

    // Extract languages
    const langMatch = text.match(/Languages\s+(.+?)(?:\n|Challenge|Proficiency)/i);
    if (langMatch && langMatch[1]) this.languages = langMatch[1].trim();

    // Extract CR
    const crMatch = text.match(/Challenge\s+([\d/]+)/i);
    if (crMatch && crMatch[1]) this.cr = crMatch[1];

    // Extract traits (features before Actions)
    this.traits = [];
    const actionsIndex = text.indexOf("Actions");
    const traitsSection = actionsIndex > 0 ? text.substring(0, actionsIndex) : text;
    
    // Look for trait patterns after CR line
    const crIndex = text.indexOf("Challenge");
    if (crIndex > 0) {
      const traitsText = traitsSection.substring(crIndex);
      const traitMatches = traitsText.matchAll(/^([A-Z][^\.]+?)\.\s+(.+?)(?=\n\n|\n[A-Z][^\.]+?\.|Actions|$)/gms);
      
      for (const match of traitMatches) {
        if (match[1] && match[2]) {
          const name = match[1].trim();
          const desc = match[2].trim();
          if (name && desc && !name.startsWith("Challenge") && !name.startsWith("Proficiency")) {
            this.traits.push({ name, desc });
          }
        }
      }
    }

    // Extract actions
    this.actions = [];
    if (actionsIndex > 0) {
      const actionsText = text.substring(actionsIndex);
      // Skip the 'Actions' header line
      const actionsContent = actionsText.replace(/^Actions\s*\n/i, '');
      
      // Match action patterns: Name. Description
      const actionMatches = actionsContent.matchAll(/^([A-Z][A-Za-z\s]+?)\.\s+(.+?)(?=\n\n|\n[A-Z][A-Za-z\s]+?\.|Bonus Actions|Reactions|Legendary Actions|$)/gms);
      
      for (const match of actionMatches) {
        if (match[1] && match[2]) {
          const name = match[1].trim();
          const desc = match[2].trim().replace(/\n/g, ' ');
          if (name && desc) {
            this.actions.push({ name, desc });
          }
        }
      }
    }

    console.log("Parsed creature:", this.creatureName);
  }

  refreshUI() {
    this.onOpen();
  }

  async loadCreatureData() {
    try {
      const creatureFile = this.app.vault.getAbstractFileByPath(this.originalCreaturePath);
      if (!(creatureFile instanceof TFile)) {
        new Notice("Creature file not found!");
        return;
      }

      const cache = this.app.metadataCache.getFileCache(creatureFile);
      const frontmatter = cache?.frontmatter;

      if (!frontmatter) {
        new Notice("Could not read creature data!");
        return;
      }

      // Load basic properties
      this.creatureName = frontmatter.name || creatureFile.basename;
      this.originalCreatureName = this.creatureName;
      this.size = frontmatter.size || 'Medium';
      this.type = frontmatter.type || "";
      this.subtype = frontmatter.subtype || "";
      this.alignment = frontmatter.alignment || "";
      this.ac = frontmatter.ac?.toString() || "";
      this.hp = frontmatter.hp?.toString() || "";
      this.hitDice = frontmatter.hit_dice || "";
      this.speed = frontmatter.speed || "";

      // Load ability scores
      if (frontmatter.stats && Array.isArray(frontmatter.stats)) {
        [this.str, this.dex, this.con, this.int, this.wis, this.cha] = frontmatter.stats;
      }

      // Load optional fields
      this.vulnerabilities = frontmatter.damage_vulnerabilities || "";
      this.resistances = frontmatter.damage_resistances || "";
      this.immunities = frontmatter.damage_immunities || "";
      this.conditionImmunities = frontmatter.condition_immunities || "";
      this.senses = frontmatter.senses || "";
      this.languages = frontmatter.languages || "";
      this.cr = frontmatter.cr?.toString() || "";
      
      // Load token ID if exists
      this.tokenId = frontmatter.token_id || "";

      // Load saves
      if (frontmatter.saves) {
        this.saves = Object.entries(frontmatter.saves).map(([key, val]) => `${key.toUpperCase()} ${val}`);
      }

      // Load skills
      if (frontmatter.skillsaves) {
        this.skills = Object.entries(frontmatter.skillsaves).map(([key, val]) => `${key} ${val}`);
      }

      // Load traits
      if (frontmatter.traits && Array.isArray(frontmatter.traits)) {
        this.traits = frontmatter.traits.map((t: any) => ({
          name: t.name || "",
          desc: t.desc || ""
        }));
      }

      // Load actions
      if (frontmatter.actions && Array.isArray(frontmatter.actions)) {
        this.actions = frontmatter.actions.map((a: any) => ({
          name: a.name || "",
          desc: a.desc || ""
        }));
      }

      // Load description from content
      const content = await this.app.vault.read(creatureFile);
      const descMatch = content.match(/---\n\n([\s\S]*?)(?:\n```statblock|$)/);
      if (descMatch && descMatch[1]) {
        this.description = descMatch[1].trim();
      }

      console.log(`[Creature Edit] Loaded creature data: ${this.creatureName}`);
    } catch (error) {
      console.error("Error loading creature data:", error);
      new Notice("Error loading creature data. Check console for details.");
    }
  }

  async saveCreature() {
    if (!this.creatureName.trim()) {
      new Notice("Please enter a creature name");
      return;
    }

    try {
      const beastiaryPath = "z_Beastiarity";
      
      // Ensure beastiary folder exists
      if (!(await this.app.vault.adapter.exists(beastiaryPath))) {
        new Notice(`Beastiary folder not found at ${beastiaryPath}`);
        return;
      }

      let creaturePath: string;
      let creatureFile: TFile | null = null;

      if (this.isEdit) {
        // Editing existing creature
        creatureFile = this.app.vault.getAbstractFileByPath(this.originalCreaturePath) as TFile;
        if (!creatureFile) {
          new Notice("Original creature file not found!");
          return;
        }
        creaturePath = this.originalCreaturePath;

        // If creature name changed, rename the file
        if (this.creatureName !== this.originalCreatureName) {
          const folder = creaturePath.substring(0, creaturePath.lastIndexOf('/'));
          const newPath = `${folder}/${this.creatureName}.md`;
          
          // Check if new name conflicts
          if (await this.app.vault.adapter.exists(newPath)) {
            new Notice(`A creature named "${this.creatureName}" already exists!`);
            return;
          }
          
          // Delete old statblock
          await this.plugin.deleteCreatureStatblock(this.originalCreatureName);
          
          await this.app.fileManager.renameFile(creatureFile, newPath);
          creaturePath = newPath;
          creatureFile = this.app.vault.getAbstractFileByPath(newPath) as TFile;
        } else {
          // Same name - delete old statblock and we'll recreate
          await this.plugin.deleteCreatureStatblock(this.originalCreatureName);
        }
      } else {
        // Creating new creature
        creaturePath = `${beastiaryPath}/${this.creatureName}.md`;

        // Check if creature already exists
        if (await this.app.vault.adapter.exists(creaturePath)) {
          new Notice(`A creature named "${this.creatureName}" already exists!`);
          return;
        }
      }

      // Create or update map token for this creature
      const now = Date.now();
      // Map creature size to CreatureSize type
      const creatureSizeMap: Record<string, CreatureSize> = {
        'Tiny': 'tiny',
        'Small': 'small',
        'Medium': 'medium',
        'Large': 'large',
        'Huge': 'huge',
        'Gargantuan': 'gargantuan'
      };
      const mappedSize = creatureSizeMap[this.size] || 'medium';
      
      if (!this.tokenId) {
        // Generate new token ID for new creatures
        this.tokenId = this.plugin.markerLibrary.generateId();
      }
      
      const tokenDef: MarkerDefinition = {
        id: this.tokenId,
        name: this.creatureName,
        type: 'creature',
        icon: 'üêâ',
        backgroundColor: '#8b0000',  // Dark red for creatures
        borderColor: '#ffffff',
        creatureSize: mappedSize,
        createdAt: now,
        updatedAt: now
      };
      await this.plugin.markerLibrary.setMarker(tokenDef);

      // Create creature content
      const creatureContent = this.createCreatureContent();

      // Create or update the file
      if (this.isEdit && creatureFile) {
        await this.app.vault.modify(creatureFile, creatureContent);
        new Notice(`Creature "${this.creatureName}" updated!`);
      } else {
        await this.app.vault.create(creaturePath, creatureContent);
        new Notice(`Creature "${this.creatureName}" created!`);
        creatureFile = this.app.vault.getAbstractFileByPath(creaturePath) as TFile;
      }

      // Save to Fantasy Statblocks plugin
      await this.saveToStatblocks();

      this.close();

      // Open the creature file
      if (creatureFile) {
        await this.app.workspace.openLinkText(creaturePath, "", false);
      }
    } catch (error) {
      console.error("Error creating/editing creature:", error);
      new Notice("Failed to save creature. Check console for details.");
    }
  }

  createCreatureContent(): string {
    // Calculate ability modifiers
    const calcMod = (score: number) => Math.floor((score - 10) / 2);
    const fageStats = [
      calcMod(this.str),
      calcMod(this.dex),
      calcMod(this.con),
      calcMod(this.int),
      calcMod(this.wis),
      calcMod(this.cha)
    ];

    // Build frontmatter
    let frontmatter = `---
statblock: true
layout: Basic 5e Layout
name: ${this.creatureName}
size: ${this.size}
type: ${this.type}`;

    if (this.subtype) {
      frontmatter += `\nsubtype: ${this.subtype}`;
    }

    frontmatter += `\nalignment: ${this.alignment}
ac: ${this.ac}
hp: ${this.hp}
hit_dice: ${this.hitDice}
speed: ${this.speed}
stats:
  - ${this.str}
  - ${this.dex}
  - ${this.con}
  - ${this.int}
  - ${this.wis}
  - ${this.cha}
fage_stats:
  - ${fageStats[0]}
  - ${fageStats[1]}
  - ${fageStats[2]}
  - ${fageStats[3]}
  - ${fageStats[4]}
  - ${fageStats[5]}`;

    // Add saves
    if (this.saves.length > 0) {
      frontmatter += `\nsaves:`;
      this.saves.forEach(save => {
        const parts = save.trim().split(/\s+/);
        if (parts.length >= 2 && parts[0]) {
          const ability = parts[0].toLowerCase().substring(0, 3);
          const bonus = parts.slice(1).join('').replace(/\+/g, '');
          frontmatter += `\n  - ${ability}: ${bonus}`;
        }
      });
    } else {
      frontmatter += `\nsaves:`;
    }

    // Add skills
    if (this.skills.length > 0) {
      frontmatter += `\nskillsaves:`;
      this.skills.forEach(skill => {
        const colonIndex = skill.indexOf(':');
        const plusIndex = skill.indexOf('+');
        const spaceIndex = skill.lastIndexOf(' ');
        
        let skillName = "";
        let bonus = "";
        
        if (colonIndex > 0) {
          skillName = skill.substring(0, colonIndex).trim();
          bonus = skill.substring(colonIndex + 1).trim().replace(/\+/g, '');
        } else if (plusIndex > 0) {
          skillName = skill.substring(0, plusIndex).trim();
          bonus = skill.substring(plusIndex).trim().replace(/\+/g, '');
        } else if (spaceIndex > 0) {
          skillName = skill.substring(0, spaceIndex).trim();
          bonus = skill.substring(spaceIndex).trim().replace(/\+/g, '');
        }
        
        if (skillName && bonus) {
          skillName = skillName.toLowerCase().replace(/\s+/g, '');
          frontmatter += `\n  - ${skillName}: ${bonus}`;
        }
      });
    } else {
      frontmatter += `\nskillsaves:`;
    }

    frontmatter += `\ndamage_vulnerabilities: ${this.vulnerabilities}`;
    frontmatter += `\ndamage_resistances: ${this.resistances}`;
    frontmatter += `\ndamage_immunities: ${this.immunities}`;
    frontmatter += `\ncondition_immunities: ${this.conditionImmunities}`;
    frontmatter += `\nsenses: ${this.senses}`;
    frontmatter += `\nlanguages: ${this.languages}`;
    frontmatter += `\ncr: ${this.cr}`;
    frontmatter += `\nspells:`;

    // Add traits
    if (this.traits.length > 0) {
      frontmatter += `\ntraits:`;
      this.traits.forEach(trait => {
        if (trait.name && trait.desc) {
          frontmatter += `\n  - name: ${trait.name}`;
          frontmatter += `\n    desc: "${trait.desc.replace(/"/g, '\\"')}"`;
        }
      });
    } else {
      frontmatter += `\ntraits:`;
    }

    // Add actions
    if (this.actions.length > 0) {
      frontmatter += `\nactions:`;
      this.actions.forEach(action => {
        if (action.name && action.desc) {
          frontmatter += `\n  - name: ${action.name}`;
          frontmatter += `\n    desc: "${action.desc.replace(/"/g, '\\"')}"`;
        }
      });
    } else {
      frontmatter += `\nactions:`;
    }

    frontmatter += `\nlegendary_actions:`;
    frontmatter += `\nbonus_actions:`;
    frontmatter += `\nreactions:`;
    frontmatter += `\ntoken_id: ${this.tokenId}`;
    frontmatter += `\n---\n\n`;

    // Add description
    let content = this.description || `${this.creatureName} creature description.\n`;
    
    // Add edit/delete buttons
    content += `\n\`\`\`dataviewjs
// Action buttons for creature management
const buttonContainer = dv.el("div", "", { 
  attr: { style: "display: flex; gap: 10px; margin: 10px 0;" } 
});

// Edit Creature button
const editBtn = buttonContainer.createEl("button", { 
  text: "‚úèÔ∏è Edit Creature",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
editBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:edit-creature");
});

// Delete Creature button  
const deleteBtn = buttonContainer.createEl("button", { 
  text: "üóëÔ∏è Delete Creature",
  attr: { style: "padding: 8px 16px; cursor: pointer; border-radius: 4px;" }
});
deleteBtn.addEventListener("click", () => {
  app.commands.executeCommandById("dnd-campaign-hub:delete-creature");
});
\`\`\`

`;
    
    // Add statblock
    content += `\`\`\`statblock\ncreature: ${this.creatureName}\n\`\`\`\n`;

    return frontmatter + content;
  }

  async saveToStatblocks() {
    try {
      const statblocksPlugin = (this.app as any).plugins.getPlugin("obsidian-5e-statblocks");
      if (!statblocksPlugin) {
        console.warn("Fantasy Statblocks plugin not found.");
        return;
      }

      // Create statblock object
      const statblock: any = {
        name: this.creatureName,
        size: this.size,
        type: this.type,
        subtype: this.subtype || undefined,
        alignment: this.alignment,
        ac: parseInt(this.ac) || 10,
        hp: parseInt(this.hp) || 1,
        hit_dice: this.hitDice,
        speed: this.speed,
        stats: [this.str, this.dex, this.con, this.int, this.wis, this.cha],
        saves: [],
        skillsaves: [],
        damage_vulnerabilities: this.vulnerabilities,
        damage_resistances: this.resistances,
        damage_immunities: this.immunities,
        condition_immunities: this.conditionImmunities,
        senses: this.senses,
        languages: this.languages,
        cr: this.cr,
        traits: this.traits.filter(t => t.name && t.desc),
        actions: this.actions.filter(a => a.name && a.desc),
        legendary_actions: [],
        bonus_actions: [],
        reactions: []
      };

      // Parse saves
      if (this.saves.length > 0) {
        this.saves.forEach(save => {
          const parts = save.split(' ');
          if (parts.length >= 2 && parts[0]) {
            const ability = parts[0].toLowerCase().substring(0, 3);
            const bonus = parts.slice(1).join(' ');
            statblock.saves.push({ [ability]: bonus });
          }
        });
      }

      // Parse skills
      if (this.skills.length > 0) {
        this.skills.forEach(skill => {
          const colonIndex = skill.indexOf(':');
          const plusIndex = skill.indexOf('+');
          const spaceIndex = skill.lastIndexOf(' ');
          
          let skillName = "";
          let bonus = "";
          
          if (colonIndex > 0) {
            skillName = skill.substring(0, colonIndex).trim();
            bonus = skill.substring(colonIndex + 1).trim();
          } else if (plusIndex > 0) {
            skillName = skill.substring(0, plusIndex).trim();
            bonus = skill.substring(plusIndex).trim();
          } else if (spaceIndex > 0) {
            skillName = skill.substring(0, spaceIndex).trim();
            bonus = skill.substring(spaceIndex).trim();
          }
          
          if (skillName && bonus) {
            skillName = skillName.toLowerCase().replace(/\s+/g, '');
            statblock.skillsaves.push({ [skillName]: bonus });
          }
        });
      }

      // Add to bestiary
      if (!statblocksPlugin.data.bestiary) {
        statblocksPlugin.data.bestiary = [];
      }

      // Remove existing entry if editing
      const existingIndex = statblocksPlugin.data.bestiary.findIndex((c: any) => c.name === this.creatureName);
      if (existingIndex !== -1) {
        statblocksPlugin.data.bestiary[existingIndex] = statblock;
      } else {
        statblocksPlugin.data.bestiary.push(statblock);
      }

      await statblocksPlugin.saveSettings();
      console.log(`Saved creature "${this.creatureName}" to Fantasy Statblocks`);
    } catch (error) {
      console.error("Error saving to Fantasy Statblocks:", error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

class FactionCreationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  factionName = "";
  campaign = "";
  mainGoal = "";
  pursuitMethod = "";
  leader = "";
  size = "";
  resources = "";
  reputation = "";
  territories = "";
  allies = "";
  enemies = "";
  activeProblem = "";

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
    this.campaign = plugin.settings.currentCampaign;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl("h2", { text: "üèõÔ∏è Create New Faction" });

    contentEl.createEl("p", {
      text: "Build a compelling faction with clear goals and methods of operation.",
      cls: "setting-item-description"
    });

    // Faction Name
    new Setting(contentEl)
      .setName("Faction Name")
      .setDesc("What is this faction called?")
      .addText((text) => {
        text
          .setPlaceholder("e.g., The Emerald Enclave, The Zhentarim")
          .onChange((value) => {
            this.factionName = value;
          });
        text.inputEl.focus();
      });

    // Campaign Selection
    const campaigns = this.getAllCampaigns();
    new Setting(contentEl)
      .setName("Campaign")
      .setDesc("Which campaign does this faction belong to?")
      .addDropdown((dropdown) => {
        campaigns.forEach(campaign => {
          dropdown.addOption(campaign.path, campaign.name);
        });
        dropdown.setValue(this.campaign)
          .onChange((value) => {
            this.campaign = value;
          });
      });

    contentEl.createEl("h3", { text: "üéØ Core Faction Engine" });

    // Main Goal
    new Setting(contentEl)
      .setName("What is their main goal?")
      .setDesc("The faction's primary objective or purpose")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Preserve the balance of nature and protect the wilderness from civilization's encroachment")
          .onChange((value) => {
            this.mainGoal = value;
          });
        text.inputEl.rows = 3;
      });

    // Pursuit Method
    new Setting(contentEl)
      .setName("How do they pursue it?")
      .setDesc("Their methods, tactics, and approach to achieving their goal")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Through covert operations, strategic alliances with druid circles, and carefully placed agents in key positions")
          .onChange((value) => {
            this.pursuitMethod = value;
          });
        text.inputEl.rows = 3;
      });

    contentEl.createEl("h3", { text: "üìã Faction Details" });

    // Leader
    new Setting(contentEl)
      .setName("Leader")
      .setDesc("Who leads this faction? (Optional)")
      .addText((text) => {
        text
          .setPlaceholder("e.g., High Druid Amaranthe Silvermoon")
          .onChange((value) => {
            this.leader = value;
          });
      });

    // Size/Influence
    new Setting(contentEl)
      .setName("Size & Influence")
      .setDesc("How large and influential is this faction?")
      .addText((text) => {
        text
          .setPlaceholder("e.g., Regional, hundreds of members")
          .onChange((value) => {
            this.size = value;
          });
      });

    // Resources
    new Setting(contentEl)
      .setName("Resources")
      .setDesc("What resources does this faction control?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Hidden forest sanctuaries, network of informants, ancient druidic artifacts")
          .onChange((value) => {
            this.resources = value;
          });
        text.inputEl.rows = 2;
      });

    // Reputation
    new Setting(contentEl)
      .setName("Reputation")
      .setDesc("How is this faction viewed by others?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Respected by rural communities, distrusted by merchant guilds, feared by loggers")
          .onChange((value) => {
            this.reputation = value;
          });
        text.inputEl.rows = 2;
      });

    contentEl.createEl("h3", { text: "üó∫Ô∏è Relationships" });

    // Territories
    new Setting(contentEl)
      .setName("Territories")
      .setDesc("What areas or locations does this faction control or operate in?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., The Misty Forest, Hidden groves throughout the Sword Coast")
          .onChange((value) => {
            this.territories = value;
          });
        text.inputEl.rows = 2;
      });

    // Allies
    new Setting(contentEl)
      .setName("Allies")
      .setDesc("Which factions or groups are allied with them?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Harpers, local druid circles, forest creatures")
          .onChange((value) => {
            this.allies = value;
          });
        text.inputEl.rows = 2;
      });

    // Enemies
    new Setting(contentEl)
      .setName("Enemies")
      .setDesc("Which factions or groups oppose them?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., Zhentarim, logging companies, industrialist merchants")
          .onChange((value) => {
            this.enemies = value;
          });
        text.inputEl.rows = 2;
      });

    contentEl.createEl("h3", { text: "‚ö†Ô∏è Current Situation" });

    // Active Problem
    new Setting(contentEl)
      .setName("Active Problem")
      .setDesc("What challenge or conflict is this faction currently facing?")
      .addTextArea((text) => {
        text
          .setPlaceholder("e.g., A corrupted member has been selling secrets to logging companies")
          .onChange((value) => {
            this.activeProblem = value;
          });
        text.inputEl.rows = 3;
      });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: "dnd-modal-buttons" });

    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });

    const createButton = buttonContainer.createEl("button", {
      text: "Create Faction",
      cls: "mod-cta",
    });

    createButton.addEventListener("click", async () => {
      if (!this.factionName.trim()) {
        new Notice("Please enter a faction name!");
        return;
      }

      this.close();
      await this.createFactionFile();
    });
  }

  getAllCampaigns(): Array<{ path: string; name: string }> {
    const ttrpgsFolder = this.app.vault.getAbstractFileByPath("ttrpgs");
    const campaigns: Array<{ path: string; name: string }> = [];

    if (ttrpgsFolder instanceof TFolder) {
      ttrpgsFolder.children.forEach((child) => {
        if (child instanceof TFolder) {
          campaigns.push({
            path: child.path,
            name: child.name
          });
        }
      });
    }

    return campaigns;
  }

  async createFactionFile() {
    const campaignName = this.campaign.split('/').pop() || "Unknown";
    const factionPath = `${this.campaign}/Factions`;
    
    new Notice(`Creating Faction "${this.factionName}"...`);

    try {
      await this.plugin.ensureFolderExists(factionPath);

      // Get world info from campaign World.md
      const worldFile = this.app.vault.getAbstractFileByPath(`${this.campaign}/World.md`);
      let worldName = campaignName;
      
      if (worldFile instanceof TFile) {
        const worldContent = await this.app.vault.read(worldFile);
        const worldMatch = worldContent.match(/^world:\s*([^\r\n]+)$/m);
        if (worldMatch && worldMatch[1] && worldMatch[1].trim()) {
          worldName = worldMatch[1].trim();
        }
      }

      // Get Faction template
      const templatePath = "z_Templates/Frontmatter - Faction.md";
      const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
      let factionContent: string;

      if (templateFile instanceof TFile) {
        factionContent = await this.app.vault.read(templateFile);
      } else {
        factionContent = FACTION_TEMPLATE;
      }

      // Get current date
      const currentDate = new Date().toISOString().split('T')[0];

      // Build complete frontmatter
      const frontmatter = `---
type: faction
name: ${this.factionName}
campaign: ${campaignName}
world: ${worldName}
main_goal: "${this.mainGoal}"
pursuit_method: "${this.pursuitMethod}"
leader: ${this.leader}
size: ${this.size}
resources: "${this.resources}"
reputation: "${this.reputation}"
territories: "${this.territories}"
allies: "${this.allies}"
enemies: "${this.enemies}"
active_problem: "${this.activeProblem}"
date: ${currentDate}
---`;

      // Replace the frontmatter
      factionContent = factionContent.replace(/^---\n[\s\S]*?\n---/, frontmatter);
      
      // Replace the title and template references
      factionContent = factionContent
        .replace(/# <% tp\.frontmatter\.name %>/g, `# ${this.factionName}`)
        .replace(/<% tp\.frontmatter\.name %>/g, this.factionName)
        .replace(/<% tp\.frontmatter\.main_goal %>/g, this.mainGoal)
        .replace(/<% tp\.frontmatter\.pursuit_method %>/g, this.pursuitMethod)
        .replace(/<% tp\.frontmatter\.leader %>/g, this.leader || "_No leader specified_")
        .replace(/<% tp\.frontmatter\.active_problem %>/g, this.activeProblem)
        .replace(/<% tp\.frontmatter\.resources %>/g, this.resources)
        .replace(/<% tp\.frontmatter\.reputation %>/g, this.reputation)
        .replace(/<% tp\.frontmatter\.territories %>/g, this.territories)
        .replace(/<% tp\.frontmatter\.allies %>/g, this.allies)
        .replace(/<% tp\.frontmatter\.enemies %>/g, this.enemies);

      const filePath = `${factionPath}/${this.factionName}.md`;
      await this.app.vault.create(filePath, factionContent);

      // Open the file
      await this.app.workspace.openLinkText(filePath, "", true);

      new Notice(`‚úÖ Faction "${this.factionName}" created successfully!`);
    } catch (error) {
      new Notice(`‚ùå Error creating Faction: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Faction creation error:", error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * Spell Import Modal - Search and import spells from D&D 5e SRD API or create custom
 */
class SpellImportModal extends Modal {
  plugin: DndCampaignHubPlugin;
  spellList: any[] = [];
  filteredSpells: any[] = [];
  selectedSpell: any = null;
  searchQuery = "";
  filterLevels: string[] = [];
  filterSchools: string[] = [];
  filterClasses: string[] = [];
  isLoading = false;
  private readonly CACHE_PATH = ".obsidian/plugins/dnd-campaign-hub/spell-cache.json";
  private readonly CACHE_EXPIRY_DAYS = 7;

  constructor(app: App, plugin: DndCampaignHubPlugin) {
    super(app);
    this.plugin = plugin;
  }

  async loadSpellCache(): Promise<any[] | null> {
    try {
      const exists = await this.app.vault.adapter.exists(this.CACHE_PATH);
      if (!exists) {
        return null;
      }

      const cacheContent = await this.app.vault.adapter.read(this.CACHE_PATH);
      const cache = JSON.parse(cacheContent);

      // Check cache age
      const ageMs = Date.now() - cache.timestamp;
      const maxAgeMs = this.CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
      
      if (ageMs > maxAgeMs) {
        console.log(`Spell cache expired (${Math.floor(ageMs / (24 * 60 * 60 * 1000))} days old)`);
        return null;
      }

      console.log(`Loaded ${cache.count} spells from cache (${Math.floor(ageMs / (60 * 60 * 1000))} hours old)`);
      return cache.spells || [];
    } catch (error) {
      console.error("Failed to load spell cache:", error);
      return null;
    }
  }

  async saveSpellCache(spells: any[]): Promise<void> {
    try {
      const cache = {
        version: "2014",
        timestamp: Date.now(),
        count: spells.length,
        spells: spells
      };

      const cacheContent = JSON.stringify(cache);
      await this.app.vault.adapter.write(this.CACHE_PATH, cacheContent);
      console.log(`Saved ${spells.length} spells to cache`);
    } catch (error) {
      console.error("Failed to save spell cache:", error);
    }
  }

  async refreshSpellsFromAPI(container: HTMLElement, listContainer: HTMLElement): Promise<void> {
    const loadingEl = container.createEl("div", { 
      text: "Refreshing spells from D&D 5e SRD API...",
      cls: "spell-loading"
    });

    try {
      const response = await requestUrl({
        url: "https://www.dnd5eapi.co/api/2014/spells",
        method: "GET"
      });

      const spellRefs = response.json.results || [];
      loadingEl.setText(`Loading spell details... (0/${spellRefs.length})`);

      this.spellList = [];
      for (let i = 0; i < spellRefs.length; i++) {
        try {
          const detailResponse = await requestUrl({
            url: `https://www.dnd5eapi.co${spellRefs[i].url}`,
            method: "GET"
          });
          this.spellList.push(detailResponse.json);
          
          if (i % 10 === 0 || i === spellRefs.length - 1) {
            loadingEl.setText(`Loading spell details... (${i + 1}/${spellRefs.length})`);
          }
        } catch (error) {
          console.error(`Failed to load spell: ${spellRefs[i].name}`, error);
        }
      }

      await this.saveSpellCache(this.spellList);
      this.filteredSpells = [...this.spellList];
      loadingEl.remove();
      this.renderSpellList(listContainer);
    } catch (error) {
      loadingEl.setText("‚ùå Failed to load spells from API. Please check your internet connection.");
      console.error("Spell API error:", error);
    }
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("spell-import-modal");

    contentEl.createEl("h2", { text: "üìñ Spell Library" });
    contentEl.createEl("p", { 
      text: "Import spells from the D&D 5e SRD or create your own custom spell.",
      cls: "setting-item-description"
    });

    // Create tabs
    const tabContainer = contentEl.createEl("div", { cls: "spell-tabs" });
    
    const srdTab = tabContainer.createEl("button", { 
      text: "üìö SRD Spells",
      cls: "spell-tab active"
    });
    
    const customTab = tabContainer.createEl("button", { 
      text: "‚ú® Custom Spell",
      cls: "spell-tab"
    });

    // Content containers
    const srdContent = contentEl.createEl("div", { cls: "spell-content active" });
    const customContent = contentEl.createEl("div", { cls: "spell-content hidden" });

    // Tab switching
    srdTab.addEventListener("click", () => {
      srdTab.addClass("active");
      customTab.removeClass("active");
      srdContent.removeClass("hidden");
      srdContent.addClass("active");
      customContent.removeClass("active");
      customContent.addClass("hidden");
    });

    customTab.addEventListener("click", () => {
      customTab.addClass("active");
      srdTab.removeClass("active");
      customContent.removeClass("hidden");
      customContent.addClass("active");
      srdContent.removeClass("active");
      srdContent.addClass("hidden");
    });

    // SRD Content
    await this.renderSRDContent(srdContent);

    // Custom Content  
    this.renderCustomContent(customContent);
  }

  async renderSRDContent(container: HTMLElement) {
    // Top bar with search and refresh button
    const topBar = container.createEl("div", { cls: "spell-top-bar" });
    
    // Search
    const searchInput = topBar.createEl("input", {
      type: "text",
      placeholder: "Search spells...",
      cls: "spell-search-input"
    });
    searchInput.addEventListener("input", () => {
      this.searchQuery = searchInput.value.toLowerCase();
      this.filterAndRenderSpells(listContainer);
    });

    // Refresh button
    const refreshBtn = topBar.createEl("button", { 
      text: "üîÑ Refresh from API",
      cls: "spell-refresh-btn"
    });

    // Bulk import button
    const bulkImportBtn = topBar.createEl("button", { 
      text: "üì• Import All",
      cls: "spell-bulk-import-btn"
    });

    // Filters container
    const filterContainer = container.createEl("div", { cls: "spell-filters" });

    // Level filter
    const levelFilterDiv = filterContainer.createEl("div", { cls: "spell-filter-group" });
    levelFilterDiv.createEl("div", { text: "Level:", cls: "spell-filter-label" });
    const levelDropdown = this.createMultiSelectDropdown(levelFilterDiv, [
      { value: "0", label: "Cantrip" },
      { value: "1", label: "Level 1" },
      { value: "2", label: "Level 2" },
      { value: "3", label: "Level 3" },
      { value: "4", label: "Level 4" },
      { value: "5", label: "Level 5" },
      { value: "6", label: "Level 6" },
      { value: "7", label: "Level 7" },
      { value: "8", label: "Level 8" },
      { value: "9", label: "Level 9" }
    ], (selected) => {
      this.filterLevels = selected;
      this.filterAndRenderSpells(listContainer);
    });

    // School filter
    const schoolFilterDiv = filterContainer.createEl("div", { cls: "spell-filter-group" });
    schoolFilterDiv.createEl("div", { text: "School:", cls: "spell-filter-label" });
    const schoolDropdown = this.createMultiSelectDropdown(schoolFilterDiv, [
      { value: "abjuration", label: "Abjuration" },
      { value: "conjuration", label: "Conjuration" },
      { value: "divination", label: "Divination" },
      { value: "enchantment", label: "Enchantment" },
      { value: "evocation", label: "Evocation" },
      { value: "illusion", label: "Illusion" },
      { value: "necromancy", label: "Necromancy" },
      { value: "transmutation", label: "Transmutation" }
    ], (selected) => {
      this.filterSchools = selected;
      this.filterAndRenderSpells(listContainer);
    });

    // Class filter
    const classFilterDiv = filterContainer.createEl("div", { cls: "spell-filter-group" });
    classFilterDiv.createEl("div", { text: "Class:", cls: "spell-filter-label" });
    const classCheckboxes = classFilterDiv.createEl("div", { cls: "spell-filter-checkboxes" });
    const classes = ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"];
    classes.forEach((className) => {
      const checkboxContainer = classCheckboxes.createEl("label", { cls: "spell-checkbox" });
      const checkbox = checkboxContainer.createEl("input", { type: "checkbox" });
      checkbox.value = className.toLowerCase();
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.filterClasses.push(className.toLowerCase());
        } else {
          this.filterClasses = this.filterClasses.filter(c => c !== className.toLowerCase());
        }
        this.filterAndRenderSpells(listContainer);
      });
      checkboxContainer.createEl("span", { text: className });
    });

    // Spell list container
    const listContainer = container.createEl("div", { cls: "spell-list-container" });

    // Loading indicator
    const loadingEl = container.createEl("div", { 
      text: "Loading spells...",
      cls: "spell-loading"
    });

    // Try to load from cache first
    const cachedSpells = await this.loadSpellCache();
    if (cachedSpells && cachedSpells.length > 0) {
      this.spellList = cachedSpells;
      this.filteredSpells = [...this.spellList];
      loadingEl.setText(`‚úì Loaded ${cachedSpells.length} spells from cache`);
      setTimeout(() => loadingEl.remove(), 1000);
      this.renderSpellList(listContainer);
    } else {
      // Fetch from API if no cache
      await this.refreshSpellsFromAPI(container, listContainer);
    }

    // Refresh button handler
    refreshBtn.addEventListener("click", async () => {
      listContainer.empty();
      this.searchQuery = "";
      this.filterLevels = [];
      this.filterSchools = [];
      this.filterClasses = [];
      searchInput.value = "";
      // Clear select options
      levelDropdown.clearSelections();
      schoolDropdown.clearSelections();
      // Uncheck all checkboxes
      filterContainer.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
        (cb as HTMLInputElement).checked = false;
      });
      await this.refreshSpellsFromAPI(container, listContainer);
    });

    // Bulk import button handler
    bulkImportBtn.addEventListener("click", async () => {
      await this.bulkImportAllSpells(bulkImportBtn);
    });
  }

  async bulkImportAllSpells(button?: HTMLElement) {
    try {
      // Prevent multiple simultaneous imports
      if (button) {
        if (button.hasClass("importing")) {
          new Notice("Import already in progress...");
          return;
        }
        button.addClass("importing");
        button.textContent = "‚è≥ Importing...";
        (button as HTMLButtonElement).disabled = true;
      }

      // Ensure spells are loaded
      if (this.spellList.length === 0) {
        new Notice("Loading spells from API first...");
        const response = await requestUrl({
          url: "https://www.dnd5eapi.co/api/2014/spells",
          method: "GET"
        });
        const spellRefs = response.json.results || [];
        
        for (let i = 0; i < spellRefs.length; i++) {
          try {
            const detailResponse = await requestUrl({
              url: `https://www.dnd5eapi.co${spellRefs[i].url}`,
              method: "GET"
            });
            this.spellList.push(detailResponse.json);
          } catch (error) {
            console.error(`Failed to load spell: ${spellRefs[i].name}`, error);
          }
        }
        await this.saveSpellCache(this.spellList);
      }

      // Create z_Spells folder
      const spellsPath = "z_Spells";
      await this.plugin.ensureFolderExists(spellsPath);

      let successCount = 0;
      let errorCount = 0;
      const totalSpells = this.spellList.length;

      new Notice(`Starting bulk import of ${totalSpells} spells...`);

      for (let i = 0; i < this.spellList.length; i++) {
        try {
          const spell = this.spellList[i];
          const filePath = `${spellsPath}/${spell.name}.md`;
          
          // Check if file already exists
          const exists = await this.app.vault.adapter.exists(filePath);
          if (exists) {
            console.log(`Skipping ${spell.name} - already exists`);
            successCount++;
            continue;
          }

          // Build spell content
          const levelText = spell.level === 0 ? "Cantrip" : spell.level.toString();
          const components = spell.components.join(", ");
          const material = spell.material ? `\nMaterials: ${spell.material}` : "";
          
          const description = spell.desc.join("\n\n");
          const higherLevel = spell.higher_level && spell.higher_level.length > 0 
            ? spell.higher_level.join("\n\n")
            : "N/A";

          const classes = spell.classes && spell.classes.length > 0
            ? spell.classes.map((c: any) => c.name).join(", ")
            : "N/A";

          const content = `---
type: spell
template_version: 1.0.0
name: ${spell.name}
level: ${spell.level}
school: ${spell.school.name}
casting_time: ${spell.casting_time}
range: ${spell.range}
components: ${components}
duration: ${spell.duration}
concentration: ${spell.concentration || false}
ritual: ${spell.ritual || false}
classes: ${classes}
source: SRD
---

# ${spell.name}

**${levelText} ${spell.school.name}**

**Casting Time:** ${spell.casting_time}  
**Range:** ${spell.range}  
**Components:** ${components}${material}  
**Duration:** ${spell.duration}${spell.concentration ? " (Concentration)" : ""}${spell.ritual ? " (Ritual)" : ""}

## Description

${description}

## At Higher Levels

${higherLevel}

## Classes

${classes}
`;

          await this.app.vault.create(filePath, content);
          successCount++;

          // Update progress notification every 50 spells
          if (i % 50 === 0 && i > 0) {
            new Notice(`Importing spells... ${i}/${totalSpells}`);
          }
        } catch (error) {
          errorCount++;
          console.error(`Failed to import ${this.spellList[i].name}:`, error);
        }
      }

      new Notice(`‚úÖ Bulk import complete! ${successCount} spells imported, ${errorCount} errors.`);
    } catch (error) {
      new Notice(`‚ùå Bulk import failed: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Bulk import error:", error);
    } finally {
      // Re-enable button
      if (button) {
        button.removeClass("importing");
        button.textContent = "üì• Import All";
        (button as HTMLButtonElement).disabled = false;
      }
    }
  }

  createMultiSelectDropdown(
    parent: HTMLElement, 
    options: Array<{value: string, label: string}>, 
    onChange: (selected: string[]) => void
  ) {
    const dropdownContainer = parent.createEl("div", { cls: "custom-multiselect" });
    const dropdownButton = dropdownContainer.createEl("button", { 
      cls: "custom-multiselect-button",
      text: "Select..."
    });
    const dropdownList = dropdownContainer.createEl("div", { cls: "custom-multiselect-list" });
    dropdownList.style.display = "none";

    const selectedValues = new Set<string>();
    const checkboxes: Array<{checkbox: HTMLInputElement, value: string}> = [];

    options.forEach(option => {
      const item = dropdownList.createEl("label", { cls: "custom-multiselect-item" });
      const checkbox = item.createEl("input", { type: "checkbox" });
      checkbox.value = option.value;
      item.createEl("span", { text: option.label });

      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          selectedValues.add(option.value);
        } else {
          selectedValues.delete(option.value);
        }
        updateButtonText();
        onChange(Array.from(selectedValues));
      });

      checkboxes.push({ checkbox, value: option.value });
    });

    const updateButtonText = () => {
      if (selectedValues.size === 0) {
        dropdownButton.textContent = "Select...";
      } else {
        dropdownButton.textContent = `${selectedValues.size} selected`;
      }
    };

    dropdownButton.addEventListener("click", (e) => {
      e.preventDefault();
      const isVisible = dropdownList.style.display !== "none";
      dropdownList.style.display = isVisible ? "none" : "block";
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      if (!dropdownContainer.contains(e.target as Node)) {
        dropdownList.style.display = "none";
      }
    });

    return {
      clearSelections: () => {
        selectedValues.clear();
        checkboxes.forEach(item => item.checkbox.checked = false);
        updateButtonText();
      }
    };
  }

  filterAndRenderSpells(container: HTMLElement) {
    this.filteredSpells = this.spellList.filter(spell => {
      // Search filter
      const matchesSearch = spell.name.toLowerCase().includes(this.searchQuery);
      
      // Level filter (if any levels selected, spell must match one of them)
      const matchesLevel = this.filterLevels.length === 0 || 
        this.filterLevels.includes(spell.level.toString());
      
      // School filter (if any schools selected, spell must match one of them)
      const matchesSchool = this.filterSchools.length === 0 || 
        this.filterSchools.includes(spell.school?.name?.toLowerCase());
      
      // Class filter (if any classes selected, spell must be available to one of them)
      const matchesClass = this.filterClasses.length === 0 || 
        spell.classes?.some((c: any) => this.filterClasses.includes(c.name.toLowerCase()));
      
      return matchesSearch && matchesLevel && matchesSchool && matchesClass;
    });

    this.renderSpellList(container);
  }

  renderSpellList(container: HTMLElement) {
    container.empty();

    if (this.filteredSpells.length === 0) {
      container.createEl("div", { 
        text: "No spells found matching your search.",
        cls: "empty-message"
      });
      return;
    }

    const list = container.createEl("div", { cls: "spell-list" });
    
    this.filteredSpells.forEach(spell => {
      const item = list.createEl("div", { cls: "spell-list-item" });
      const levelText = spell.level === 0 ? "Cantrip" : `Lvl ${spell.level}`;
      const schoolText = spell.school?.name || "Unknown";
      const classNames = spell.classes?.map((c: any) => c.name).join(", ") || "";
      
      item.createEl("span", { 
        text: spell.name,
        cls: "spell-item-name"
      });
      item.createEl("span", { 
        text: ` (${levelText} ${schoolText})`,
        cls: "spell-item-meta"
      });
      if (classNames) {
        item.createEl("div", { 
          text: classNames,
          cls: "spell-item-classes"
        });
      }
      
      item.addEventListener("click", async () => {
        await this.showSpellDetails(spell);
      });
    });

    container.createEl("div", { 
      text: `${this.filteredSpells.length} spells found`,
      cls: "spell-count"
    });
  }

  async showSpellDetails(spell: any) {
    try {
      // Spell data is already loaded from initial fetch
      this.selectedSpell = spell;

      // Show modal with spell details
      new SpellDetailsModal(this.app, this.plugin, spell).open();
      this.close();
    } catch (error) {
      new Notice("‚ùå Failed to load spell details");
      console.error("Spell details error:", error);
    }
  }

  renderCustomContent(container: HTMLElement) {
    container.createEl("p", {
      text: "Create your own custom spell with D&D 5e format.",
      cls: "setting-item-description"
    });

    let spellName = "";

    new Setting(container)
      .setName("Spell Name")
      .setDesc("Name of your custom spell")
      .addText((text) => {
        text.setPlaceholder("e.g., Arcane Blast")
          .onChange((value) => {
            spellName = value;
          });
        text.inputEl.focus();
      });

    const buttonContainer = container.createEl("div", { cls: "dnd-modal-buttons" });
    
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());

    const createBtn = buttonContainer.createEl("button", { 
      text: "Create Custom Spell",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", async () => {
      if (!spellName.trim()) {
        new Notice("Please enter a spell name");
        return;
      }

      await this.createCustomSpell(spellName);
      this.close();
    });
  }

  async createCustomSpell(spellName: string) {
    try {
      const spellPath = `${this.plugin.settings.currentCampaign}/Spells`;
      await this.plugin.ensureFolderExists(spellPath);

      const template = this.plugin.getDefaultSpellTemplate();
      const filePath = `${spellPath}/${spellName}.md`;

      // Update template with spell name
      const content = template.replace("# Spell", `# ${spellName}`);

      await this.app.vault.create(filePath, content);
      await this.app.workspace.openLinkText(filePath, "", true);
      new Notice(`‚úÖ Custom spell "${spellName}" created!`);
    } catch (error) {
      new Notice(`‚ùå Error creating spell: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * Spell Details Modal - Shows full spell info and import button
 */
class SpellDetailsModal extends Modal {
  plugin: DndCampaignHubPlugin;
  spellData: any;

  constructor(app: App, plugin: DndCampaignHubPlugin, spellData: any) {
    super(app);
    this.plugin = plugin;
    this.spellData = spellData;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("spell-details-modal");

    const spell = this.spellData;

    // Header
    contentEl.createEl("h2", { text: spell.name });
    
    const meta = contentEl.createEl("div", { cls: "spell-meta" });
    const levelText = spell.level === 0 ? "Cantrip" : `Level ${spell.level}`;
    meta.createEl("span", { text: `${levelText} ${spell.school.name}`, cls: "spell-level-school" });

    // Details grid
    const details = contentEl.createEl("div", { cls: "spell-details-grid" });

    this.addDetail(details, "‚è±Ô∏è Casting Time", spell.casting_time);
    this.addDetail(details, "üìè Range", spell.range);
    this.addDetail(details, "üé≠ Components", spell.components.join(", ") + (spell.material ? ` (${spell.material})` : ""));
    this.addDetail(details, "‚è≥ Duration", spell.duration);
    
    if (spell.concentration) {
      details.createEl("div", { text: "‚ö†Ô∏è Requires Concentration", cls: "spell-concentration" });
    }
    if (spell.ritual) {
      details.createEl("div", { text: "üïØÔ∏è Ritual", cls: "spell-ritual" });
    }

    // Description
    const descSection = contentEl.createEl("div", { cls: "spell-description" });
    descSection.createEl("h3", { text: "Description" });
    spell.desc.forEach((para: string) => {
      descSection.createEl("p", { text: para });
    });

    // Higher levels
    if (spell.higher_level && spell.higher_level.length > 0) {
      const higherSection = contentEl.createEl("div", { cls: "spell-higher-level" });
      higherSection.createEl("h3", { text: "At Higher Levels" });
      spell.higher_level.forEach((para: string) => {
        higherSection.createEl("p", { text: para });
      });
    }

    // Classes
    if (spell.classes && spell.classes.length > 0) {
      const classesSection = contentEl.createEl("div", { cls: "spell-classes" });
      classesSection.createEl("strong", { text: "Classes: " });
      classesSection.createEl("span", { 
        text: spell.classes.map((c: any) => c.name).join(", ")
      });
    }

    // Buttons
    const buttonContainer = contentEl.createEl("div", { cls: "dnd-modal-buttons" });
    
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());

    const importBtn = buttonContainer.createEl("button", { 
      text: "üì• Import Spell",
      cls: "mod-cta"
    });
    importBtn.addEventListener("click", async () => {
      await this.importSpell();
      this.close();
    });
  }

  addDetail(container: HTMLElement, label: string, value: string) {
    const detail = container.createEl("div", { cls: "spell-detail" });
    detail.createEl("strong", { text: label + ": " });
    detail.createEl("span", { text: value });
  }

  async importSpell() {
    try {
      const spell = this.spellData;
      const spellPath = `${this.plugin.settings.currentCampaign}/Spells`;
      await this.plugin.ensureFolderExists(spellPath);

      // Build spell content from API data
      const levelText = spell.level === 0 ? "Cantrip" : spell.level.toString();
      const components = spell.components.join(", ");
      const material = spell.material ? `\nMaterials: ${spell.material}` : "";
      
      const description = spell.desc.join("\n\n");
      const higherLevel = spell.higher_level && spell.higher_level.length > 0 
        ? spell.higher_level.join("\n\n")
        : "N/A";

      const classes = spell.classes && spell.classes.length > 0
        ? spell.classes.map((c: any) => c.name).join(", ")
        : "N/A";

      const content = `---
type: spell
template_version: 1.0.0
name: ${spell.name}
level: ${spell.level}
school: ${spell.school.name}
casting_time: ${spell.casting_time}
range: ${spell.range}
components: ${components}
duration: ${spell.duration}
concentration: ${spell.concentration || false}
ritual: ${spell.ritual || false}
classes: ${classes}
source: SRD
---

# ${spell.name}

**${levelText} ${spell.school.name}**

**Casting Time:** ${spell.casting_time}  
**Range:** ${spell.range}  
**Components:** ${components}${material}  
**Duration:** ${spell.duration}${spell.concentration ? " (Concentration)" : ""}${spell.ritual ? " (Ritual)" : ""}

## Description

${description}

## At Higher Levels

${higherLevel}

## Classes

${classes}
`;

      const filePath = `${spellPath}/${spell.name}.md`;
      await this.app.vault.create(filePath, content);
      await this.app.workspace.openLinkText(filePath, "", true);
      new Notice(`‚úÖ Spell "${spell.name}" imported successfully!`);
    } catch (error) {
      new Notice(`‚ùå Error importing spell: ${error instanceof Error ? error.message : String(error)}`);
      console.error("Import error:", error);
    }
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}

/**
 * DM Screen - Virtual Dungeon Master reference screen with quick access to rules and SRD data
 */
class DMScreenView extends ItemView {
  plugin: DndCampaignHubPlugin;
  activeTab: string = "conditions";

  constructor(leaf: WorkspaceLeaf, plugin: DndCampaignHubPlugin) {
    super(leaf);
    this.plugin = plugin;
  }

  getViewType(): string {
    return DM_SCREEN_VIEW_TYPE;
  }

  getDisplayText(): string {
    return "DM Screen";
  }

  getIcon(): string {
    return "shield";
  }

  async onOpen() {
    await this.render();
  }

  async render() {
    const container = this.containerEl.children[1];
    if (!container) return;
    
    container.empty();
    container.addClass("dm-screen-view");

    // Header
    const header = container.createEl("div", { cls: "dm-screen-header" });
    header.createEl("h3", { text: "üìú DM Screen" });

    // Tab navigation
    const tabNav = container.createEl("div", { cls: "dm-screen-tabs" });
    const tabs = [
      { id: "conditions", label: "Conditions", icon: "‚ö†Ô∏è" },
      { id: "actions", label: "Actions", icon: "‚öîÔ∏è" },
      { id: "combat", label: "Combat", icon: "üéØ" },
      { id: "skills", label: "Skills", icon: "üé≤" },
      { id: "travel", label: "Travel & Rest", icon: "üèïÔ∏è" },
      { id: "dcs", label: "DCs", icon: "üìä" },
      { id: "damage", label: "Damage", icon: "üí•" },
      { id: "cover", label: "Cover", icon: "üõ°Ô∏è" }
    ];

    for (const tab of tabs) {
      const tabBtn = tabNav.createEl("button", {
        text: `${tab.icon} ${tab.label}`,
        cls: `dm-screen-tab ${this.activeTab === tab.id ? "active" : ""}`
      });
      tabBtn.addEventListener("click", () => {
        this.activeTab = tab.id;
        this.render();
      });
    }

    // Content area
    const content = container.createEl("div", { cls: "dm-screen-content" });

    switch (this.activeTab) {
      case "conditions":
        await this.renderConditionsTab(content);
        break;
      case "actions":
        this.renderActionsTab(content);
        break;
      case "combat":
        this.renderCombatTab(content);
        break;
      case "skills":
        this.renderSkillsTab(content);
        break;
      case "travel":
        this.renderTravelTab(content);
        break;
      case "dcs":
        this.renderDCsTab(content);
        break;
      case "damage":
        await this.renderDamageTab(content);
        break;
      case "cover":
        this.renderCoverTab(content);
        break;
    }
  }

  async renderConditionsTab(container: HTMLElement) {
    container.createEl("h4", { text: "Conditions" });

    // Try to load from SRD data first
    const conditionsFolder = this.app.vault.getAbstractFileByPath("z_Conditions");
    
    if (conditionsFolder instanceof TFolder && conditionsFolder.children.length > 0) {
      const conditionsGrid = container.createEl("div", { cls: "dm-screen-conditions-grid" });
      
      for (const file of conditionsFolder.children) {
        if (file instanceof TFile && file.extension === "md") {
          const conditionCard = conditionsGrid.createEl("div", { cls: "dm-condition-card" });
          const conditionName = conditionCard.createEl("strong", { text: file.basename });
          conditionName.addClass("dm-condition-link");
          conditionName.addEventListener("click", async () => {
            await this.app.workspace.openLinkText(file.path, "", true);
          });
          
          // Read file to get description
          try {
            const content = await this.app.vault.read(file);
            const lines = content.split("\n");
            let description = "";
            let inFrontmatter = false;
            
            for (const line of lines) {
              if (line.trim() === "---") {
                inFrontmatter = !inFrontmatter;
                continue;
              }
              if (!inFrontmatter && line.trim() && !line.startsWith("#")) {
                description = line.trim();
                break;
              }
            }
            
            if (description) {
              conditionCard.createEl("p", { text: description.substring(0, 150) + (description.length > 150 ? "..." : "") });
            }
          } catch (error) {
            // Ignore read errors
          }
        }
      }
    } else {
      // Fallback to hardcoded conditions
      const conditions = [
        { name: "Blinded", desc: "Can't see. Auto-fail sight checks. Attack rolls have disadvantage; attacks against have advantage." },
        { name: "Charmed", desc: "Can't attack charmer. Charmer has advantage on social checks." },
        { name: "Deafened", desc: "Can't hear. Auto-fail hearing checks." },
        { name: "Frightened", desc: "Disadvantage on checks/attacks while source is visible. Can't willingly move closer." },
        { name: "Grappled", desc: "Speed becomes 0. Ends if grappler is incapacitated or forcefully separated." },
        { name: "Incapacitated", desc: "Can't take actions or reactions." },
        { name: "Invisible", desc: "Impossible to see without magic. Attacks have advantage; attacks against have disadvantage." },
        { name: "Paralyzed", desc: "Incapacitated, can't move or speak. Auto-fail STR/DEX saves. Attacks have advantage; melee crits." },
        { name: "Petrified", desc: "Transformed to stone. Weight x10. Incapacitated, unaware. Resistance to all damage." },
        { name: "Poisoned", desc: "Disadvantage on attack rolls and ability checks." },
        { name: "Prone", desc: "Can only crawl (half speed). Disadvantage on attacks. Melee attacks have advantage; ranged disadvantage." },
        { name: "Restrained", desc: "Speed 0. Attacks have disadvantage; attacks against have advantage. Disadvantage on DEX saves." },
        { name: "Stunned", desc: "Incapacitated, can't move, can speak only falteringly. Auto-fail STR/DEX saves. Attacks have advantage." },
        { name: "Unconscious", desc: "Incapacitated, can't move or speak, unaware. Drop what held, fall prone. Auto-fail STR/DEX. Attacks have advantage; melee crits." },
        { name: "Exhaustion", desc: "1: Disadv on checks. 2: Speed halved. 3: Disadv attacks/saves. 4: HP max halved. 5: Speed 0. 6: Death." }
      ];

      const conditionsGrid = container.createEl("div", { cls: "dm-screen-conditions-grid" });
      
      for (const condition of conditions) {
        const card = conditionsGrid.createEl("div", { cls: "dm-condition-card" });
        card.createEl("strong", { text: condition.name });
        card.createEl("p", { text: condition.desc });
      }
    }
  }

  renderActionsTab(container: HTMLElement) {
    container.createEl("h4", { text: "Actions in Combat" });

    const actionsData = [
      {
        category: "Actions",
        items: [
          { name: "Attack", desc: "Make one melee or ranged attack. Some features allow multiple attacks." },
          { name: "Cast a Spell", desc: "Cast a spell with a casting time of 1 action." },
          { name: "Dash", desc: "Gain extra movement equal to your speed for the turn." },
          { name: "Disengage", desc: "Your movement doesn't provoke opportunity attacks for the turn." },
          { name: "Dodge", desc: "Attacks against you have disadvantage; DEX saves have advantage (if you can see)." },
          { name: "Help", desc: "Give an ally advantage on their next ability check or attack roll." },
          { name: "Hide", desc: "Make a Dexterity (Stealth) check to hide." },
          { name: "Ready", desc: "Prepare an action to trigger on a specific condition (uses reaction)." },
          { name: "Search", desc: "Make a Wisdom (Perception) or Intelligence (Investigation) check." },
          { name: "Use an Object", desc: "Interact with an object that requires an action." },
          { name: "Grapple", desc: "STR (Athletics) vs STR (Athletics) or DEX (Acrobatics). Target at most one size larger." },
          { name: "Shove", desc: "STR (Athletics) vs STR (Athletics) or DEX (Acrobatics). Push 5ft or knock prone." }
        ]
      },
      {
        category: "Bonus Actions",
        items: [
          { name: "Two-Weapon Fighting", desc: "Attack with light melee weapon in off hand (no ability mod to damage)." },
          { name: "Class Features", desc: "Cunning Action (Rogue), Rage (Barbarian), etc." },
          { name: "Spells", desc: "Cast spells with bonus action casting time." }
        ]
      },
      {
        category: "Reactions",
        items: [
          { name: "Opportunity Attack", desc: "Melee attack when hostile creature leaves your reach." },
          { name: "Readied Action", desc: "Use your prepared action when trigger occurs." },
          { name: "Spells", desc: "Shield, Counterspell, etc." }
        ]
      },
      {
        category: "Movement",
        items: [
          { name: "Move", desc: "Move up to your speed. Can split before/after actions." },
          { name: "Stand Up", desc: "Costs half your movement to stand from prone." },
          { name: "Climb/Swim", desc: "Each foot costs 2 feet of movement (unless you have a climb/swim speed)." },
          { name: "Difficult Terrain", desc: "Each foot costs 2 feet of movement." },
          { name: "Jump", desc: "Long: STR score in feet (running). High: 3 + STR mod feet (running)." }
        ]
      },
      {
        category: "Free Actions",
        items: [
          { name: "Object Interaction", desc: "One free object interaction per turn (draw weapon, open door)." },
          { name: "Communicate", desc: "Brief utterances and gestures during your turn." },
          { name: "Drop Item", desc: "Drop something you're holding." },
          { name: "Drop Prone", desc: "Fall prone (standing costs movement)." }
        ]
      }
    ];

    for (const section of actionsData) {
      const sectionEl = container.createEl("div", { cls: "dm-screen-section" });
      sectionEl.createEl("h5", { text: section.category });
      
      const tableEl = sectionEl.createEl("table", { cls: "dm-screen-table" });
      const tbody = tableEl.createEl("tbody");
      
      for (const item of section.items) {
        const row = tbody.createEl("tr");
        row.createEl("td", { text: item.name, cls: "dm-table-name" });
        row.createEl("td", { text: item.desc });
      }
    }
  }

  renderCombatTab(container: HTMLElement) {
    container.createEl("h4", { text: "Combat Rules Quick Reference" });

    // Attack Roll
    const attackSection = container.createEl("div", { cls: "dm-screen-section" });
    attackSection.createEl("h5", { text: "Attack Roll" });
    attackSection.createEl("p", { text: "d20 + ability modifier + proficiency bonus (if proficient)" });
    attackSection.createEl("p", { text: "‚Ä¢ Melee: Strength modifier (or Dex with Finesse weapons)" });
    attackSection.createEl("p", { text: "‚Ä¢ Ranged: Dexterity modifier" });
    attackSection.createEl("p", { text: "‚Ä¢ Spell: Spellcasting ability modifier" });

    // Critical Hits
    const critSection = container.createEl("div", { cls: "dm-screen-section" });
    critSection.createEl("h5", { text: "Critical Hits" });
    critSection.createEl("p", { text: "Natural 20: Roll damage dice twice, then add modifiers." });
    critSection.createEl("p", { text: "Natural 1: Automatic miss regardless of modifiers." });

    // Advantage/Disadvantage
    const advSection = container.createEl("div", { cls: "dm-screen-section" });
    advSection.createEl("h5", { text: "Advantage & Disadvantage" });
    advSection.createEl("p", { text: "Advantage: Roll 2d20, use higher result" });
    advSection.createEl("p", { text: "Disadvantage: Roll 2d20, use lower result" });
    advSection.createEl("p", { text: "Multiple sources don't stack. If both apply, they cancel out." });

    // Death Saves
    const deathSection = container.createEl("div", { cls: "dm-screen-section" });
    deathSection.createEl("h5", { text: "Death Saving Throws" });
    deathSection.createEl("p", { text: "At 0 HP, roll d20 at start of each turn:" });
    deathSection.createEl("p", { text: "‚Ä¢ 10+: Success | <10: Failure" });
    deathSection.createEl("p", { text: "‚Ä¢ Natural 1: 2 failures | Natural 20: Regain 1 HP" });
    deathSection.createEl("p", { text: "‚Ä¢ 3 successes: Stabilize | 3 failures: Death" });

    // Concentration
    const concentrationSection = container.createEl("div", { cls: "dm-screen-section" });
    concentrationSection.createEl("h5", { text: "Concentration" });
    concentrationSection.createEl("p", { text: "When damaged: CON save DC = 10 or half damage (whichever is higher)" });
    concentrationSection.createEl("p", { text: "Broken by: Incapacitation, death, or casting another concentration spell" });

    // Initiative
    const initSection = container.createEl("div", { cls: "dm-screen-section" });
    initSection.createEl("h5", { text: "Initiative" });
    initSection.createEl("p", { text: "d20 + Dexterity modifier" });
    initSection.createEl("p", { text: "Ties: DM decides (often higher Dex goes first, or simultaneous)" });

    // Surprise
    const surpriseSection = container.createEl("div", { cls: "dm-screen-section" });
    surpriseSection.createEl("h5", { text: "Surprise" });
    surpriseSection.createEl("p", { text: "Surprised creatures can't move or take actions on their first turn." });
    surpriseSection.createEl("p", { text: "Can't take reactions until that turn ends." });
  }

  renderSkillsTab(container: HTMLElement) {
    container.createEl("h4", { text: "Skills by Ability" });

    const skills = {
      "Strength (STR)": ["Athletics"],
      "Dexterity (DEX)": ["Acrobatics", "Sleight of Hand", "Stealth"],
      "Constitution (CON)": ["(No skills, but concentration and HP)"],
      "Intelligence (INT)": ["Arcana", "History", "Investigation", "Nature", "Religion"],
      "Wisdom (WIS)": ["Animal Handling", "Insight", "Medicine", "Perception", "Survival"],
      "Charisma (CHA)": ["Deception", "Intimidation", "Performance", "Persuasion"]
    };

    for (const [ability, skillList] of Object.entries(skills)) {
      const section = container.createEl("div", { cls: "dm-screen-section" });
      section.createEl("h5", { text: ability });
      const list = section.createEl("ul");
      for (const skill of skillList) {
        list.createEl("li", { text: skill });
      }
    }

    // Passive Scores
    const passiveSection = container.createEl("div", { cls: "dm-screen-section" });
    passiveSection.createEl("h5", { text: "Passive Scores" });
    passiveSection.createEl("p", { text: "Passive Score = 10 + all modifiers that apply" });
    passiveSection.createEl("p", { text: "Advantage: +5 | Disadvantage: -5" });
    passiveSection.createEl("p", { text: "Common: Passive Perception, Passive Investigation, Passive Insight" });
  }

  renderTravelTab(container: HTMLElement) {
    container.createEl("h4", { text: "Travel & Rest" });

    // Travel Pace
    const travelSection = container.createEl("div", { cls: "dm-screen-section" });
    travelSection.createEl("h5", { text: "Travel Pace" });
    const travelTable = travelSection.createEl("table", { cls: "dm-screen-table" });
    const travelBody = travelTable.createEl("tbody");
    
    const paces = [
      { pace: "Fast", perMin: "400 ft", perHour: "4 miles", perDay: "30 miles", effect: "-5 passive Perception" },
      { pace: "Normal", perMin: "300 ft", perHour: "3 miles", perDay: "24 miles", effect: "‚Äî" },
      { pace: "Slow", perMin: "200 ft", perHour: "2 miles", perDay: "18 miles", effect: "Can use Stealth" }
    ];

    const header = travelBody.createEl("tr");
    header.createEl("th", { text: "Pace" });
    header.createEl("th", { text: "/Minute" });
    header.createEl("th", { text: "/Hour" });
    header.createEl("th", { text: "/Day" });
    header.createEl("th", { text: "Effect" });

    for (const pace of paces) {
      const row = travelBody.createEl("tr");
      row.createEl("td", { text: pace.pace });
      row.createEl("td", { text: pace.perMin });
      row.createEl("td", { text: pace.perHour });
      row.createEl("td", { text: pace.perDay });
      row.createEl("td", { text: pace.effect });
    }

    // Short Rest
    const shortRestSection = container.createEl("div", { cls: "dm-screen-section" });
    shortRestSection.createEl("h5", { text: "Short Rest (1+ hour)" });
    shortRestSection.createEl("p", { text: "‚Ä¢ Spend Hit Dice to recover HP (roll + CON mod each)" });
    shortRestSection.createEl("p", { text: "‚Ä¢ Some class features recharge" });
    shortRestSection.createEl("p", { text: "‚Ä¢ Light activity: eating, reading, keeping watch" });

    // Long Rest
    const longRestSection = container.createEl("div", { cls: "dm-screen-section" });
    longRestSection.createEl("h5", { text: "Long Rest (8+ hours, 6 hours sleep)" });
    longRestSection.createEl("p", { text: "‚Ä¢ Regain all HP" });
    longRestSection.createEl("p", { text: "‚Ä¢ Regain half your total Hit Dice (minimum 1)" });
    longRestSection.createEl("p", { text: "‚Ä¢ Regain all spell slots" });
    longRestSection.createEl("p", { text: "‚Ä¢ Remove 1 level of Exhaustion" });
    longRestSection.createEl("p", { text: "‚Ä¢ Can only benefit from one long rest per 24 hours" });

    // Carrying Capacity
    const carrySection = container.createEl("div", { cls: "dm-screen-section" });
    carrySection.createEl("h5", { text: "Carrying Capacity" });
    carrySection.createEl("p", { text: "Carry: STR √ó 15 lbs" });
    carrySection.createEl("p", { text: "Push/Drag/Lift: STR √ó 30 lbs (speed = 5 ft)" });
    carrySection.createEl("p", { text: "Encumbered (variant): > STR √ó 5 lbs = -10 speed" });
    carrySection.createEl("p", { text: "Heavily Encumbered (variant): > STR √ó 10 lbs = -20 speed, disadvantage on attacks/checks/saves" });
  }

  renderDCsTab(container: HTMLElement) {
    container.createEl("h4", { text: "Difficulty Classes" });

    // Standard DCs
    const dcSection = container.createEl("div", { cls: "dm-screen-section" });
    dcSection.createEl("h5", { text: "Typical Difficulty Classes" });
    const dcTable = dcSection.createEl("table", { cls: "dm-screen-table" });
    const dcBody = dcTable.createEl("tbody");
    
    const dcs = [
      { difficulty: "Very Easy", dc: "5" },
      { difficulty: "Easy", dc: "10" },
      { difficulty: "Medium", dc: "15" },
      { difficulty: "Hard", dc: "20" },
      { difficulty: "Very Hard", dc: "25" },
      { difficulty: "Nearly Impossible", dc: "30" }
    ];

    for (const dc of dcs) {
      const row = dcBody.createEl("tr");
      row.createEl("td", { text: dc.difficulty });
      row.createEl("td", { text: `DC ${dc.dc}`, cls: "dm-table-highlight" });
    }

    // Spell Save DC
    const spellDcSection = container.createEl("div", { cls: "dm-screen-section" });
    spellDcSection.createEl("h5", { text: "Spell Save DC" });
    spellDcSection.createEl("p", { text: "8 + proficiency bonus + spellcasting ability modifier" });

    // Spell Attack
    const spellAttackSection = container.createEl("div", { cls: "dm-screen-section" });
    spellAttackSection.createEl("h5", { text: "Spell Attack Modifier" });
    spellAttackSection.createEl("p", { text: "Proficiency bonus + spellcasting ability modifier" });

    // AC Calculation
    const acSection = container.createEl("div", { cls: "dm-screen-section" });
    acSection.createEl("h5", { text: "Armor Class" });
    acSection.createEl("p", { text: "No Armor: 10 + DEX mod" });
    acSection.createEl("p", { text: "Light Armor: Armor AC + DEX mod" });
    acSection.createEl("p", { text: "Medium Armor: Armor AC + DEX mod (max +2)" });
    acSection.createEl("p", { text: "Heavy Armor: Armor AC (no DEX)" });
    acSection.createEl("p", { text: "Shield: +2 AC" });
  }

  async renderDamageTab(container: HTMLElement) {
    container.createEl("h4", { text: "Damage Types" });

    // Try to load from SRD data
    const damageFolder = this.app.vault.getAbstractFileByPath("z_DamageTypes");
    
    if (damageFolder instanceof TFolder && damageFolder.children.length > 0) {
      const damageGrid = container.createEl("div", { cls: "dm-screen-damage-grid" });
      
      for (const file of damageFolder.children) {
        if (file instanceof TFile && file.extension === "md") {
          const card = damageGrid.createEl("div", { cls: "dm-damage-card" });
          const nameEl = card.createEl("strong", { text: file.basename });
          nameEl.addClass("dm-damage-link");
          nameEl.addEventListener("click", async () => {
            await this.app.workspace.openLinkText(file.path, "", true);
          });
          
          // Read description
          try {
            const content = await this.app.vault.read(file);
            const lines = content.split("\n");
            let description = "";
            let inFrontmatter = false;
            
            for (const line of lines) {
              if (line.trim() === "---") {
                inFrontmatter = !inFrontmatter;
                continue;
              }
              if (!inFrontmatter && line.trim() && !line.startsWith("#")) {
                description = line.trim();
                break;
              }
            }
            
            if (description) {
              card.createEl("p", { text: description.substring(0, 100) + (description.length > 100 ? "..." : "") });
            }
          } catch (error) {
            // Ignore
          }
        }
      }
    } else {
      // Fallback
      const damageTypes = [
        { name: "Acid", desc: "Corrosive spray or digestive enzymes.", example: "Black dragon breath" },
        { name: "Bludgeoning", desc: "Blunt force attacks.", example: "Clubs, falling, constriction" },
        { name: "Cold", desc: "Infernal chill.", example: "White dragon breath, cone of cold" },
        { name: "Fire", desc: "Flames and heat.", example: "Red dragon breath, fireball" },
        { name: "Force", desc: "Pure magical energy.", example: "Magic missile, spiritual weapon" },
        { name: "Lightning", desc: "Electrical discharge.", example: "Blue dragon breath, lightning bolt" },
        { name: "Necrotic", desc: "Life-draining energy.", example: "Chill touch, harm" },
        { name: "Piercing", desc: "Puncturing and stabbing.", example: "Arrows, spears, teeth" },
        { name: "Poison", desc: "Toxins and venom.", example: "Green dragon breath, poison spray" },
        { name: "Psychic", desc: "Mental assault.", example: "Mind flayer attacks, vicious mockery" },
        { name: "Radiant", desc: "Divine and celestial.", example: "Guiding bolt, sacred flame" },
        { name: "Slashing", desc: "Cutting attacks.", example: "Swords, axes, claws" },
        { name: "Thunder", desc: "Concussive sound.", example: "Thunderwave, shatter" }
      ];

      const damageGrid = container.createEl("div", { cls: "dm-screen-damage-grid" });
      
      for (const type of damageTypes) {
        const card = damageGrid.createEl("div", { cls: "dm-damage-card" });
        card.createEl("strong", { text: type.name });
        card.createEl("p", { text: type.desc });
        card.createEl("p", { text: `(${type.example})`, cls: "dm-damage-example" });
      }
    }

    // Resistances and Immunities
    const resistSection = container.createEl("div", { cls: "dm-screen-section" });
    resistSection.createEl("h5", { text: "Resistance & Immunity" });
    resistSection.createEl("p", { text: "Resistance: Take half damage (round down)" });
    resistSection.createEl("p", { text: "Vulnerability: Take double damage" });
    resistSection.createEl("p", { text: "Immunity: Take no damage" });
    resistSection.createEl("p", { text: "Multiple resistances/vulnerabilities don't stack." });
  }

  renderCoverTab(container: HTMLElement) {
    container.createEl("h4", { text: "Cover" });

    const coverSection = container.createEl("div", { cls: "dm-screen-section" });
    const coverTable = coverSection.createEl("table", { cls: "dm-screen-table" });
    const coverBody = coverTable.createEl("tbody");
    
    const header = coverBody.createEl("tr");
    header.createEl("th", { text: "Cover" });
    header.createEl("th", { text: "AC/DEX Bonus" });
    header.createEl("th", { text: "Example" });

    const covers = [
      { type: "Half Cover", bonus: "+2", example: "Low wall, furniture, another creature" },
      { type: "Three-Quarters", bonus: "+5", example: "Arrow slit, tree trunk" },
      { type: "Total Cover", bonus: "Can't be targeted", example: "Completely concealed" }
    ];

    for (const cover of covers) {
      const row = coverBody.createEl("tr");
      row.createEl("td", { text: cover.type });
      row.createEl("td", { text: cover.bonus, cls: "dm-table-highlight" });
      row.createEl("td", { text: cover.example });
    }

    // Obscurement
    const obscureSection = container.createEl("div", { cls: "dm-screen-section" });
    obscureSection.createEl("h5", { text: "Obscurement" });
    
    const obscureTable = obscureSection.createEl("table", { cls: "dm-screen-table" });
    const obscureBody = obscureTable.createEl("tbody");
    
    const obscureHeader = obscureBody.createEl("tr");
    obscureHeader.createEl("th", { text: "Type" });
    obscureHeader.createEl("th", { text: "Effect" });
    obscureHeader.createEl("th", { text: "Example" });

    const obscures = [
      { type: "Lightly Obscured", effect: "Disadvantage on Perception", example: "Dim light, patchy fog, moderate foliage" },
      { type: "Heavily Obscured", effect: "Effectively blinded", example: "Darkness, opaque fog, dense foliage" }
    ];

    for (const obs of obscures) {
      const row = obscureBody.createEl("tr");
      row.createEl("td", { text: obs.type });
      row.createEl("td", { text: obs.effect });
      row.createEl("td", { text: obs.example });
    }

    // Light
    const lightSection = container.createEl("div", { cls: "dm-screen-section" });
    lightSection.createEl("h5", { text: "Light" });
    lightSection.createEl("p", { text: "Bright Light: Normal vision" });
    lightSection.createEl("p", { text: "Dim Light: Lightly obscured, disadvantage on Perception" });
    lightSection.createEl("p", { text: "Darkness: Heavily obscured, effectively blinded" });

    // Vision Types
    const visionSection = container.createEl("div", { cls: "dm-screen-section" });
    visionSection.createEl("h5", { text: "Special Vision" });
    visionSection.createEl("p", { text: "Darkvision: See dim light as bright, darkness as dim (no color). Common range: 60 ft." });
    visionSection.createEl("p", { text: "Blindsight: Perceive surroundings without sight. Common range: 10-60 ft." });
    visionSection.createEl("p", { text: "Truesight: See in darkness, invisible creatures, illusions, shapechangers, ethereal plane." });
    visionSection.createEl("p", { text: "Tremorsense: Detect vibrations through the ground." });
  }

  async onClose() {
    const container = this.containerEl.children[1];
    if (container) {
      container.empty();
    }
  }
}

/**
 * TabletopCalibrationModal - Allows the user to calibrate their monitor's
 * physical dimensions for tabletop miniature mode.
 */
class TabletopCalibrationModal extends Modal {
  plugin: DndCampaignHubPlugin;
  private onDone: (calibration: TabletopCalibration) => void;
  private win: Window;

  constructor(app: App, plugin: DndCampaignHubPlugin, popoutWin: Window, onDone: (cal: TabletopCalibration) => void) {
    super(app);
    this.plugin = plugin;
    this.onDone = onDone;
    this.win = popoutWin;
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dnd-tabletop-calibration-modal');

    contentEl.createEl('h2', { text: 'üéØ Tabletop Calibration' });
    contentEl.createEl('p', {
      text: 'Configure your monitor so the grid matches physical miniature bases.',
      cls: 'setting-item-description'
    });

    // Get screen info for the popout window
    const screen = this.win.screen;
    const screenW = screen.width * (this.win.devicePixelRatio || 1);
    const screenH = screen.height * (this.win.devicePixelRatio || 1);

    const existing = this.plugin.settings.tabletopCalibration;

    // --- Step 1: Monitor Size ---
    contentEl.createEl('h3', { text: 'üìê Monitor Size' });
    const monitorInfo = contentEl.createDiv({ cls: 'dnd-calibration-info' });
    monitorInfo.setText(`Screen resolution: ${screenW} √ó ${screenH} px`);

    const diagonalSetting = contentEl.createDiv({ cls: 'dnd-map-calibration-input' });
    diagonalSetting.createEl('label', { text: 'Monitor diagonal (inches):' });
    const diagonalInput = diagonalSetting.createEl('input', {
      type: 'number',
      attr: { min: '10', max: '100', step: '0.1', placeholder: '27' }
    }) as HTMLInputElement;
    diagonalInput.value = existing?.monitorDiagonalInch?.toString() || '';

    // Computed PPI display
    const ppiDisplay = contentEl.createDiv({ cls: 'dnd-calibration-info' });
    ppiDisplay.style.marginTop = '8px';

    const computePPMM = () => {
      const diag = parseFloat(diagonalInput.value);
      if (!diag || diag <= 0) {
        ppiDisplay.setText('Enter monitor diagonal to compute pixel density.');
        return 0;
      }
      const diagPx = Math.sqrt(screenW * screenW + screenH * screenH);
      const ppi = diagPx / diag;
      const ppmm = ppi / 25.4;
      ppiDisplay.setText(`Computed: ${ppi.toFixed(1)} PPI ‚Üí ${ppmm.toFixed(2)} px/mm`);
      return ppmm;
    };
    diagonalInput.addEventListener('input', computePPMM);
    computePPMM();

    // --- Step 2: Mini Base Size ---
    contentEl.createEl('h3', { text: 'üßç Miniature Base Size' });
    contentEl.createEl('p', {
      text: 'The physical size each grid cell should be. Standard D&D bases: 25mm (1"), large: 50mm (2").',
      cls: 'setting-item-description'
    });

    const baseSetting = contentEl.createDiv({ cls: 'dnd-map-calibration-input' });
    baseSetting.createEl('label', { text: 'Grid cell size (mm):' });
    const baseInput = baseSetting.createEl('input', {
      type: 'number',
      attr: { min: '10', max: '100', step: '1', placeholder: '25' }
    }) as HTMLInputElement;
    baseInput.value = (existing?.miniBaseMm || 25).toString();

    // --- Step 3: Fine-tune with on-screen ruler ---
    contentEl.createEl('h3', { text: 'üìè Fine-Tune (Optional)' });
    contentEl.createEl('p', {
      text: 'Adjust the slider until the bar below matches a known physical measurement (e.g., a credit card is 85.6mm wide).',
      cls: 'setting-item-description'
    });

    const rulerContainer = contentEl.createDiv({ cls: 'dnd-calibration-ruler-container' });

    // The ruler bar
    const rulerBar = rulerContainer.createDiv({ cls: 'dnd-calibration-ruler-bar' });
    const rulerLabel = rulerContainer.createDiv({ cls: 'dnd-calibration-ruler-label' });
    rulerLabel.setText('85.6 mm');
    const targetMm = 85.6; // credit card width

    // Fine-tune slider (adjustment factor: 0.8 to 1.2)
    const sliderRow = contentEl.createDiv({ cls: 'dnd-map-calibration-input' });
    sliderRow.createEl('label', { text: 'Fine-tune adjustment:' });
    const slider = sliderRow.createEl('input', {
      type: 'range',
      attr: { min: '0.80', max: '1.20', step: '0.005', value: '1.00' }
    }) as HTMLInputElement;
    const sliderValue = sliderRow.createEl('span');
    sliderValue.setText('1.00√ó');

    const updateRuler = () => {
      const ppmm = computePPMM();
      const adj = parseFloat(slider.value);
      sliderValue.setText(`${adj.toFixed(3)}√ó`);
      if (ppmm > 0) {
        const rulerPx = targetMm * ppmm * adj;
        rulerBar.style.width = rulerPx + 'px';
      }
    };
    slider.addEventListener('input', updateRuler);
    diagonalInput.addEventListener('input', updateRuler);
    updateRuler();

    // --- Buttons ---
    const btnRow = contentEl.createDiv({ cls: 'modal-button-container' });

    const cancelBtn = btnRow.createEl('button', { text: 'Cancel' });
    cancelBtn.addEventListener('click', () => this.close());

    const saveBtn = btnRow.createEl('button', { text: 'Save & Apply', cls: 'mod-cta' });
    saveBtn.addEventListener('click', async () => {
      const diag = parseFloat(diagonalInput.value);
      if (!diag || diag <= 0) {
        new Notice('Please enter your monitor diagonal size.');
        return;
      }
      const baseMm = parseFloat(baseInput.value) || 25;
      const adj = parseFloat(slider.value) || 1.0;
      const diagPx = Math.sqrt(screenW * screenW + screenH * screenH);
      const ppi = diagPx / diag;
      const ppmm = (ppi / 25.4) * adj;

      const calibration: TabletopCalibration = {
        monitorDiagonalInch: diag,
        pixelsPerMm: ppmm,
        miniBaseMm: baseMm
      };
      this.plugin.settings.tabletopCalibration = calibration;
      await this.plugin.saveSettings();
      this.onDone(calibration);
      this.close();
      new Notice(`Tabletop calibrated: ${ppmm.toFixed(2)} px/mm, grid = ${baseMm}mm`);
    });
  }

  onClose() {
    this.contentEl.empty();
  }
}

/**
 * PlayerMapView - Renders a read-only player view of the battle map
 * in a popout window using Obsidian's native openPopoutLeaf() API.
 * Shows only Player layer annotations with real-time sync from the GM view.
 */
class PlayerMapView extends ItemView {
  plugin: DndCampaignHubPlugin;
  private mapConfig: any = null;
  private imageResourcePath: string = '';
  private mapId: string = ''; // Unique identifier for the associated GM map
  private canvas: HTMLCanvasElement | null = null;
  private mapImage: MapMediaElement | null = null;
  private markerImageCache: Map<string, HTMLImageElement> = new Map();
  // Tabletop mode state
  private tabletopMode: boolean = true;
  private tabletopPanX: number = 0;
  private tabletopPanY: number = 0;
  private tabletopScale: number = 1;
  private tabletopRotation: number = 0; // degrees, clockwise
  private tabletopTargetX: number | null = null; // desired image top-left X (natural px)
  private tabletopTargetY: number | null = null; // desired image top-left Y (natural px)
  private mapContainer: HTMLDivElement | null = null;
  private syncCanvasToImage: (() => void) | null = null;
  private isFullscreen: boolean = false; // Track fullscreen state

  constructor(leaf: WorkspaceLeaf, plugin: DndCampaignHubPlugin) {
    super(leaf);
    this.plugin = plugin;
  }

  getViewType(): string {
    return PLAYER_MAP_VIEW_TYPE;
  }

  getDisplayText(): string {
    return "Player View";
  }

  getIcon(): string {
    return "eye";
  }

  async setState(state: any, result: any) {
    if (state.mapConfig) {
      this.mapConfig = state.mapConfig;
    }
    if (state.imageResourcePath) {
      this.imageResourcePath = state.imageResourcePath;
    }
    if (state.mapId) {
      this.mapId = state.mapId;
      console.log('[Player View] setState - mapId set to:', this.mapId);
    } else {
      console.log('[Player View] setState - no mapId in state, current mapId:', this.mapId);
    }
    await super.setState(state, result);
    if (this.mapConfig) {
      this.renderPlayerView();
    }
  }

  getState() {
    return {
      mapConfig: this.mapConfig,
      imageResourcePath: this.imageResourcePath,
      mapId: this.mapId
    };
  }

  /**
   * Called by the GM view to push real-time updates
   */
  updateMapData(config: any) {
    console.log('[PV] updateMapData called with config:', config);
    // Extract travel animation data before storing config
    const hexcrawlTravel = config.hexcrawlTravel;
    if (hexcrawlTravel) {
      delete config.hexcrawlTravel; // Don't persist animation trigger
    }
    this.mapConfig = config;
    // Use syncCanvasToImage when available ‚Äî it ensures the canvas is properly
    // sized before drawing (important for video where media may still be loading).
    if (this.syncCanvasToImage) {
      console.log('[PV] mapConfig updated, calling syncCanvasToImage');
      this.syncCanvasToImage();
    } else {
      console.log('[PV] mapConfig updated, calling redrawAnnotations (no sync fn yet)');
      this.redrawAnnotations();
    }
    // Trigger hexcrawl travel animation if present
    if (hexcrawlTravel) {
      console.log('[PV] Triggering hexcrawl travel animation:', hexcrawlTravel);
      this.animateHexcrawlTravel(hexcrawlTravel.fromCol, hexcrawlTravel.fromRow, hexcrawlTravel.toCol, hexcrawlTravel.toRow);
    }
    console.log('[PV] update completed');
  }

  /**
   * Set tabletop pan to show given image coordinates at top-left of viewport.
   * Called by GM when dragging the player-view region rectangle.
   * @param x - Image x coordinate (natural pixels)
   * @param y - Image y coordinate (natural pixels)
   */
  /**
   * Set viewport to show a specific image coordinate at the center of the screen.
   * This is the simplified approach: we always center the view on the given point.
   * @param centerX - Image X coordinate to center on
   * @param centerY - Image Y coordinate to center on
   */
  setTabletopPanFromImageCoords(centerX: number, centerY: number) {
    try { console.debug('[PV] setTabletopPanFromImageCoords (center-based)', { centerX, centerY, scale: this.tabletopScale, rot: this.tabletopRotation }); } catch (e) {}
    
    // Store the desired center point
    this.tabletopTargetX = centerX;
    this.tabletopTargetY = centerY;

    // Apply transform which will center this point in the viewport
    this.applyTabletopTransform();
  }

  /**
   * Set tabletop rotation.
   * Called by GM when using Q/E keys to rotate the player view.
   * @param rotation - Rotation in degrees (0, 90, 180, 270)
   */
  setTabletopRotation(rotation: number) {
    this.tabletopRotation = ((rotation % 360) + 360) % 360;

    // Use centralized transform application so rotation does not wipe out pan
    this.applyTabletopTransform();
  }

  /**
   * Set tabletop scale (uniform). Called by GM to project a GM indicator
   * rectangle exactly into the player viewport.
   */
  setTabletopScale(scale: number) {
    this.tabletopScale = scale || 1;
    try { console.debug('[PV] setTabletopScale', { scale: this.tabletopScale }); } catch (e) {}
    this.applyTabletopTransform();
  }

  /**
   * Enable/disable tabletop mode programmatically (called from GM view)
   */
  setTabletopMode(on: boolean) {
    // Tabletop mode is always enforced on the player view. Ignore requests
    // to disable; keep behavior idempotent for callers.
    this.tabletopMode = true;
    this.syncGmViewRectVisibility();
    if (this.syncCanvasToImage) this.syncCanvasToImage();
    this.applyTabletopTransform();
  }

  /**
   * Toggle fullscreen for the player view window (popout leaf document)
   */
  toggleFullscreen() {
    try {
      const win = (this.containerEl as any).win || this.containerEl.ownerDocument?.defaultView || window;
      const doc = win.document;
      
      if (!this.isFullscreen) {
        // Enter fullscreen
        this.isFullscreen = true;
        this.hideObsidianChrome();
        doc.documentElement.requestFullscreen().catch((e: any) => {
          console.warn('Fullscreen request failed', e);
        });
      } else {
        // Exit fullscreen
        this.isFullscreen = false;
        this.showObsidianChrome();
        if (doc.fullscreenElement) {
          doc.exitFullscreen().catch((e: any) => {
            console.warn('Exit fullscreen failed', e);
          });
        }
      }
    } catch (e) { console.warn('toggleFullscreen failed', e); }
  }

  private applyTabletopTransform() {
    if (!this.mapContainer || !this.mapImage) return;
    const sled = this.mapContainer.querySelector('.dnd-player-map-sled') as HTMLElement;
    if (!sled) return;

    const s = this.tabletopScale || 1;
    const deg = this.tabletopRotation || 0;
    const rad = (deg * Math.PI) / 180;
    const c = Math.cos(rad);
    const sn = Math.sin(rad);

    // Get viewport dimensions
    const viewportRect = this.mapContainer.getBoundingClientRect();
    const vcx = viewportRect.width / 2;
    const vcy = viewportRect.height / 2;

    // If GM requested a specific image center, compute pan to center it in viewport
    if (this.tabletopTargetX !== null && this.tabletopTargetY !== null) {
      const cx = this.tabletopTargetX;
      const cy = this.tabletopTargetY;

      // Transform: translate(panX, panY) rotate(deg) scale(s)
      // Applied right-to-left: scale first, then rotate, then translate
      // After scale: (cx*s, cy*s)
      // After rotate by +deg around origin: (cx*s*cos - cy*s*sin, cx*s*sin + cy*s*cos)  
      // After translate: add panX, panY
      // Want result at viewport center (vcx, vcy):
      this.tabletopPanX = vcx - s * (c * cx - sn * cy);
      this.tabletopPanY = vcy - s * (sn * cx + c * cy);

      try { console.debug('[PV] applyTabletopTransform (center-based)', { centerX: cx, centerY: cy, viewportCenter: [vcx, vcy], panX: this.tabletopPanX, panY: this.tabletopPanY, scale: s, rot: deg }); } catch (e) {}
    }

    // Clamp based on rotated bbox in SCREEN space
    this.clampTabletopPan();

    sled.style.transformOrigin = '0 0';
    sled.style.left = '0px';
    sled.style.top = '0px';

    // Apply scale in the transform along with rotation and translation
    sled.style.transform = `translate(${this.tabletopPanX}px, ${this.tabletopPanY}px) rotate(${deg}deg) scale(${s})`;
    try { console.debug('[PV] sled transform applied', { transform: sled.style.transform, panX: this.tabletopPanX, panY: this.tabletopPanY, rot: deg, scale: s }); } catch (e) {}
  }

  private clampTabletopPan() {
    const img = this.mapImage;
    const wrap = this.mapContainer;
    if (!img || !wrap) return;

    const s = this.tabletopScale || 1;
    const deg = this.tabletopRotation || 0;
    const rad = (deg * Math.PI) / 180;
    const c = Math.cos(rad);
    const sn = Math.sin(rad);

    const W = img.naturalWidth * s;
    const H = img.naturalHeight * s;

    // Rotated corners in SCREEN space (before pan)
    const pts = [
      { x: 0, y: 0 },
      { x: W, y: 0 },
      { x: 0, y: H },
      { x: W, y: H }
    ].map(p => ({ x: c * p.x - sn * p.y, y: sn * p.x + c * p.y }));

    const minX0 = Math.min(...pts.map(p => p.x));
    const maxX0 = Math.max(...pts.map(p => p.x));
    const minY0 = Math.min(...pts.map(p => p.y));
    const maxY0 = Math.max(...pts.map(p => p.y));

    const r = wrap.getBoundingClientRect();
    const vw = r.width;
    const vh = r.height;

    // Debug: log computed bbox and viewport sizes to diagnose width clipping
    console.debug('[PV] clampTabletopPan bbox', { minX0, maxX0, minY0, maxY0, vw, vh, panBefore: this.tabletopPanX });

    // Compute the strict pan ranges that would keep the rotated bbox
    // fully covering the viewport. For large rotated bboxes this enforces
    // that no empty area appears; for our UX we want the player to be
    // able to freely pan the map, so we only CENTER when the rotated
    // bbox is smaller than the viewport and otherwise allow free panning.
    const panMinX = vw - maxX0;
    const panMaxX = -minX0;
    const panMinY = vh - maxY0;
    const panMaxY = -minY0;

    // If the rotated bbox is smaller than the viewport, center it.
    if (panMinX > panMaxX) {
      const centerX = (vw - (maxX0 - minX0)) / 2;
      this.tabletopPanX = centerX - minX0;
    } else {
      // Otherwise: allow free horizontal panning (do not hard-clamp here).
      // Leave `this.tabletopPanX` unchanged so the user can explore fully.
    }

    if (panMinY > panMaxY) {
      const centerY = (vh - (maxY0 - minY0)) / 2;
      this.tabletopPanY = centerY - minY0;
    } else {
      // Allow free vertical panning as well.
    }

    console.debug('[PV] clampTabletopPan result', { panMinX, panMaxX, panMinY, panMaxY, panAfterX: this.tabletopPanX, panAfterY: this.tabletopPanY });
  }

  /**
   * Sync GM view rect visibility based on tabletop mode state.
   * Shows rect when this player view is in tabletop mode, hides when exiting.
   */
  syncGmViewRectVisibility() {
    try {
      // Find GM map viewport(s) and trigger redraw
      const leaves = this.plugin.app.workspace.getLeavesOfType('markdown');
      leaves.forEach((leaf: any) => {
        try {
          const viewportEl = leaf.view?.containerEl?.querySelector('.dnd-map-viewport');
          if (viewportEl) {
            const gmRect = (this.plugin as any)._gmViewRect;
            if (this.tabletopMode) {
              // Entering tabletop mode - ensure rect exists and is visible
              if (!gmRect || !gmRect.w || !gmRect.h) {
                // Create initial rect if none exists
                const rect = {
                  x: 0,
                  y: 0,
                  w: 800,
                  h: 600
                };
                try { (viewportEl as any)._gmViewRect = rect; } catch (e) { }
                try { (this.plugin as any)._gmViewRect = rect; } catch (e) { }
              }
            } else {
              // Exiting tabletop mode - check if any other player views are still in tabletop mode
              let anyTabletopActive = false;
              if ((this.plugin as any)._playerMapViews) {
                (this.plugin as any)._playerMapViews.forEach((pv: any) => {
                  if (pv !== this && pv.tabletopMode) {
                    anyTabletopActive = true;
                  }
                });
              }
              // If no other views in tabletop mode, hide the rect
              if (!anyTabletopActive && gmRect) {
                try { delete (viewportEl as any)._gmViewRect; } catch (e) { }
                try { delete (this.plugin as any)._gmViewRect; } catch (e) { }
              }
            }
            // Trigger redraw
            viewportEl.dispatchEvent(new CustomEvent('gm-rect-updated'));
          }
        } catch (e) { }
      });
    } catch (e) { }
  }

  async onOpen() {
    const container = this.containerEl.children[1] as HTMLElement;
    container.empty();
    container.addClass('dnd-player-map-container');

    // Don't hide chrome by default - let fullscreen toggle handle it

    if (this.mapConfig) {
      this.renderPlayerView();
    }
  }

  /**
   * Hide the Obsidian view header and tab bar.
   * Injects CSS into the popout window's document to hide all chrome.
   */
  private hideObsidianChrome() {
    // Get the window that owns this view (popout window, not main window)
    const win = (this.containerEl as any).win || this.containerEl.ownerDocument?.defaultView;
    if (!win || win === window) {
      // Don't apply to main window, only to popout windows
      return;
    }
    const doc = win.document;

    // Remove any existing style first
    const existingStyle = doc.getElementById('dnd-player-view-chrome-hide');
    if (existingStyle) {
      existingStyle.remove();
    }

    const style = doc.createElement('style');
    style.id = 'dnd-player-view-chrome-hide';
    style.textContent = `
      /* Hide the tab header bar completely */
      .workspace-tab-header-container {
        display: none !important;
      }

      /* Hide the view header (title bar) completely */
      .view-header {
        display: none !important;
      }

      /* Hide titlebar / window decorations */
      .titlebar {
        display: none !important;
      }

      /* Hide sidebar toggles if any */
      .sidebar-toggle-button {
        display: none !important;
      }

      /* Hide status bar */
      .status-bar {
        display: none !important;
      }

      /* Ensure content fills the full window from the very top */
      .mod-root {
        top: 0 !important;
      }

      .workspace-leaf-content {
        position: relative !important;
      }

      /* Remove any hover trigger zones */
      .workspace-leaf-content::before {
        display: none !important;
      }
    `;
    doc.head.appendChild(style);
  }

  /**
   * Show the Obsidian chrome by removing the hide styles.
   */
  private showObsidianChrome() {
    const win = (this.containerEl as any).win || this.containerEl.ownerDocument?.defaultView;
    if (!win || win === window) {
      return;
    }
    const doc = win.document;
    const style = doc.getElementById('dnd-player-view-chrome-hide');
    if (style) {
      style.remove();
    }
  }

  private renderPlayerView() {
    const container = this.containerEl.children[1] as HTMLElement;
    container.empty();
    container.addClass('dnd-player-map-container');

    // Button toolbar (top-right corner)
    const toolbar = container.createDiv({ cls: 'dnd-player-toolbar' });

    // Fullscreen button
    const fullscreenBtn = toolbar.createEl('button', {
      cls: 'dnd-player-toolbar-btn',
      text: 'üñµ Fullscreen'
    });
    fullscreenBtn.addEventListener('click', () => {
      this.toggleFullscreen();
    });

    // Listen for fullscreen state changes (e.g., user presses ESC)
    const win = (this.containerEl as any).win || window;
    const doc = win.document;
    const handleFullscreenChange = () => {
      if (!doc.fullscreenElement && this.isFullscreen) {
        // Exited fullscreen via ESC or other means
        this.isFullscreen = false;
        this.showObsidianChrome();
      }
    };
    doc.addEventListener('fullscreenchange', handleFullscreenChange);
    // Store reference for cleanup if needed
    (this as any)._fullscreenChangeHandler = handleFullscreenChange;

    // Tabletop mode button
    const tabletopBtn = toolbar.createEl('button', {
      cls: 'dnd-player-toolbar-btn',
      text: this.tabletopMode ? 'üé≤ Tabletop: ON' : 'üé≤ Tabletop: OFF'
    });

    // Calibrate button
    const calibrateBtn = toolbar.createEl('button', {
      cls: 'dnd-player-toolbar-btn',
      text: 'üéØ Calibrate'
    });

    // Hide player-side calibrate UI: calibration is managed from the GM map view
    calibrateBtn.style.display = 'none';

    // Mini size display
    const miniSizeLabel = toolbar.createEl('span', {
      cls: 'dnd-player-toolbar-label'
    });
    const updateMiniLabel = () => {
      const cal = this.plugin.settings.tabletopCalibration;
      if (cal) {
        miniSizeLabel.setText(`Grid: ${cal.miniBaseMm}mm`);
        miniSizeLabel.style.display = '';
      } else {
        miniSizeLabel.style.display = 'none';
      }
    };
    updateMiniLabel();

    // Rotate controls for tabletop mode
    const rotateLeftBtn = toolbar.createEl('button', { cls: 'dnd-player-toolbar-btn', text: '‚§∫' });
    const rotateResetBtn = toolbar.createEl('button', { cls: 'dnd-player-toolbar-btn', text: '0¬∞' });
    const rotateRightBtn = toolbar.createEl('button', { cls: 'dnd-player-toolbar-btn', text: '‚§ª' });

    // Hide player-side controls: GM map view will provide these controls instead
    fullscreenBtn.style.display = 'none';
    tabletopBtn.style.display = 'none';
    rotateLeftBtn.style.display = 'none';
    rotateResetBtn.style.display = 'none';
    rotateRightBtn.style.display = 'none';


    // Map container
    const mapContainer = container.createDiv({ cls: 'dnd-player-map-wrapper' });
    this.mapContainer = mapContainer;

    // Inner sled wraps image + canvas, pans together in tabletop mode
    const sled = mapContainer.createDiv({ cls: 'dnd-player-map-sled' });

    // Image or video background
    const isVideo = this.mapConfig?.isVideo || /\.(mp4|webm)$/i.test(this.imageResourcePath);
    let img: MapMediaElement;
    if (isVideo) {
      const video = sled.createEl('video', {
        cls: 'dnd-player-map-image dnd-player-map-video',
        attr: {
          src: this.imageResourcePath,
          autoplay: '',
          loop: '',
          muted: '',
          playsinline: '',
        }
      });
      video.autoplay = true;
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      // Shim image-compatible properties so existing code works transparently
      Object.defineProperty(video, 'naturalWidth', { get: () => video.videoWidth, configurable: true });
      Object.defineProperty(video, 'naturalHeight', { get: () => video.videoHeight, configurable: true });
      Object.defineProperty(video, 'complete', { get: () => video.readyState >= 2, configurable: true });
      // Shim width/height to return rendered size (HTMLImageElement.width returns clientWidth)
      Object.defineProperty(video, 'width', { get: () => video.clientWidth || video.videoWidth, configurable: true });
      Object.defineProperty(video, 'height', { get: () => video.clientHeight || video.videoHeight, configurable: true });
      img = video as MapMediaElement;
    } else {
      img = sled.createEl('img', {
        cls: 'dnd-player-map-image',
        attr: {
          src: this.imageResourcePath,
          alt: this.mapConfig?.name || 'Battle Map'
        }
      });
    }
    this.mapImage = img;

    // Annotation canvas
    const canvas = sled.createEl('canvas', {
      cls: 'dnd-player-map-canvas'
    });
    this.canvas = canvas;

    // Helper to sync canvas CSS size and position to match displayed image exactly
    const syncCanvasToImage = () => {
      if (img.complete && img.naturalWidth > 0) {
        // Ensure buffer matches natural image size
        if (canvas.width !== img.naturalWidth || canvas.height !== img.naturalHeight) {
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
        }

        if (this.tabletopMode) {
          // In tabletop mode: image is sized by natural dimensions (no scale applied via CSS size)
          // The scale is applied via CSS transform instead
          if (this.tabletopScale && this.mapConfig?.gridSize > 0) {
            const s = this.tabletopScale;

            // Image uses natural size
            img.style.maxWidth = 'none';
            img.style.maxHeight = 'none';
            img.style.objectFit = 'none';
            img.style.width = img.naturalWidth + 'px';
            img.style.height = img.naturalHeight + 'px';

            // Sled wraps at natural size
            sled.style.width = img.naturalWidth + 'px';
            sled.style.height = img.naturalHeight + 'px';
            sled.style.position = 'absolute';
            sled.style.transformOrigin = '0 0';
            sled.style.left = '0px';
            sled.style.top = '0px';
            // Note: applyTabletopTransform will set the transform with scale
            // Don't call it here - it will be called after scale is set

            mapContainer.style.overflow = 'hidden';

            // Canvas exactly overlays image at (0,0) within the sled
            canvas.style.left = '0px';
            canvas.style.top = '0px';
            canvas.style.width = img.naturalWidth + 'px';
            canvas.style.height = img.naturalHeight + 'px';
          }

          // Expose sync helper so GM-side code can ask the player view to refresh layout
          try { this.syncCanvasToImage = syncCanvasToImage; } catch (e) { }

            // If a GM-side view rect exists on the plugin, update its scaled pixel bounds so redrawAnnotations can draw it
            try {
              const gmRect = (this.plugin as any)._gmViewRect;
              if (gmRect) {
                (gmRect as any).__scaledW = img.naturalWidth * this.tabletopScale;
                (gmRect as any).__scaledH = img.naturalHeight * this.tabletopScale;
              }
            } catch {}
        } else {
          // Normal mode: fit to screen
          img.style.maxWidth = '100%';
          img.style.maxHeight = '100%';
          img.style.objectFit = 'contain';
          img.style.width = '';
          img.style.height = '';
            sled.style.width = '';
          sled.style.height = '';
          sled.style.position = '';
          sled.style.left = '';
          sled.style.top = '';
          mapContainer.style.overflow = 'hidden';

          // Use getBoundingClientRect for accurate post-layout dimensions
          const imgRect = img.getBoundingClientRect();
          const sledRect = sled.getBoundingClientRect();
          canvas.style.left = (imgRect.left - sledRect.left) + 'px';
          canvas.style.top = (imgRect.top - sledRect.top) + 'px';
          canvas.style.width = imgRect.width + 'px';
          canvas.style.height = imgRect.height + 'px';
        }

        this.redrawAnnotations();
      }
    };
    this.syncCanvasToImage = syncCanvasToImage;

    // --- Tabletop mode: pan/drag (moves the sled) ---
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;

    mapContainer.addEventListener('mousedown', (e: MouseEvent) => {
      if (!this.tabletopMode) return;
      isPanning = true;
      // If GM previously requested a specific image top-left, clear it - manual pan takes precedence
      this.tabletopTargetX = null;
      this.tabletopTargetY = null;

      panStartX = e.clientX - this.tabletopPanX;
      panStartY = e.clientY - this.tabletopPanY;
      mapContainer.style.cursor = 'grabbing';
      e.preventDefault();
    });

    mapContainer.addEventListener('mousemove', (e: MouseEvent) => {
      if (!isPanning || !this.tabletopMode) return;
      this.tabletopPanX = e.clientX - panStartX;
      this.tabletopPanY = e.clientY - panStartY;

      // Clamp using rotation-aware bbox and apply transform
      this.clampTabletopPan();
      this.applyTabletopTransform();
    });

    

    const stopPan = () => {
      if (isPanning) {
        isPanning = false;
        mapContainer.style.cursor = this.tabletopMode ? 'grab' : '';
        
        // Bidirectional sync: report current top-left image coords back to GM
        if (this.tabletopMode && this.tabletopScale > 0) {
          // Convert current pan back to image coords accounting for rotation
          const s = this.tabletopScale || 1;
          const deg = this.tabletopRotation || 0;
          const t = (deg * Math.PI) / 180;
          const c = Math.cos(t);
          const sn = Math.sin(t);

          // v = -pan
          const vx = -this.tabletopPanX;
          const vy = -this.tabletopPanY;

          // [x;y] = R^-1 * v / s  where R^-1 = [ c  sn; -sn  c ]
          const imageX = Math.round((c * vx + sn * vy) / s);
          const imageY = Math.round((-sn * vx + c * vy) / s);
          
          // Update GM rect position and trigger redraw
          try {
            const gmRect = (this.plugin as any)._gmViewRect;
            if (gmRect) {
              gmRect.x = Math.max(0, imageX);
              gmRect.y = Math.max(0, imageY);
              
              // Find GM map view and trigger its redraw
              const leaves = this.plugin.app.workspace.getLeavesOfType('markdown');
              leaves.forEach((leaf: any) => {
                try {
                  const viewportEl = leaf.view?.containerEl?.querySelector('.dnd-map-viewport');
                  if (viewportEl && (viewportEl as any)._syncPlayerView) {
                    // Find the annotation canvas and redraw
                    const canvas = viewportEl.querySelector('.dnd-map-annotation-canvas') as HTMLCanvasElement;
                    if (canvas) {
                      // Trigger redraw by dispatching a custom event
                      viewportEl.dispatchEvent(new CustomEvent('gm-rect-updated'));
                    }
                  }
                } catch (e) { }
              });
            }
          } catch (e) { }
        }
      }
    };
    mapContainer.addEventListener('mouseup', stopPan);
    mapContainer.addEventListener('mouseleave', stopPan);

    // Rotation handlers (rotate 15¬∞ steps)
    rotateLeftBtn.addEventListener('click', () => {
      this.tabletopRotation = (this.tabletopRotation - 15 + 360) % 360;
      this.applyTabletopTransform();
    });
    rotateRightBtn.addEventListener('click', () => {
      this.tabletopRotation = (this.tabletopRotation + 15) % 360;
      this.applyTabletopTransform();
    });
    rotateResetBtn.addEventListener('click', () => {
      this.tabletopRotation = 0;
      this.applyTabletopTransform();
    });

    // --- Tabletop button handlers ---
    const applyTabletopMode = () => {
      tabletopBtn.setText(this.tabletopMode ? 'üé≤ Tabletop: ON' : 'üé≤ Tabletop: OFF');
      tabletopBtn.toggleClass('active', this.tabletopMode);
      mapContainer.style.cursor = this.tabletopMode ? 'grab' : '';
      if (!this.tabletopMode) {
        this.tabletopPanX = 0;
        this.tabletopPanY = 0;
      }
      // Sync GM view rect visibility based on tabletop mode state
      this.syncGmViewRectVisibility();
      // Call sync immediately for tabletop mode (dimensions are explicit),
      // then defer for normal mode where layout needs to settle
      syncCanvasToImage();
      requestAnimationFrame(syncCanvasToImage);
    };

    tabletopBtn.addEventListener('click', () => {
      // Tabletop mode is enforced on the player view (GM is authoritative).
      // Ignore user clicks that attempt to disable it; refresh UI instead.
      this.tabletopMode = true;
      applyTabletopMode();
    });

    // Player-side calibration removed; calibration should be performed from GM view.

    // Size canvas when media loads
    const onPlayerMediaReady = () => {
      canvas.width = (img as any).naturalWidth;
      canvas.height = (img as any).naturalHeight;
      // Defer one frame so media has been laid out, then sync position
      requestAnimationFrame(syncCanvasToImage);
    };
    if (isVideo) {
      img.addEventListener('loadeddata', onPlayerMediaReady, { once: true });
      if ((img as any).readyState >= 2) onPlayerMediaReady();
    } else {
      img.addEventListener('load', onPlayerMediaReady);
    }

    // Handle window resize ‚Äî defer one frame to ensure layout is settled
    const resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(syncCanvasToImage);
    });
    resizeObserver.observe(mapContainer);
    this.register(() => resizeObserver.disconnect());

    // Handle fullscreen transitions (F11 / button)
    // Use multiple deferred frames since browsers need time to settle after fullscreen reflow
    const onFullscreenChange = () => {
      // Fire at multiple intervals to catch the layout settling
      requestAnimationFrame(syncCanvasToImage);
      requestAnimationFrame(() => requestAnimationFrame(syncCanvasToImage));
      setTimeout(syncCanvasToImage, 100);
      setTimeout(syncCanvasToImage, 300);
    };
    win.document.addEventListener('fullscreenchange', onFullscreenChange);
    this.register(() => win.document.removeEventListener('fullscreenchange', onFullscreenChange));

    // Also listen for window resize events directly (catches F11 without fullscreen API)
    const onWinResize = () => {
      requestAnimationFrame(syncCanvasToImage);
      setTimeout(syncCanvasToImage, 100);
    };
    win.addEventListener('resize', onWinResize);
    this.register(() => win.removeEventListener('resize', onWinResize));

    // If image already loaded
    if (img.complete && img.naturalWidth > 0) {
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      requestAnimationFrame(syncCanvasToImage);
    }
  }

  private loadMarkerImage(path: string): HTMLImageElement | null {
    if (this.markerImageCache.has(path)) {
      const cached = this.markerImageCache.get(path)!;
      return cached.complete && cached.naturalWidth > 0 ? cached : null;
    }
    const img = new Image();
    this.markerImageCache.set(path, img);
    try {
      img.src = this.plugin.app.vault.adapter.getResourcePath(path);
      img.onload = () => this.redrawAnnotations();
    } catch {
      // invalid path
    }
    return null;
  }

  private redrawAnnotations() {
    console.log('[PV] redrawAnnotations - canvas:', !!this.canvas, 'mapConfig:', !!this.mapConfig);
    if (!this.canvas || !this.mapConfig) return;
    const ctx = this.canvas.getContext('2d');
    if (!ctx) {
      console.log('[PV] redrawAnnotations - no context!');
      return;
    }

    const config = this.mapConfig;
    console.log('[PV] redrawAnnotations - config:', {
      gridType: config.gridType,
      gridSize: config.gridSize,
      markersCount: config.markers?.length || 0,
      drawingsCount: config.drawings?.length || 0,
      highlightsCount: config.highlights?.length || 0,
      fogEnabled: config.fogOfWar?.enabled,
      lightSourcesCount: config.lightSources?.length || 0
    });
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw grid overlay if active
    if (config.gridType && config.gridType !== 'none' && config.gridSize > 0) {
      this.drawGrid(ctx, config);
    }

    // ‚îÄ‚îÄ Hexcrawl rendering (terrain, visited trail, party marker) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const isHexcrawlMap = (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && (config.type === 'world' || config.type === 'regional');
    if (isHexcrawlMap) {
      this.drawHexcrawlLayer(ctx, config);
    }

    // Filter to Player, Elevated, and Subterranean layers (exclude DM and Background)
    // Player tokens are always visible regardless of layer
    const visibleLayers = ['Player', 'Elevated', 'Subterranean'];
    const playerMarkers = (config.markers || []).filter((m: any) => {
      const markerLayer = m.layer || 'Player';
      const markerDef = m.markerId ? this.plugin.markerLibrary.getMarker(m.markerId) : null;
      
      // Debug: log each marker being filtered
      console.log('[Layer Filter Debug]', {
        id: m.id,
        markerId: m.markerId,
        markerDefName: markerDef?.name,
        markerDefType: markerDef?.type,
        layer: markerLayer,
        hasElevation: !!m.elevation,
        isBurrowing: m.elevation?.isBurrowing,
        hasTunnelState: !!m.tunnelState,
        tunnelId: m.tunnelState?.tunnelId
      });
      
      // Always show player-type tokens (or tokens marked visible to players), even if on DM layer (for tunneling)
      if (markerDef && (markerDef.type === 'player' || m.visibleToPlayers)) {
        console.log('[Layer Filter] Including player/visible token:', m.id);
        return true; // Always show player tokens and tokens visible to players
      }
      // Also show burrowing tokens (they may be visible to players in tunnels)
      if (m.elevation?.isBurrowing) {
        console.log('[Layer Filter] Including burrowing token:', m.id);
        return true;
      }
      const included = visibleLayers.includes(markerLayer);
      console.log('[Layer Filter]', included ? 'Including' : 'EXCLUDING', 'marker:', m.id, 'layer:', markerLayer);
      return included;
    });
    const playerDrawings = (config.drawings || []).filter((d: any) => visibleLayers.includes(d.layer || 'Player'));
    const playerHighlights = (config.highlights || []).filter((h: any) => visibleLayers.includes(h.layer || 'Player'));
    const playerPoiRefs = (config.poiReferences || []).filter((p: any) => (p.layer || 'DM') === 'Player');

    // Draw highlights
    playerHighlights.forEach((h: any) => this.drawHighlight(ctx, h));

    // Draw PoI icons (player layer only) - hidden entirely for hexcrawl/exploration maps
    if (!isHexcrawlMap) {
      playerPoiRefs.forEach((p: any) => this.drawPoiIcon(ctx, p, config));
    }

    // Draw drawings
    playerDrawings.forEach((d: any) => this.drawDrawing(ctx, d));

    // Separate player tokens from other markers - player tokens should always be visible
    const playerTokens: any[] = [];
    const otherMarkers: any[] = [];
    playerMarkers.forEach((m: any) => {
      if (m.markerId) {
        const markerDef = this.plugin.markerLibrary.getMarker(m.markerId);
        if (markerDef && (markerDef.type === 'player' || m.visibleToPlayers)) {
          playerTokens.push(m);
        } else {
          otherMarkers.push(m);
        }
      } else {
        otherMarkers.push(m);
      }
    });
    
    console.log('[Marker Separation Debug] Separated markers:', {
      totalPlayerMarkers: playerMarkers.length,
      playerTokensCount: playerTokens.length,
      otherMarkersCount: otherMarkers.length,
      allPlayerMarkers: playerMarkers.map((m: any) => {
        const markerDef = m.markerId ? this.plugin.markerLibrary.getMarker(m.markerId) : null;
        return {
          id: m.id,
          markerId: m.markerId,
          markerDefType: markerDef?.type,
          markerDefName: markerDef?.name,
          hasBurrowing: !!m.elevation?.isBurrowing,
          hasTunnelState: !!m.tunnelState
        };
      }),
      playerTokens: playerTokens.map((m: any) => ({
        id: m.id,
        markerId: m.markerId,
        hasBurrowing: !!m.elevation?.isBurrowing,
        hasTunnelState: !!m.tunnelState
      })),
      otherMarkers: otherMarkers.map((m: any) => ({
        id: m.id,
        markerId: m.markerId,
        hasBurrowing: !!m.elevation?.isBurrowing,
        hasTunnelState: !!m.tunnelState
      }))
    });

    // Track players who are in tunnels - used for drawing tunnel above fog
    const tunnelPlayersInMarkers = playerTokens.filter((m: any) => m.tunnelState);

    // Draw tunnel entrances and exits (always visible on surface - these are physical holes)
    console.log('[Tunnel Debug Player Render] config.tunnels:', config.tunnels ? config.tunnels.length : 'undefined');
    if (config.tunnels && config.tunnels.length > 0) {
      const CREATURE_SIZE_SQUARES: Record<string, number> = {
        'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
      };
      
      config.tunnels.forEach((tunnel: any) => {
        console.log('[Tunnel Debug Player Render] Rendering tunnel:', tunnel.id, 'visible:', tunnel.visible, 'active:', tunnel.active, 'entrance:', tunnel.entrancePosition);
        if (!tunnel.visible) return;
        
        const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
        const radius = (squares * config.gridSize) / 2.5;
        
        // Draw entrance (always visible - it's a physical hole on the surface)
        const entrance = tunnel.entrancePosition;
        ctx.save();
        ctx.globalAlpha = 0.7;
        
        // Draw dark circle for tunnel entrance
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(entrance.x, entrance.y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw rocky border
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = Math.max(3, radius * 0.15);
        ctx.stroke();
        
        // Add inner shadow effect
        const gradient = ctx.createRadialGradient(entrance.x, entrance.y, radius * 0.3, entrance.x, entrance.y, radius);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Add tunnel entrance icon
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#8B4513';
        ctx.font = `${Math.max(12, radius * 0.8)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üï≥Ô∏è', entrance.x, entrance.y);
        
        ctx.restore();
        
        // Draw exit if tunnel is inactive (completed) and has a different exit position
        if (!tunnel.active && tunnel.path && tunnel.path.length > 1) {
          const exit = tunnel.path[tunnel.path.length - 1];
          // Only draw exit if it's different from entrance
          if (Math.abs(exit.x - tunnel.entrancePosition.x) > 5 || Math.abs(exit.y - tunnel.entrancePosition.y) > 5) {
            ctx.save();
            ctx.globalAlpha = 0.7;
            
            // Draw dark circle for tunnel exit
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(exit.x, exit.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rocky border
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = Math.max(3, radius * 0.15);
            ctx.stroke();
            
            // Add inner shadow effect
            const exitGradient = ctx.createRadialGradient(exit.x, exit.y, radius * 0.3, exit.x, exit.y, radius);
            exitGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            exitGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = exitGradient;
            ctx.fill();
            
            // Add tunnel exit icon
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#8B4513';
            ctx.font = `${Math.max(12, radius * 0.8)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üï≥Ô∏è', exit.x, exit.y);
            
            console.log('[Tunnel Debug Player Render] Drew exit at:', exit);
            ctx.restore();
          }
        }
      });
    }

    // Draw tunnel paths if a player token is in any tunnel or created it
    // Check if any player token is in a tunnel or is the creator
    if (config.tunnels && config.tunnels.length > 0 && playerTokens.length > 0) {
      const CREATURE_SIZE_SQUARES: Record<string, number> = {
        'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
      };
      
      // Calculate pixels per foot for vision range calculations
      const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
      
      // Helper function to calculate vision range for a player token
      const getVisionRange = (marker: any): number => {
        let visionRange = 0;
        
        // Check darkvision
        if (marker.darkvision && marker.darkvision > 0) {
          visionRange = Math.max(visionRange, marker.darkvision);
        }
        
        // Check attached light source
        if (marker.light && marker.light.bright !== undefined) {
          const totalLightRange = (marker.light.bright || 0) + (marker.light.dim || 0);
          visionRange = Math.max(visionRange, totalLightRange);
        }
        
        const pixelRange = visionRange * pixelsPerFoot;
        console.log('[Tunnel Vision Debug PATH] Marker vision:', {
          id: marker.id,
          darkvision: marker.darkvision,
          lightBright: marker.light?.bright,
          lightDim: marker.light?.dim,
          visionRangeFeet: visionRange,
          visionRangePx: pixelRange
        });
        
        return pixelRange;
      };
      
      // Helper function to check if a point is within vision range and line of sight
      // Uses 3D distance when elevation data is available (D&D 5e RAW: elevation counts toward distance)
      const isPointVisible = (point: { x: number; y: number; elevation?: any }, playerMarker: any, tunnel: any): boolean => {
        const visionRangePx = getVisionRange(playerMarker);
        if (visionRangePx === 0) return false; // No vision = can't see
        
        const dx = point.x - playerMarker.position.x;
        const dy = point.y - playerMarker.position.y;
        const horizontalDistSq = dx * dx + dy * dy;
        
        // Calculate vertical distance in pixels if elevation data exists
        const pointElev = point.elevation ? ((point.elevation.height || 0) - (point.elevation.depth || 0)) : 0;
        const playerElev = playerMarker.elevation ? ((playerMarker.elevation.height || 0) - (playerMarker.elevation.depth || 0)) : 0;
        const verticalFeet = Math.abs(pointElev - playerElev);
        const verticalPx = verticalFeet * pixelsPerFoot;
        
        // 3D distance (Pythagorean: horizontal¬≤ + vertical¬≤ = total¬≤)
        const distance = Math.sqrt(horizontalDistSq + verticalPx * verticalPx);
        
        return distance <= visionRangePx;
      };
      
      // Helper function to find visible segments of a tunnel path from a player's position using raycasting
      const getVisiblePathSegments = (tunnel: any, playerMarker: any): Array<Array<{x: number, y: number}>> => {
        if (!tunnel.path || tunnel.path.length < 2) return [];
        if (!playerMarker.position) return [];
        if (!tunnel.walls || tunnel.walls.length === 0) {
          console.log('[Tunnel Vision] No tunnel walls generated yet, skipping visibility');
          return [];
        }
        
        const visionRangePx = getVisionRange(playerMarker);
        if (visionRangePx === 0) return [];
        
        // Use raycasting to determine which parts of the tunnel path are visible
        // Compute visibility polygon using tunnel walls as obstacles
        const visibilityPolygon = this.computeVisibilityPolygon(
          playerMarker.position.x,
          playerMarker.position.y,
          visionRangePx,
          tunnel.walls
        );
        
        if (visibilityPolygon.length < 3) {
          console.log('[Tunnel Vision] Failed to compute visibility polygon');
          return [];
        }
        
        // Now determine which path segments are visible by checking if path points are inside visibility polygon
        const visibleSegments: Array<Array<{x: number, y: number}>> = [];
        let currentSegment: Array<{x: number, y: number}> | null = null;
        
        for (let i = 0; i < tunnel.path.length; i++) {
          const pathPoint = tunnel.path[i];
          if (!pathPoint) continue;
          
          const isVisible = this.pointInPolygon(pathPoint.x, pathPoint.y, visibilityPolygon);
          
          if (isVisible) {
            if (!currentSegment) {
              currentSegment = [];
              // If not the first point, include the previous point for continuity
              if (i > 0 && tunnel.path[i - 1]) {
                currentSegment.push(tunnel.path[i - 1]);
              }
            }
            currentSegment.push(pathPoint);
          } else {
            // Point not visible - end current segment
            if (currentSegment && currentSegment.length >= 2) {
              // Include this point for continuity (edge of visibility)
              currentSegment.push(pathPoint);
              visibleSegments.push(currentSegment);
              currentSegment = null;
            } else {
              currentSegment = null;
            }
          }
        }
        
        // Add final segment if exists
        if (currentSegment && currentSegment.length >= 2) {
          visibleSegments.push(currentSegment);
        }
        
        console.log('[Tunnel Vision Debug RAYCASTING]', {
          tunnelId: tunnel.id,
          playerPos: { x: playerMarker.position.x.toFixed(1), y: playerMarker.position.y.toFixed(1) },
          visionRange: visionRangePx.toFixed(1),
          wallCount: tunnel.walls.length,
          pathPointCount: tunnel.path.length,
          visibleSegmentCount: visibleSegments.length,
          totalVisiblePoints: visibleSegments.reduce((sum, seg) => sum + seg.length, 0)
        });
        
        return visibleSegments;
      };
      
      // Find tunnels that should be visible to players
      const visibleTunnelSegments = new Map<string, Array<Array<{x: number, y: number}>>>();
      
      // Build a map of tunnel ID -> player marker for tunnels that need visibility calculation
      // This ensures we only calculate ONCE per tunnel, using the first player's vision
      const tunnelPlayerMap = new Map<string, any>();
      
      config.tunnels.forEach((tunnel: any) => {
        // Find the first player token that's in this tunnel or created it
        const playerInTunnel = playerTokens.find((playerMarker: any) => {
          const isInTunnel = playerMarker.tunnelState?.tunnelId === tunnel.id;
          const isCreator = tunnel.creatorMarkerId === playerMarker.id;
          return isInTunnel || isCreator;
        });
        
        if (playerInTunnel) {
          tunnelPlayerMap.set(tunnel.id, playerInTunnel);
        }
      });
      
      // Now calculate segments ONCE per tunnel
      tunnelPlayerMap.forEach((playerMarker: any, tunnelId: string) => {
        const tunnel = config.tunnels.find((t: any) => t.id === tunnelId);
        if (!tunnel) return;
        
        const segments = getVisiblePathSegments(tunnel, playerMarker);
        console.log('[Tunnel Vision Debug] Calculated segments for tunnel:', {
          tunnelId: tunnel.id,
          playerMarkerId: playerMarker.id,
          segmentCount: segments.length,
          totalSegmentPoints: segments.reduce((sum, seg) => sum + seg.length, 0)
        });
        
        if (segments.length > 0) {
          visibleTunnelSegments.set(tunnel.id, segments);
        }
      });
      
      // Draw paths for visible tunnel segments
      config.tunnels.forEach((tunnel: any) => {
        const segments = visibleTunnelSegments.get(tunnel.id);
        if (!segments || segments.length === 0) return;
        
        const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
        const tunnelWidth = tunnel.tunnelWidth || (squares + 0.5) * config.gridSize;
        
        // Draw each visible segment
        segments.forEach((segment: Array<{x: number, y: number}>, segIdx: number) => {
          if (segment.length < 2 || !segment[0]) return;
          
          console.log('[Tunnel Debug DRAW]', {
            tunnelId: tunnel.id,
            segmentIndex: segIdx,
            segmentPointCount: segment.length,
            firstPoint: segment[0],
            lastPoint: segment[segment.length - 1]
          });
          
          ctx.save();
          ctx.globalAlpha = 0.3;
          ctx.strokeStyle = '#2a2a2a';
          ctx.lineWidth = tunnelWidth;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Draw tunnel path
          ctx.beginPath();
          ctx.moveTo(segment[0].x, segment[0].y);
          for (let i = 1; i < segment.length; i++) {
            const point = segment[i];
            if (point) ctx.lineTo(point.x, point.y);
          }
          ctx.stroke();
          
          // Draw border
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = tunnelWidth + 4;
          ctx.beginPath();
          ctx.moveTo(segment[0].x, segment[0].y);
          for (let i = 1; i < segment.length; i++) {
            const point = segment[i];
            if (point) ctx.lineTo(point.x, point.y);
          }
          ctx.stroke();
          
          // Draw inner path
          ctx.globalAlpha = 0.6;
          ctx.strokeStyle = '#1a1a1a';
          ctx.lineWidth = tunnelWidth * 0.7;
          ctx.beginPath();
          ctx.moveTo(segment[0].x, segment[0].y);
          for (let i = 1; i < segment.length; i++) {
            const point = segment[i];
            if (point) ctx.lineTo(point.x, point.y);
          }
          ctx.stroke();
          
          ctx.restore();
        });
        
        console.log('[Tunnel Debug Player Render] Drew tunnel path with vision restrictions, tunnel:', tunnel.id, 'segments:', segments.length);
      });
    }

    // Calculate pixelsPerFoot for vision range calculations
    const pixelsPerFootForVision = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;

    // Draw non-player markers (these will be obscured by fog)
    // Filter out burrowed tokens unless they're marked as visible to players OR visible to a player in the same tunnel
    console.log('[Other Markers Debug] Processing otherMarkers:', {
      count: otherMarkers.length,
      markers: otherMarkers.map((m: any) => ({
        id: m.id,
        hasBurrowing: !!m.elevation?.isBurrowing,
        visibleToPlayers: m.visibleToPlayers,
        hasTunnelState: !!m.tunnelState,
        tunnelId: m.tunnelState?.tunnelId
      }))
    });
    
    otherMarkers.forEach((m: any) => {
      // Check if burrowed token OR token in tunnel should be visible
      // Tokens can be in tunnels either by burrowing (isBurrowing=true) or by entering (tunnelState set)
      if ((m.elevation?.isBurrowing || m.tunnelState) && !m.visibleToPlayers) {
        console.log('[Burrowed Token Visibility] Checking token:', {
          id: m.id,
          isBurrowing: !!m.elevation?.isBurrowing,
          hasTunnelState: !!m.tunnelState,
          tunnelId: m.tunnelState?.tunnelId,
          pathIndex: m.tunnelState?.pathIndex,
          position: m.position
        });
        
        // Check if any player token that is underground (in tunnel or burrowing) can see this burrowed token
        let visibleToPlayerInTunnel = false;
        
        // Helper to calculate vision range for a player
        const getVisionRange = (marker: any): number => {
          let visionRange = 0;
          if (marker.darkvision && marker.darkvision > 0) {
            visionRange = Math.max(visionRange, marker.darkvision);
          }
          
          // Check for light as nested object or direct properties
          let lightBright = 0;
          let lightDim = 0;
          if (marker.light) {
            lightBright = marker.light.bright || 0;
            lightDim = marker.light.dim || 0;
          } else if (marker.lightBright !== undefined || marker.lightDim !== undefined) {
            lightBright = marker.lightBright || 0;
            lightDim = marker.lightDim || 0;
          }
          
          if (lightBright > 0 || lightDim > 0) {
            const totalLightRange = lightBright + lightDim;
            visionRange = Math.max(visionRange, totalLightRange);
          }
          
          const visionRangePx = visionRange * pixelsPerFootForVision;
          console.log('[Vision Range Calc]:', {
            markerId: marker.id,
            darkvision: marker.darkvision,
            lightBright,
            lightDim,
            visionRangeFeet: visionRange,
            visionRangePx: visionRangePx.toFixed(2),
            pixelsPerFootForVision
          });
          
          return visionRangePx;
        };
        
        if (playerTokens.length > 0) {
          // Case 1: Burrowed token is in an explicit tunnel with a player
          if (m.tunnelState && config.tunnels) {
            const tunnel = config.tunnels.find((t: any) => t.id === m.tunnelState.tunnelId);
            
            console.log('[Burrowed Token Visibility] Token in explicit tunnel:', !!tunnel, 'Player tokens:', playerTokens.length);
            
            if (tunnel && tunnel.path) {
            // Check each player token in the same tunnel
            for (const playerMarker of playerTokens) {
              console.log('[Burrowed Token Visibility] Checking player:', {
                playerId: playerMarker.id,
                playerTunnelId: playerMarker.tunnelState?.tunnelId,
                playerPathIdx: playerMarker.tunnelState?.pathIndex,
                sameTunnel: playerMarker.tunnelState?.tunnelId === m.tunnelState.tunnelId
              });
              
              if (playerMarker.tunnelState?.tunnelId === m.tunnelState.tunnelId) {
                // Both tokens are in the same tunnel - use raycasting with tunnel walls
                const visionRangePx = getVisionRange(playerMarker);
                console.log('[Burrowed Token Visibility] Player vision range:', visionRangePx);
                
                if (visionRangePx > 0) {
                  // Calculate 3D distance (accounting for elevation/depth differences)
                  const directDx = m.position.x - playerMarker.position.x;
                  const directDy = m.position.y - playerMarker.position.y;
                  const horizontalDistSq = directDx * directDx + directDy * directDy;
                  
                  // Include elevation difference in distance calculation
                  const mElev = (m.elevation?.height || 0) - (m.elevation?.depth || 0);
                  const pElev = (playerMarker.elevation?.height || 0) - (playerMarker.elevation?.depth || 0);
                  const verticalFeet = Math.abs(mElev - pElev);
                  const verticalPx = verticalFeet * pixelsPerFootForVision;
                  
                  const directDistance = Math.sqrt(horizontalDistSq + verticalPx * verticalPx);
                  
                  // Check if within vision range (3D distance)
                  if (directDistance <= visionRangePx) {
                    // Use raycasting to check if tunnel walls block line of sight
                    let isBlocked = false;
                    
                    if (tunnel.walls && tunnel.walls.length > 0) {
                      // Check if any tunnel wall intersects the line of sight
                      // EXCLUDE end caps (last 2 walls) when checking sight between tokens in same tunnel
                      // End caps are at entrance/exit and shouldn't block intra-tunnel vision
                      const sideWalls = tunnel.walls.length > 2 ? tunnel.walls.slice(0, -2) : tunnel.walls;
                      isBlocked = !this.hasLineOfSight(
                        playerMarker.position.x,
                        playerMarker.position.y,
                        m.position.x,
                        m.position.y,
                        sideWalls
                      );
                    }
                    
                    console.log('[Burrowed Token Visibility] Raycasting check:', {
                      directDistance: directDistance.toFixed(2),
                      visionRange: visionRangePx.toFixed(2),
                      hasWalls: tunnel.walls && tunnel.walls.length > 0,
                      totalWallCount: tunnel.walls?.length || 0,
                      sideWallCount: tunnel.walls && tunnel.walls.length > 2 ? tunnel.walls.length - 2 : tunnel.walls?.length || 0,
                      wallsBlockSight: isBlocked,
                      visible: !isBlocked,
                      playerPos: { x: playerMarker.position.x, y: playerMarker.position.y },
                      tokenPos: { x: m.position.x, y: m.position.y }
                    });
                    
                    if (!isBlocked) {
                      visibleToPlayerInTunnel = true;
                      console.log('[Burrowed Token Visibility] TOKEN VISIBLE (same tunnel, raycasting line of sight)!');
                      break;
                    }
                  }
                }
              }
            }
          }
          }
          
          // Case 2: Burrowed token is NOT in an explicit tunnel - check tunnel path-based visibility
          // If a player is in a tunnel, check path distance along that tunnel to the burrowing token
          if (!visibleToPlayerInTunnel && !m.tunnelState) {
            console.log('[Burrowed Token Visibility] Token NOT in explicit tunnel - checking tunnel path-based visibility');
            
            for (const playerMarker of playerTokens) {
              // Check if player is in a tunnel
              const playerTunnelId = playerMarker.tunnelState?.tunnelId;
              
              console.log('[Burrowed Token Visibility] Checking player (tunnel-based):', {
                playerId: playerMarker.id,
                playerTunnelId,
                playerPathIdx: playerMarker.tunnelState?.pathIndex,
                playerBurrowing: playerMarker.elevation?.isBurrowing
              });
              
              if (playerTunnelId && config.tunnels) {
                // Player is in a tunnel - find the tunnel and check path distance
                const tunnel = config.tunnels.find((t: any) => t.id === playerTunnelId);
                
                if (tunnel && tunnel.path && tunnel.path.length > 0) {
                  const visionRangePx = getVisionRange(playerMarker);
                  
                  if (visionRangePx > 0) {
                    const playerPathIdx = playerMarker.tunnelState.pathIndex || 0;
                    
                    // Calculate direct distance for logging, but DO NOT use it to bypass corner checks
                    const directDx = m.position.x - playerMarker.position.x;
                    const directDy = m.position.y - playerMarker.position.y;
                    const directDistance = Math.sqrt(directDx * directDx + directDy * directDy);
                    
                    console.log('[Burrowed Token Visibility] Direct distance (for reference only):', {
                      directDistance: directDistance.toFixed(2),
                      visionRange: visionRangePx.toFixed(2)
                    });
                    
                    // NOTE: We do NOT use direct distance to determine visibility in tunnels
                    // because there may be corners between the player and the burrowed token.
                    // Instead, we always use path-based distance with corner detection.
                    
                    // For the burrowing token that owns/created this tunnel, it's at the dig head (end of path)
                    // Check if the burrowing token is close to the last point of the tunnel
                    const lastPathPoint = tunnel.path[tunnel.path.length - 1];
                    const distToEnd = Math.sqrt(
                      Math.pow(lastPathPoint.x - m.position.x, 2) + 
                      Math.pow(lastPathPoint.y - m.position.y, 2)
                    );
                    
                    // If the burrowing token is within 50px of the tunnel end, assume it's the owner at dig head
                    const isAtDigHead = distToEnd < 50;
                    const burrowingPathIdx = isAtDigHead ? tunnel.path.length - 1 : (() => {
                      // Find closest point on tunnel path to the burrowing token
                      let closestPathIdx = 0;
                      let closestDist = Infinity;
                      for (let i = 0; i < tunnel.path.length; i++) {
                        const dx = tunnel.path[i].x - m.position.x;
                        const dy = tunnel.path[i].y - m.position.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < closestDist) {
                          closestDist = dist;
                          closestPathIdx = i;
                        }
                      }
                      return closestPathIdx;
                    })();
                    
                    console.log('[Burrowed Token Visibility] Burrowing token path position:', {
                      isAtDigHead,
                      distToEnd: distToEnd.toFixed(2),
                      burrowingPathIdx,
                      playerPathIdx,
                      tunnelLength: tunnel.path.length
                    });
                    
                    // Check path distance between player and burrower with corner detection
                    // This works for both cases: player ahead of or behind the burrowing token
                    let pathDistance = 0;
                    let cornerBlocked = false;
                    let lastDirection: { dx: number, dy: number } | null = null;
                    
                    const startIdx = Math.min(playerPathIdx, burrowingPathIdx);
                    const endIdx = Math.max(playerPathIdx, burrowingPathIdx);
                    
                    for (let i = startIdx; i < endIdx; i++) {
                      if (i + 1 < tunnel.path.length) {
                        const dx = tunnel.path[i + 1].x - tunnel.path[i].x;
                        const dy = tunnel.path[i + 1].y - tunnel.path[i].y;
                        const segmentDist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check for corner blocking vision (45¬∞ threshold)
                        if (lastDirection && segmentDist > 1) {
                          const prevLen = Math.sqrt(lastDirection.dx * lastDirection.dx + lastDirection.dy * lastDirection.dy);
                          const currLen = segmentDist;
                          if (prevLen > 0 && currLen > 0) {
                            const dotProduct = (lastDirection.dx * dx + lastDirection.dy * dy) / (prevLen * currLen);
                            const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
                            if (angle > Math.PI / 4) { // 45¬∞ threshold
                              cornerBlocked = true;
                              console.log('[Burrowed Token Visibility] Corner blocked at index:', i, 'angle:', (angle * 180 / Math.PI).toFixed(1) + '¬∞');
                              break;
                            }
                          }
                        }
                        
                        pathDistance += segmentDist;
                        lastDirection = { dx, dy };
                      }
                    }
                    
                    console.log('[Burrowed Token Visibility] Path distance check:', {
                      pathDistance: pathDistance.toFixed(2),
                      visionRange: visionRangePx.toFixed(2),
                      cornerBlocked,
                      directDistance: directDistance.toFixed(2),
                      visible: !cornerBlocked && directDistance <= visionRangePx
                    });
                    
                    // If no corner blocks vision, use DIRECT distance for visibility
                    // (path distance is only used for corner detection, not range)
                    if (!cornerBlocked && directDistance <= visionRangePx) {
                      visibleToPlayerInTunnel = true;
                      console.log('[Burrowed Token Visibility] TOKEN VISIBLE (direct line of sight, no corner)!');
                      break;
                    }
                  }
                }
              } else if (playerMarker.elevation?.isBurrowing) {
                // Player is burrowing (not in explicit tunnel) - use 3D distance
                const visionRangePx = getVisionRange(playerMarker);
                
                if (visionRangePx > 0) {
                  const dx = m.position.x - playerMarker.position.x;
                  const dy = m.position.y - playerMarker.position.y;
                  const horizontalDistSq = dx * dx + dy * dy;
                  
                  // Include elevation difference in distance calculation
                  const mElev = (m.elevation?.height || 0) - (m.elevation?.depth || 0);
                  const pElev = (playerMarker.elevation?.height || 0) - (playerMarker.elevation?.depth || 0);
                  const verticalFeet = Math.abs(mElev - pElev);
                  const verticalPx = verticalFeet * pixelsPerFootForVision;
                  
                  const distance = Math.sqrt(horizontalDistSq + verticalPx * verticalPx);
                  
                  console.log('[Burrowed Token Visibility] Position-based 3D distance check:', {
                    distance: distance.toFixed(2),
                    visionRange: visionRangePx.toFixed(2),
                    visible: distance <= visionRangePx
                  });
                  
                  if (distance <= visionRangePx) {
                    visibleToPlayerInTunnel = true;
                    console.log('[Burrowed Token Visibility] TOKEN VISIBLE (position-based)!');
                    break;
                  }
                }
              }
            }
          }
        }
        
        console.log('[Burrowed Token Visibility] Final decision:', {
          tokenId: m.id,
          visibleToPlayerInTunnel,
          willRender: visibleToPlayerInTunnel
        });
        
        // Update visibility flag for burrowed tokens - MUST set to false if not visible
        m._visibleToTunnelPlayer = visibleToPlayerInTunnel;
        
        // Always skip rendering burrowed tokens here - they'll be drawn on top of fog later if visible
        return;
      }
      // 3D elevation-aware visibility check for surface tokens (D&D 5e RAW)
      // A token flying at 80ft directly above a player with 60ft darkvision should NOT be visible
      // because the true 3D distance (80ft) exceeds the vision range (60ft)
      if (m.elevation && (m.elevation.height > 0 || m.elevation.depth > 0) && playerTokens.length > 0) {
        const tokenElev = (m.elevation.height || 0) - (m.elevation.depth || 0);
        const pixelsPerFootLocal = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
        
        let visibleToAnyPlayer = false;
        for (const playerMarker of playerTokens) {
          // Get this player's max vision range in feet
          let playerVisionFeet = 0;
          if (playerMarker.darkvision && playerMarker.darkvision > 0) {
            playerVisionFeet = Math.max(playerVisionFeet, playerMarker.darkvision);
          }
          if (playerMarker.light) {
            const totalLight = (playerMarker.light.bright || 0) + (playerMarker.light.dim || 0);
            playerVisionFeet = Math.max(playerVisionFeet, totalLight);
          }
          
          if (playerVisionFeet <= 0) continue;
          
          const playerElev = playerMarker.elevation ? ((playerMarker.elevation.height || 0) - (playerMarker.elevation.depth || 0)) : 0;
          const verticalFeet = Math.abs(tokenElev - playerElev);
          
          // If vertical distance alone exceeds vision range, this player can't see it
          if (verticalFeet > playerVisionFeet) continue;
          
          // Calculate 3D distance in feet
          const dx = m.position.x - playerMarker.position.x;
          const dy = m.position.y - playerMarker.position.y;
          const horizontalPx = Math.sqrt(dx * dx + dy * dy);
          const horizontalFeet = horizontalPx / pixelsPerFootLocal;
          const totalDistFeet = Math.sqrt(horizontalFeet * horizontalFeet + verticalFeet * verticalFeet);
          
          if (totalDistFeet <= playerVisionFeet) {
            visibleToAnyPlayer = true;
            break;
          }
        }
        
        if (!visibleToAnyPlayer) {
          console.log('[3D Vision] Token hidden due to elevation - 3D distance exceeds vision range:', {
            tokenId: m.id,
            tokenElevation: tokenElev,
            position: m.position
          });
          return; // Skip rendering this token
        }
      }
      
      this.drawMarker(ctx, m);
    });

    // Draw drag ruler (distance indicator) if a marker is being moved
    if (config.dragRuler) {
      this.drawDragRuler(ctx, config);
    }

    // Draw Fog of War (Player view: fully opaque black with light source revelation)
    // Fog must be enabled for darkness to appear - lights reveal areas within the fog
    console.log('[PV] Fog draw check:', { fogOfWar: !!config.fogOfWar, enabled: config.fogOfWar?.enabled, lightSources: config.lightSources?.length || 0 });
    if (config.fogOfWar && config.fogOfWar.enabled) {
      console.log('[PV] Drawing fog of war with lights');
      this.drawFogOfWar(ctx, this.canvas!.width, this.canvas!.height, config);
    }

    // Redraw tunnel paths ON TOP of fog for underground players
    // This allows them to see the tunnel while surface is covered in fog
    if (config.tunnels && config.tunnels.length > 0 && tunnelPlayersInMarkers.length > 0) {
      const CREATURE_SIZE_SQUARES: Record<string, number> = {
        'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
      };
      const pixelsPerFootTunnel = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
      
      for (const tunnel of config.tunnels) {
        if (!tunnel.visible || !tunnel.active || !tunnel.path || tunnel.path.length < 2) continue;
        
        // Check if any tunnel player is in this tunnel
        const playersInThisTunnel = tunnelPlayersInMarkers.filter((p: any) => 
          p.tunnelState?.tunnelId === tunnel.id
        );
        
        if (playersInThisTunnel.length === 0) continue;
        
        // Use stored tunnel width or calculate based on creature size
        const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
        const tunnelWidth = tunnel.tunnelWidth || (squares + 0.5) * config.gridSize;
        
        for (const playerMarker of playersInThisTunnel) {
          const pathIdx = playerMarker.tunnelState?.pathIndex || 0;
          
          // Calculate vision range
          let visionRange = 0;
          if (playerMarker.darkvision && playerMarker.darkvision > 0) {
            visionRange = Math.max(visionRange, playerMarker.darkvision);
          }
          if (playerMarker.lightBright !== undefined) {
            const totalLight = (playerMarker.lightBright || 0) + (playerMarker.lightDim || 0);
            visionRange = Math.max(visionRange, totalLight);
          }
          const visionRangePx = visionRange * pixelsPerFootTunnel;
          
          // Draw the visible portion of tunnel
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Draw background (dirt) - more transparent
          ctx.globalAlpha = 0.4;
          ctx.strokeStyle = '#3d2817';
          ctx.lineWidth = tunnelWidth + 8;
          ctx.beginPath();
          
          // Collect points within vision (forward and backward from player position)
          const visiblePoints: { x: number, y: number }[] = [];
          
          // Go backward from player position
          let backwardDist = 0;
          let lastDir: { dx: number, dy: number } | null = null;
          for (let i = pathIdx; i >= 0 && backwardDist < visionRangePx; i--) {
            if (i < tunnel.path.length) {
              if (i > 0) {
                const dx = tunnel.path[i].x - tunnel.path[i-1].x;
                const dy = tunnel.path[i].y - tunnel.path[i-1].y;
                const segDist = Math.sqrt(dx*dx + dy*dy);
                
                if (lastDir && segDist > 1) {
                  const prevLen = Math.sqrt(lastDir.dx*lastDir.dx + lastDir.dy*lastDir.dy);
                  const dot = (lastDir.dx*dx + lastDir.dy*dy) / (prevLen * segDist);
                  const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
                  if (angle > Math.PI / 4) break; // Corner blocks (45¬∞)
                }
                backwardDist += segDist;
                lastDir = { dx, dy };
              }
              visiblePoints.unshift(tunnel.path[i]);
            }
          }
          
          // Go forward from player position
          let forwardDist = 0;
          lastDir = null;
          for (let i = pathIdx + 1; i < tunnel.path.length && forwardDist < visionRangePx; i++) {
            const dx = tunnel.path[i].x - tunnel.path[i-1].x;
            const dy = tunnel.path[i].y - tunnel.path[i-1].y;
            const segDist = Math.sqrt(dx*dx + dy*dy);
            
            if (lastDir && segDist > 1) {
              const prevLen = Math.sqrt(lastDir.dx*lastDir.dx + lastDir.dy*lastDir.dy);
              const dot = (lastDir.dx*dx + lastDir.dy*dy) / (prevLen * segDist);
              const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
              if (angle > Math.PI / 4) break; // Corner blocks (45¬∞)
            }
            forwardDist += segDist;
            lastDir = { dx, dy };
            visiblePoints.push(tunnel.path[i]);
          }
          
          // Draw the visible path
          if (visiblePoints.length >= 2 && visiblePoints[0] && visiblePoints[1]) {
            ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
            for (let i = 1; i < visiblePoints.length; i++) {
              const pt = visiblePoints[i];
              if (pt) ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            
            // Draw border
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = tunnelWidth + 4;
            ctx.beginPath();
            ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
            for (let i = 1; i < visiblePoints.length; i++) {
              const pt = visiblePoints[i];
              if (pt) ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            
            // Draw inner path
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = tunnelWidth * 0.7;
            ctx.beginPath();
            ctx.moveTo(visiblePoints[0].x, visiblePoints[0].y);
            for (let i = 1; i < visiblePoints.length; i++) {
              const pt = visiblePoints[i];
              if (pt) ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }
    }

    // Draw player tokens on top of fog - they should always be visible
    // Separate tunnel players to draw them on top of tunnel paths
    const tunnelPlayerTokens = playerTokens.filter((m: any) => m.tunnelState);
    const surfacePlayerTokens = playerTokens.filter((m: any) => !m.tunnelState);
    
    // Draw surface players first
    surfacePlayerTokens.forEach((m: any) => this.drawMarker(ctx, m));
    
    // Draw tunnel players on top (after tunnel paths are rendered)
    tunnelPlayerTokens.forEach((m: any) => {
      ctx.save();
      ctx.globalAlpha = 0.85; // Mostly visible but slightly transparent to show underground
      this.drawMarker(ctx, m);
      ctx.restore();
    });

    // Draw visible burrowed tokens on top of fog (they were marked visible earlier)
    // These are creature/NPC tokens that were determined visible to tunnel players
    // Includes both burrowing tokens (isBurrowing) and tokens that entered tunnels (tunnelState)
    otherMarkers.forEach((m: any) => {
      if ((m.elevation?.isBurrowing || m.tunnelState) && m._visibleToTunnelPlayer) {
        ctx.save();
        ctx.globalAlpha = 0.5; // Semi-transparent to show underground
        this.drawMarker(ctx, m);
        ctx.restore();
      }
    });

    // Draw auras on top of fog (for all player layer markers)
    const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
    playerMarkers.forEach((marker: any) => {
      if (marker.auras && marker.auras.length > 0) {
        marker.auras.forEach((aura: any) => {
          const radiusPx = (aura.radius || 0) * pixelsPerFoot;
          if (radiusPx > 0) {
            ctx.globalAlpha = aura.opacity || 0.25;
            ctx.fillStyle = aura.color || '#ffcc00';
            ctx.beginPath();
            ctx.arc(marker.position.x, marker.position.y, radiusPx, 0, Math.PI * 2);
            ctx.fill();
            // Draw aura border
            ctx.globalAlpha = Math.min((aura.opacity || 0.25) + 0.3, 0.8);
            ctx.strokeStyle = aura.color || '#ffcc00';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
          }
        });
      }
    });

    // Draw AoE effects on top of fog (Player layer only)
    const playerAoeEffects = (config.aoeEffects || []).filter((a: any) => (a.layer || 'Player') === 'Player');
    playerAoeEffects.forEach((aoe: any) => this.drawAoeEffect(ctx, aoe, config));

    // Draw measure ruler if active
    if (config.measureRuler) {
      this.drawMeasureRuler(ctx, config);
    }

    // Draw target distance ruler if active
    if (config.targetDistRuler) {
      this.drawTargetDistanceRuler(ctx, config);
    }
  }

  private drawGrid(ctx: CanvasRenderingContext2D, config: any) {
    const w = this.canvas!.width;
    const h = this.canvas!.height;
    const offsetX = config.gridOffsetX || 0;
    const offsetY = config.gridOffsetY || 0;

    ctx.save();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.lineWidth = 2;

    if (config.gridType === 'square') {
      const size = config.gridSize;
      const normalizedOffsetX = ((offsetX % size) + size) % size;
      const normalizedOffsetY = ((offsetY % size) + size) % size;

      for (let x = normalizedOffsetX; x <= w; x += size) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      for (let y = normalizedOffsetY; y <= h; y += size) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
    } else if (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') {
      const gridSize = config.gridSize;
      
      if (config.gridType === 'hex-horizontal') {
        const horiz = gridSize;
        const size = (2 / 3) * horiz;
        const vert = Math.sqrt(3) * size;

        const startCol = Math.floor(-offsetX / horiz) - 2;
        const endCol = Math.ceil((w - offsetX) / horiz) + 2;
        const startRow = Math.floor(-offsetY / vert) - 2;
        const endRow = Math.ceil((h - offsetY) / vert) + 2;

        for (let row = startRow; row < endRow; row++) {
          for (let col = startCol; col < endCol; col++) {
            const colOffsetY = (col & 1) ? vert / 2 : 0;
            const centerX = col * horiz + offsetX;
            const centerY = row * vert + colOffsetY + offsetY;
            this.drawHexFlatOutline(ctx, centerX, centerY, size);
          }
        }
      } else if (config.gridType === 'hex-vertical') {
        const vert = gridSize;
        const size = (2 / 3) * vert;
        const horiz = Math.sqrt(3) * size;

        const startCol = Math.floor(-offsetX / horiz) - 2;
        const endCol = Math.ceil((w - offsetX) / horiz) + 2;
        const startRow = Math.floor(-offsetY / vert) - 2;
        const endRow = Math.ceil((h - offsetY) / vert) + 2;

        for (let row = startRow; row < endRow; row++) {
          for (let col = startCol; col < endCol; col++) {
            const rowOffsetX = (row & 1) ? horiz / 2 : 0;
            const centerX = col * horiz + rowOffsetX + offsetX;
            const centerY = row * vert + offsetY;
            this.drawHexPointyOutline(ctx, centerX, centerY, size);
          }
        }
      }
    }

    ctx.restore();
  }

  private drawHexFlatOutline(ctx: CanvasRenderingContext2D, cx: number, cy: number, size: number) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i;
      const x = cx + size * Math.cos(angle);
      const y = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  private drawHexPointyOutline(ctx: CanvasRenderingContext2D, cx: number, cy: number, size: number) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 6) + (Math.PI / 3) * i;
      const x = cx + size * Math.cos(angle);
      const y = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // ‚îÄ‚îÄ Hexcrawl helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /** Calculate effective grid size (fixed single grid ‚Äî no pace scaling). */
  private getPlayerEffectiveGridSize(config: any): number {
    return config.gridSize;
  }

  /** Convert hex col/row ‚Üí pixel centre, matching the GM coordinate system. */
  private hexToPixel(col: number, row: number, config: any): { x: number; y: number } {
    const ox = config.gridOffsetX || 0;
    const oy = config.gridOffsetY || 0;
    const effectiveSize = this.getPlayerEffectiveGridSize(config);

    if (config.gridType === 'hex-horizontal') {
      const horiz = effectiveSize;
      const size = (2 / 3) * horiz;
      const vert = Math.sqrt(3) * size;
      const colOffsetY = (col & 1) ? vert / 2 : 0;
      return { x: col * horiz + ox, y: row * vert + colOffsetY + oy };
    } else {
      // hex-vertical
      const vert = effectiveSize;
      const size = (2 / 3) * vert;
      const horiz = Math.sqrt(3) * size;
      const rowOffsetX = (row & 1) ? horiz / 2 : 0;
      return { x: col * horiz + rowOffsetX + ox, y: row * vert + oy };
    }
  }

  /**
   * Hex distance for offset-coordinate grids (cube coordinate conversion).
   */
  private hexDistance(c1: number, r1: number, c2: number, r2: number, gridType: string): number {
    if (gridType === 'hex-horizontal') {
      const x1 = c1, z1 = r1 - (c1 - (c1 & 1)) / 2, y1 = -x1 - z1;
      const x2 = c2, z2 = r2 - (c2 - (c2 & 1)) / 2, y2 = -x2 - z2;
      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
    } else {
      const x1 = c1 - (r1 - (r1 & 1)) / 2, z1 = r1, y1 = -x1 - z1;
      const x2 = c2 - (r2 - (r2 & 1)) / 2, z2 = r2, y2 = -x2 - z2;
      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
    }
  }

  /**
   * Render the full hexcrawl layer: terrain fills, climate borders,
   * visited-hex trail, and the pulsing party position marker.
   */
  private drawHexcrawlLayer(ctx: CanvasRenderingContext2D, config: any) {
    const effectiveGridSz = this.getPlayerEffectiveGridSize(config);

    // NOTE: Terrain fills and climate borders are intentionally omitted from
    // the player view ‚Äî players only see the map image, the visited trail,
    // and their current party location.

    // ‚îÄ‚îÄ 1. Visited-hex trail ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const hcState = config.hexcrawlState;
    if (hcState && hcState.visitedHexes && hcState.visitedHexes.length > 1) {
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = '#c8a85c';
      ctx.lineWidth = Math.max(3, effectiveGridSz * 0.06);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.setLineDash([effectiveGridSz * 0.10, effectiveGridSz * 0.08]);

      ctx.beginPath();
      const first = this.hexToPixel(hcState.visitedHexes[0].col, hcState.visitedHexes[0].row, config);
      ctx.moveTo(first.x, first.y);
      for (let i = 1; i < hcState.visitedHexes.length; i++) {
        const pt = this.hexToPixel(hcState.visitedHexes[i].col, hcState.visitedHexes[i].row, config);
        ctx.lineTo(pt.x, pt.y);
      }
      ctx.stroke();

      // Draw small dots at each visited hex center
      ctx.setLineDash([]);
      ctx.fillStyle = '#c8a85c';
      hcState.visitedHexes.forEach((vh: any) => {
        const pt = this.hexToPixel(vh.col, vh.row, config);
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, Math.max(3, effectiveGridSz * 0.04), 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }

    // ‚îÄ‚îÄ 4. Party position marker (pulsing campfire icon) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (hcState && hcState.enabled && hcState.partyPosition) {
      const pp = this.hexToPixel(hcState.partyPosition.col, hcState.partyPosition.row, config);
      const hexSize = (2 / 3) * effectiveGridSz;
      const iconRadius = hexSize * 0.65;

      // Outer glow ring (large, warm pulse)
      ctx.save();
      ctx.globalAlpha = 1.0;
      const glow = ctx.createRadialGradient(pp.x, pp.y, iconRadius * 0.3, pp.x, pp.y, iconRadius * 1.6);
      glow.addColorStop(0, 'rgba(255, 180, 50, 0.7)');
      glow.addColorStop(0.6, 'rgba(255, 140, 30, 0.3)');
      glow.addColorStop(1, 'rgba(255, 180, 50, 0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(pp.x, pp.y, iconRadius * 1.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Solid circle background
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = 'rgba(40, 30, 15, 0.95)';
      ctx.beginPath();
      ctx.arc(pp.x, pp.y, iconRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#c8a85c';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();

      // Campfire emoji (large)
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.font = `${Math.round(iconRadius * 1.4)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üèïÔ∏è', pp.x, pp.y);
      ctx.restore();
    }

    // ‚îÄ‚îÄ 5. Travel range overlay (synced from GM hexcrawl-move tool) ‚îÄ
    const overlay = config.hexcrawlRangeOverlay;
    if (overlay && overlay.active && hcState && hcState.enabled && hcState.partyPosition &&
        (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical')) {
      const partyPos = hcState.partyPosition;
      const tracker = new HexcrawlTracker(hcState, config.hexTerrains || [], config.hexClimates || []);
      const remaining = tracker.getRemainingMovement();
      const hexSize = (2 / 3) * effectiveGridSz;

      // Green fill for adjacent affordable hexes (travel is one hex at a time)
      ctx.save();
      for (let dc = -1; dc <= 1; dc++) {
        for (let dr = -1; dr <= 1; dr++) {
          const c = partyPos.col + dc;
          const r = partyPos.row + dr;
          if (c < 0 || r < 0) continue;
          if (c === partyPos.col && r === partyPos.row) continue;
          const dist = this.hexDistance(partyPos.col, partyPos.row, c, r, config.gridType);
          if (dist !== 1) continue;
          const hexCost = tracker.getMovementCostForHex(c, r);
          if (hexCost <= remaining) {
            const center = this.hexToPixel(c, r, config);
            ctx.fillStyle = 'rgba(0, 200, 80, 0.18)';
            ctx.strokeStyle = 'rgba(0, 200, 80, 0.35)';
            ctx.lineWidth = 1.5;
            if (config.gridType === 'hex-horizontal') {
              this.drawFilledHexFlat(ctx, center.x, center.y, hexSize);
            } else {
              this.drawFilledHexPointy(ctx, center.x, center.y, hexSize);
            }
          }
        }
      }
      ctx.restore();

      // Hover highlight: green if adjacent + affordable, red if not
      const hoverHex = overlay.hoverHex;
      if (hoverHex && !(hoverHex.col === partyPos.col && hoverHex.row === partyPos.row)) {
        const dist = this.hexDistance(partyPos.col, partyPos.row, hoverHex.col, hoverHex.row, config.gridType);
        const hexCost = tracker.getMovementCostForHex(hoverHex.col, hoverHex.row);
        const canMove = dist === 1 && hexCost <= remaining;
        const center = this.hexToPixel(hoverHex.col, hoverHex.row, config);
        ctx.save();
        ctx.fillStyle = canMove ? 'rgba(0, 220, 80, 0.38)' : 'rgba(220, 40, 30, 0.35)';
        ctx.strokeStyle = canMove ? 'rgba(0, 220, 80, 0.7)' : 'rgba(220, 40, 30, 0.65)';
        ctx.lineWidth = 2.5;
        if (config.gridType === 'hex-horizontal') {
          this.drawFilledHexFlat(ctx, center.x, center.y, hexSize);
        } else {
          this.drawFilledHexPointy(ctx, center.x, center.y, hexSize);
        }
        ctx.restore();
      }
    }
  }

  // ‚îÄ‚îÄ Hexcrawl travel animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /** Currently running travel animation frame id (for cancellation). */
  private _hexTravelAnimFrame: number = 0;

  /**
   * Animate the party marker moving from one hex to another.
   * Uses requestAnimationFrame for a smooth ~1.5 s transition, then redraws
   * the static scene at the end.
   */
  private animateHexcrawlTravel(fromCol: number, fromRow: number, toCol: number, toRow: number) {
    if (!this.canvas || !this.mapConfig) return;
    const config = this.mapConfig;
    const effectiveGridSz = this.getPlayerEffectiveGridSize(config);
    const hexSize = (2 / 3) * effectiveGridSz;
    const from = this.hexToPixel(fromCol, fromRow, config);
    const to = this.hexToPixel(toCol, toRow, config);
    const duration = 1400; // ms
    const startTime = performance.now();

    // Cancel any running animation
    if (this._hexTravelAnimFrame) cancelAnimationFrame(this._hexTravelAnimFrame);

    const animFrame = (now: number) => {
      const t = Math.min((now - startTime) / duration, 1);
      // Ease-in-out cubic
      const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      // Full redraw (static scene without the old party marker at destination)
      this.redrawAnnotations();
      const ctx = this.canvas?.getContext('2d');
      if (!ctx) return;

      const cx = from.x + (to.x - from.x) * ease;
      const cy = from.y + (to.y - from.y) * ease;
      const iconRadius = hexSize * 0.38;

      // Animated marker glow
      ctx.save();
      const glow = ctx.createRadialGradient(cx, cy, iconRadius * 0.3, cx, cy, iconRadius * 1.8);
      glow.addColorStop(0, `rgba(255, 200, 60, ${0.6 - 0.2 * ease})`);
      glow.addColorStop(1, 'rgba(255, 200, 60, 0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(cx, cy, iconRadius * 1.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Animated circle
      ctx.save();
      ctx.fillStyle = 'rgba(40, 30, 15, 0.85)';
      ctx.beginPath();
      ctx.arc(cx, cy, iconRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f0c050';
      ctx.lineWidth = 2.5;
      ctx.stroke();
      ctx.restore();

      // Moving icon
      ctx.save();
      ctx.font = `${Math.round(iconRadius * 1.3)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üß≠', cx, cy);
      ctx.restore();

      // Trail line behind the moving marker
      ctx.save();
      ctx.globalAlpha = 0.4 * (1 - ease * 0.5);
      ctx.strokeStyle = '#f0c050';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(cx, cy);
      ctx.stroke();
      ctx.restore();

      if (t < 1) {
        this._hexTravelAnimFrame = requestAnimationFrame(animFrame);
      } else {
        this._hexTravelAnimFrame = 0;
        // Final static redraw at destination
        this.redrawAnnotations();
      }
    };

    this._hexTravelAnimFrame = requestAnimationFrame(animFrame);
  }

  private drawMeasureRuler(ctx: CanvasRenderingContext2D, config: any) {
    if (!config.measureRuler) return;

    const { start, end } = config.measureRuler;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Calculate distance in grid units (feet)
    const gridSize = config.gridSize || 70;
    const scale = config.scale?.value || 5;
    const distanceInFeet = (distance / gridSize) * scale;

    // Draw the ruler line
    ctx.save();
    ctx.strokeStyle = '#ffff00'; // Yellow
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 5]);
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw distance text at midpoint
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;
    const text = `${Math.round(distanceInFeet)}ft`;

    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Draw text outline for better visibility
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.strokeText(text, midX, midY);
    
    // Draw text fill
    ctx.fillStyle = '#ffff00';
    ctx.fillText(text, midX, midY);

    ctx.restore();
  }

  private drawTargetDistanceRuler(ctx: CanvasRenderingContext2D, config: any) {
    if (!config.targetDistRuler) return;

    const { origin, target } = config.targetDistRuler;
    const dx = target.x - origin.x;
    const dy = target.y - origin.y;
    const horizontalPixelDist = Math.sqrt(dx * dx + dy * dy);

    const gridSize = config.gridSize || 70;
    const scaleValue = config.scale?.value || 5;
    const scaleUnit = config.scale?.unit || 'feet';
    const horizontalFeet = (horizontalPixelDist / gridSize) * scaleValue;

    // 3D distance with elevation
    const verticalFeet = Math.abs((target.elevation || 0) - (origin.elevation || 0));
    const totalFeetRaw = Math.sqrt(horizontalFeet * horizontalFeet + verticalFeet * verticalFeet);
    const totalFeet = Math.max(scaleValue, Math.round(totalFeetRaw / scaleValue) * scaleValue);

    ctx.save();

    // Draw measurement line (cyan, dashed with glow)
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 4;
    ctx.setLineDash([10, 5]);
    ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(target.x, target.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;

    // Draw arrowhead at target
    const angle = Math.atan2(dy, dx);
    const arrowLen = 12;
    ctx.fillStyle = '#00ffff';
    ctx.beginPath();
    ctx.moveTo(target.x, target.y);
    ctx.lineTo(target.x - arrowLen * Math.cos(angle - Math.PI / 6), target.y - arrowLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(target.x - arrowLen * Math.cos(angle + Math.PI / 6), target.y - arrowLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    // Draw distance label at midpoint
    const midX = (origin.x + target.x) / 2;
    const midY = (origin.y + target.y) / 2 - 14;
    let distText = `${totalFeet} ${scaleUnit}`;
    if (verticalFeet > 0) {
      distText += ` (‚Üï${verticalFeet}ft)`;
    }

    // Background pill for readability
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const textWidth = ctx.measureText(distText).width;
    const pillPadX = 8;
    const pillPadY = 4;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
    const pillX = midX - textWidth / 2 - pillPadX;
    const pillY = midY - 10 - pillPadY;
    const pillW = textWidth + pillPadX * 2;
    const pillH = 20 + pillPadY * 2;
    ctx.beginPath();
    ctx.roundRect(pillX, pillY, pillW, pillH, 6);
    ctx.fill();

    // Text outline
    ctx.strokeStyle = '#003333';
    ctx.lineWidth = 3;
    ctx.strokeText(distText, midX, midY);

    // Text fill (cyan)
    ctx.fillStyle = '#00ffff';
    ctx.fillText(distText, midX, midY);

    ctx.restore();
  }

  private drawDragRuler(ctx: CanvasRenderingContext2D, config: any) {
    const origin = config.dragRuler.origin;
    const current = config.dragRuler.current;

    // Yellow dashed line
    ctx.save();
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 4;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(current.x, current.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Distance text
    const distance = Math.sqrt(
      Math.pow(current.x - origin.x, 2) +
      Math.pow(current.y - origin.y, 2)
    );
    const gridDistance = distance / config.gridSize;
    const realDistance = gridDistance * config.scale.value;
    const textX = (origin.x + current.x) / 2;
    const textY = (origin.y + current.y) / 2 - 10;
    const text = `${realDistance.toFixed(1)} ${config.scale.unit}`;

    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Black outline for contrast
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.strokeText(text, textX, textY);

    // Yellow fill
    ctx.fillStyle = '#ffff00';
    ctx.fillText(text, textX, textY);
    ctx.restore();
  }

  private drawAoeEffect(ctx: CanvasRenderingContext2D, aoe: any, config: any) {
    const gs = config.gridSize || 70;
    const origin = aoe.origin;
    const end = aoe.end;
    const dx = end.x - origin.x;
    const dy = end.y - origin.y;
    const rawDist = Math.sqrt(dx * dx + dy * dy);
    const snappedDist = Math.max(gs, Math.round(rawDist / gs) * gs);
    const angle = Math.atan2(dy, dx);

    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = aoe.color;
    ctx.strokeStyle = aoe.color;
    ctx.lineWidth = 3;

    if (aoe.shape === 'circle') {
      ctx.beginPath();
      ctx.arc(origin.x, origin.y, snappedDist, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.8;
      ctx.stroke();
    } else if (aoe.shape === 'cone') {
      const halfAngle = (53 / 2) * (Math.PI / 180);
      ctx.beginPath();
      ctx.moveTo(origin.x, origin.y);
      ctx.arc(origin.x, origin.y, snappedDist, angle - halfAngle, angle + halfAngle);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 0.8;
      ctx.stroke();
    } else if (aoe.shape === 'square') {
      const half = snappedDist;
      const centered = !!aoe.anchorMarkerId;
      ctx.save();
      ctx.translate(origin.x, origin.y);
      ctx.rotate(angle);
      if (centered) {
        ctx.fillRect(-half, -half, half * 2, half * 2);
        ctx.globalAlpha = 0.8;
        ctx.strokeRect(-half, -half, half * 2, half * 2);
      } else {
        ctx.fillRect(0, -half, half * 2, half * 2);
        ctx.globalAlpha = 0.8;
        ctx.strokeRect(0, -half, half * 2, half * 2);
      }
      ctx.restore();
    } else if (aoe.shape === 'line') {
      const halfWidth = gs / 2;
      ctx.save();
      ctx.translate(origin.x, origin.y);
      ctx.rotate(angle);
      ctx.fillRect(0, -halfWidth, snappedDist, halfWidth * 2);
      ctx.globalAlpha = 0.8;
      ctx.strokeRect(0, -halfWidth, snappedDist, halfWidth * 2);
      ctx.restore();
    }

    // Size label
    ctx.globalAlpha = 1.0;
    const gridUnits = snappedDist / gs;
    const realSize = gridUnits * (config.scale?.value || 5);
    const unit = config.scale?.unit || 'feet';
    let labelText = '';
    if (aoe.shape === 'circle') labelText = `${realSize.toFixed(0)} ${unit} radius`;
    else if (aoe.shape === 'cone') labelText = `${realSize.toFixed(0)} ${unit} cone`;
    else if (aoe.shape === 'square') labelText = `${(realSize * 2).toFixed(0)} ${unit} cube`;
    else if (aoe.shape === 'line') labelText = `${realSize.toFixed(0)} ${unit} line`;

    let labelX: number, labelY: number;
    if (aoe.shape === 'circle') {
      labelX = origin.x;
      labelY = origin.y;
    } else {
      labelX = origin.x + Math.cos(angle) * snappedDist / 2;
      labelY = origin.y + Math.sin(angle) * snappedDist / 2;
    }

    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText(labelText, labelX, labelY - 12);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(labelText, labelX, labelY - 12);

    ctx.restore();
  }

  private drawHighlight(ctx: CanvasRenderingContext2D, highlight: any) {
    const config = this.mapConfig;
    ctx.fillStyle = highlight.color + '60';
    ctx.strokeStyle = highlight.color;
    ctx.lineWidth = 2;
    const ox = config.gridOffsetX || 0;
    const oy = config.gridOffsetY || 0;

    if (config.gridType === 'hex-horizontal') {
      const horiz = config.gridSize;
      const size = (2 / 3) * horiz;
      const vert = Math.sqrt(3) * size;
      const colOffsetY = (highlight.col & 1) ? vert / 2 : 0;
      const centerX = highlight.col * horiz + ox;
      const centerY = highlight.row * vert + colOffsetY + oy;
      this.drawFilledHexFlat(ctx, centerX, centerY, size);
    } else if (config.gridType === 'hex-vertical') {
      const vert = config.gridSize;
      const size = (2 / 3) * vert;
      const horiz = Math.sqrt(3) * size;
      const rowOffsetX = (highlight.row & 1) ? horiz / 2 : 0;
      const centerX = highlight.col * horiz + rowOffsetX + ox;
      const centerY = highlight.row * vert + oy;
      this.drawFilledHexPointy(ctx, centerX, centerY, size);
    } else if (config.gridType === 'square') {
      ctx.fillRect(
        highlight.col * config.gridSize + ox,
        highlight.row * config.gridSize + oy,
        config.gridSize,
        config.gridSize
      );
      ctx.strokeRect(
        highlight.col * config.gridSize + ox,
        highlight.row * config.gridSize + oy,
        config.gridSize,
        config.gridSize
      );
    }
  }

  private drawPoiIcon(ctx: CanvasRenderingContext2D, poiRef: any, config: any) {
    // Skip rendering for hexcrawl/exploration maps - PoIs are GM-only hints
    const isHexcrawlMap = (config.gridType === 'hex-horizontal' || config.gridType === 'hex-vertical') && (config.type === 'world' || config.type === 'regional');
    if (isHexcrawlMap) return;
    ctx.globalAlpha = 0.9; // Slightly transparent for player view
    
    const ox = config.gridOffsetX || 0;
    const oy = config.gridOffsetY || 0;
    
    const effectiveSize = config.gridSize;
    
    // Calculate hex center
    let centerX, centerY;
    if (config.gridType === 'hex-horizontal') {
      const horiz = effectiveSize;
      const size = (2/3) * horiz;
      const vert = Math.sqrt(3) * size;
      const colOffsetY = (poiRef.col & 1) ? vert / 2 : 0;
      centerX = poiRef.col * horiz + ox;
      centerY = poiRef.row * vert + colOffsetY + oy;
    } else {
      const vert = effectiveSize;
      const size = (2/3) * vert;
      const horiz = Math.sqrt(3) * size;
      const rowOffsetX = (poiRef.row & 1) ? horiz / 2 : 0;
      centerX = poiRef.col * horiz + rowOffsetX + ox;
      centerY = poiRef.row * vert + oy;
    }
    
    // Load icon from PoI file
    let icon = 'üìç'; // Default icon
    try {
      const fileCache = this.plugin.app.metadataCache.getCache(poiRef.poiFile);
      if (fileCache?.frontmatter?.icon) {
        icon = fileCache.frontmatter.icon;
      }
    } catch (error) {
      console.error('Error loading PoI icon:', error);
    }
    
    // Draw background circle for visibility
    const iconRadius = 18;
    ctx.beginPath();
    ctx.arc(centerX, centerY, iconRadius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw icon (larger and more visible)
    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#000000';
    ctx.fillText(icon, centerX, centerY);
    
    // Reset globalAlpha
    ctx.globalAlpha = 1.0;
  }

  private drawFilledHexFlat(ctx: CanvasRenderingContext2D, cx: number, cy: number, size: number) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i;
      const x = cx + size * Math.cos(angle);
      const y = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  private drawFilledHexPointy(ctx: CanvasRenderingContext2D, cx: number, cy: number, size: number) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i - Math.PI / 6;
      const x = cx + size * Math.cos(angle);
      const y = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  private drawDrawing(ctx: CanvasRenderingContext2D, drawing: any) {
    if (!drawing.points || drawing.points.length === 0) return;
    ctx.strokeStyle = drawing.color;
    ctx.lineWidth = drawing.strokeWidth || 2;
    ctx.beginPath();
    ctx.moveTo(drawing.points[0].x, drawing.points[0].y);
    for (let i = 1; i < drawing.points.length; i++) {
      ctx.lineTo(drawing.points[i].x, drawing.points[i].y);
    }
    ctx.stroke();
  }

  private drawMarker(ctx: CanvasRenderingContext2D, marker: any) {
    const pos = marker.position;
    let markerDef = marker.markerId ? this.plugin.markerLibrary.getMarker(marker.markerId) : null;
    const config = this.mapConfig;

    if (!markerDef) {
      // Fallback rendering for legacy or missing markers
      const radius = 15;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff0000';
      ctx.fill();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      return;
    }

    const radius = this.getMarkerRadius(markerDef);
    const elevation = marker.elevation;
    const itemLayer = marker.layer || 'Player';

    ctx.save();
    
    // Apply transparency for burrowed tokens (underground)
    if (elevation && elevation.isBurrowing) {
      ctx.globalAlpha = 0.5; // ALL burrowed tokens are semi-transparent
    }
    // Apply transparency for Elevated/Subterranean layers
    else if (itemLayer === 'Elevated' || itemLayer === 'Subterranean') {
      ctx.globalAlpha = 0.6;
    }
    
    // Draw drop shadow for flying tokens
    if (elevation && elevation.height && elevation.height > 0) {
      const shadowOffset = Math.min(10, elevation.height / 5);
      const shadowBlur = Math.min(15, elevation.height / 3);
      
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#000000';
      ctx.shadowColor = '#000000';
      ctx.shadowBlur = shadowBlur;
      ctx.shadowOffsetX = shadowOffset;
      ctx.shadowOffsetY = shadowOffset;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, radius * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Reset to main alpha
      if (itemLayer === 'Elevated') {
        ctx.globalAlpha = 0.6;
      }
    }
    
    // Add colored glow for elevated/subterranean
    if (itemLayer === 'Elevated' || itemLayer === 'Subterranean') {
      ctx.save();
      ctx.shadowColor = itemLayer === 'Elevated' ? '#4DA6FF' : '#8B4513';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = itemLayer === 'Elevated' ? '#4DA6FF' : '#8B4513';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    }
    
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
    ctx.closePath();

    // Try to draw image first
    let imageDrawn = false;
    if (markerDef.imageFile) {
      const cachedImg = this.loadMarkerImage(markerDef.imageFile);
      if (cachedImg) {
        ctx.clip();
        const fit = markerDef.imageFit || 'cover';
        const imgW = cachedImg.naturalWidth;
        const imgH = cachedImg.naturalHeight;
        const tokenSize = radius * 2;
        if (fit === 'contain') {
          // Show entire image inside the token, preserving aspect ratio
          ctx.fillStyle = markerDef.backgroundColor || '#333333';
          ctx.fill();
          const scale = Math.min(tokenSize / imgW, tokenSize / imgH);
          const drawW = imgW * scale;
          const drawH = imgH * scale;
          ctx.drawImage(cachedImg, pos.x - drawW / 2, pos.y - drawH / 2, drawW, drawH);
        } else {
          // Cover: fill the token, may crop edges, preserving aspect ratio
          const scale = Math.max(tokenSize / imgW, tokenSize / imgH);
          const drawW = imgW * scale;
          const drawH = imgH * scale;
          ctx.drawImage(cachedImg, pos.x - drawW / 2, pos.y - drawH / 2, drawW, drawH);
        }
        imageDrawn = true;
      }
    }

    // Fill background color only if no image was drawn
    if (!imageDrawn) {
      ctx.fillStyle = markerDef.backgroundColor;
      ctx.fill();
    }

    // Draw border (check marker instance first, then definition, then default to white)
    const borderColor = (marker as any).borderColor || markerDef.borderColor || '#ffffff';
    ctx.restore();
    ctx.save();
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = Math.max(2, radius * 0.1);
    ctx.stroke();

    // Draw icon
    if (markerDef.icon) {
      ctx.fillStyle = '#ffffff';
      ctx.font = '' + Math.max(10, radius * 1.2) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(markerDef.icon, pos.x, pos.y);
    }

    ctx.restore();
    
    // Draw elevation badge
    if (elevation && (elevation.height || elevation.depth)) {
      ctx.save();
      ctx.globalAlpha = 1.0;
      
      const badgeSize = Math.max(16, radius * 0.5);
      const badgeX = pos.x + radius - badgeSize / 2;
      const badgeY = pos.y - radius + badgeSize / 2;
      
      // Badge background
      ctx.fillStyle = elevation.height ? '#4DA6FF' : '#8B4513';
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Badge border
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Badge text
      const elevationValue = elevation.height || elevation.depth || 0;
      const elevationIcon = elevation.height ? '‚Üë' : '‚Üì';
      ctx.fillStyle = '#ffffff';
      ctx.font = `bold ${Math.max(10, badgeSize * 0.6)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(elevationIcon, badgeX, badgeY - 1);
      
      // Show feet value if there's room
      if (radius > 25) {
        ctx.font = `${Math.max(8, badgeSize * 0.4)}px sans-serif`;
        ctx.fillText(`${elevationValue}`, badgeX, badgeY + badgeSize / 2 + 6);
      }
      
      ctx.restore();
    }
    
    // Draw tunnel mode badge
    if (marker.tunnelState) {
      ctx.save();
      ctx.globalAlpha = 1.0;
      
      const badgeSize = Math.max(16, radius * 0.5);
      const badgeX = pos.x - radius + badgeSize / 2;  // Left side
      const badgeY = pos.y - radius + badgeSize / 2;
      
      // Badge background (orange/amber for visibility)
      ctx.fillStyle = '#FF8C00';
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Badge border
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Badge icon (flashlight/tunnel icon)
      ctx.fillStyle = '#ffffff';
      ctx.font = `bold ${Math.max(10, badgeSize * 0.6)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üî¶', badgeX, badgeY);
      
      ctx.restore();
      
      // Draw highlighted tunnel path for this player's own token
      const tunnel = config.tunnels?.find((t: any) => t.id === marker.tunnelState.tunnelId);
      if (tunnel && tunnel.path.length > 1) {
        ctx.save();
        ctx.globalAlpha = 0.25; // More transparent
        
        const CREATURE_SIZE_SQUARES: Record<string, number> = {
          'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
        };
        const squares = CREATURE_SIZE_SQUARES[tunnel.creatureSize] || 1;
        const tunnelWidth = tunnel.tunnelWidth || (squares + 0.5) * config.gridSize;
        
        // Draw path up to current position in subtle earth tone color
        ctx.strokeStyle = '#8B7355';  // Muted brown/tan
        ctx.lineWidth = tunnelWidth + 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(tunnel.path[0].x, tunnel.path[0].y);
        for (let i = 1; i <= marker.tunnelState.pathIndex && i < tunnel.path.length; i++) {
          ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
        }
        ctx.stroke();
        
        // Draw remaining path in dimmer color (ONLY within vision range and line-of-sight)
        if (marker.tunnelState.pathIndex < tunnel.path.length - 1) {
          // Calculate vision range for this marker
          const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
          let visionRange = 0;
          if (marker.darkvision && marker.darkvision > 0) {
            visionRange = Math.max(visionRange, marker.darkvision);
          }
          if (marker.light && marker.light.bright !== undefined) {
            const totalLightRange = (marker.light.bright || 0) + (marker.light.dim || 0);
            visionRange = Math.max(visionRange, totalLightRange);
          }
          const visionRangePx = visionRange * pixelsPerFoot;
          
          // Only draw forward path segments within vision and before corners
          if (visionRangePx > 0) {
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = tunnelWidth;
            ctx.beginPath();
            ctx.moveTo(tunnel.path[marker.tunnelState.pathIndex].x, tunnel.path[marker.tunnelState.pathIndex].y);
            
            let forwardDistance = 0;
            let lastDirection: { dx: number, dy: number } | null = null;
            let drewAnySegment = false;
            
            for (let i = marker.tunnelState.pathIndex + 1; i < tunnel.path.length; i++) {
              const dx = tunnel.path[i].x - tunnel.path[i - 1].x;
              const dy = tunnel.path[i].y - tunnel.path[i - 1].y;
              const segmentDist = Math.sqrt(dx * dx + dy * dy);
              
              // Check for corner
              if (lastDirection && segmentDist > 1) {
                const prevLen = Math.sqrt(lastDirection.dx * lastDirection.dx + lastDirection.dy * lastDirection.dy);
                const currLen = segmentDist;
                if (prevLen > 0 && currLen > 0) {
                  const dotProduct = (lastDirection.dx * dx + lastDirection.dy * dy) / (prevLen * currLen);
                  const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
                  if (angle > Math.PI / 4) break; // 45¬∞ threshold
                }
              }
              
              forwardDistance += segmentDist;
              if (forwardDistance > visionRangePx) break;
              
              ctx.lineTo(tunnel.path[i].x, tunnel.path[i].y);
              lastDirection = { dx, dy };
              drewAnySegment = true;
            }
            
            if (drewAnySegment) {
              ctx.stroke();
            }
          }
        }
        
        ctx.restore();
      }
    }
  }

  private getMarkerRadius(markerDef: any): number {
    const config = this.mapConfig;
    if (['player', 'npc', 'creature'].includes(markerDef.type) && markerDef.creatureSize && config.gridSize) {
      const CREATURE_SIZE_SQUARES: Record<string, number> = {
        'tiny': 1, 'small': 1, 'medium': 1, 'large': 2, 'huge': 3, 'gargantuan': 4
      };
      const squares = CREATURE_SIZE_SQUARES[markerDef.creatureSize] || 1;
      return (squares * config.gridSize) / 2;
    }
    return (markerDef.pixelSize || 30) / 2;
  }

  async onClose() {
    // Clean up the plugin reference to this view
    if (this.plugin._playerMapViews) {
      this.plugin._playerMapViews.delete(this as any);
    }
    
    // Clean up fullscreen event listener
    if ((this as any)._fullscreenChangeHandler) {
      const win = (this.containerEl as any).win || this.containerEl.ownerDocument?.defaultView;
      if (win) {
        const doc = win.document;
        doc.removeEventListener('fullscreenchange', (this as any)._fullscreenChangeHandler);
      }
    }
    
    this.canvas = null;
    this.mapImage = null;
    this.markerImageCache.clear();
    const container = this.containerEl.children[1];
    if (container) {
      (container as HTMLElement).empty();
    }
  }

  private drawFogOfWar(ctx: CanvasRenderingContext2D, w: number, h: number, config: any) {
    const fogCanvas = document.createElement('canvas');
    fogCanvas.width = w;
    fogCanvas.height = h;
    const fogCtx = fogCanvas.getContext('2d');
    if (!fogCtx) return;

    // Start fully black (darkness covers everything)
    fogCtx.fillStyle = '#000000';
    fogCtx.fillRect(0, 0, w, h);

    // In player view, IGNORE pre-revealed fog regions
    // Only player tokens (darkvision + lights) reveal areas
    // This implements "Schr√∂dinger's light" - light only exists when observed by a player

    // Light sources reveal fog in player view
    // Combine standalone lights and marker-attached lights
    const allLights: any[] = [];
    
    // Add standalone light sources (only active ones - default to active if not specified)
    if (config.lightSources && config.lightSources.length > 0) {
      const activeLights = config.lightSources.filter((light: any) => light.active !== false);
      allLights.push(...activeLights);
    }
    
    // Add lights attached to markers (follows marker position)
    // Note: Marker lights don't have an active property - they're always active
    // SKIP lights from tunnel tokens - they don't reveal above-ground fog
    // Lights are physical and illuminate the area regardless of whose vision is selected
    if (config.markers && config.markers.length > 0) {
      config.markers.forEach((marker: any) => {
        if (marker.light && marker.light.bright !== undefined) {
          // Skip lights from tokens in tunnels
          if (marker.tunnelState) {
            console.log('[PV Fog] Skipping light from tunnel token:', marker.id);
            return;
          }
          allLights.push({
            x: marker.position.x,
            y: marker.position.y,
            bright: marker.light.bright,
            dim: marker.light.dim,
            name: marker.light.name || 'Token Light',
            attachedToMarker: marker.id
          });
        }
      });
    }
    
    // Collect vision tokens - defines what's visible in the player view
    // If selectedVisionTokenId is set, use ONLY that token (any type: player, creature, NPC)
    // Otherwise, use all player-type tokens (default combined vision)
    // SKIP tokens in tunnels (underground) - they don't reveal above-ground fog
    const playerTokens: { x: number; y: number; darkvision: number }[] = [];
    if (config.markers && config.markers.length > 0) {
      config.markers.forEach((marker: any) => {
        if (!marker.markerId) return;
        
        // Skip tokens in tunnels (underground)
        if (marker.tunnelState) {
          console.log('[PV Fog] Skipping tunnel token from fog calculation:', marker.id);
          return;
        }
        
        const markerDef = this.plugin.markerLibrary.getMarker(marker.markerId);
        if (!markerDef) return;
        
        // Determine if this token should contribute to vision
        let includeToken = false;
        if (config.selectedVisionTokenId) {
          // Single-token mode: only include the selected token (any type)
          includeToken = (marker.id === config.selectedVisionTokenId);
        } else {
          // Default mode: include all player-type tokens and tokens marked visible to players
          includeToken = (markerDef.type === 'player' || !!marker.visibleToPlayers);
        }
        
        if (includeToken) {
          playerTokens.push({
            x: marker.position.x,
            y: marker.position.y,
            darkvision: marker.darkvision || 0
          });
        }
      });
    }
    
    const pixelsPerFoot = config.gridSize && config.scale?.value ? config.gridSize / config.scale.value : 1;
    console.log('[PV] Vision calculation params:', { 
      gridSize: config.gridSize, 
      scale: config.scale?.value, 
      pixelsPerFoot,
      playerTokens: playerTokens.length,
      allLights: allLights.length,
      playerTokenDetails: playerTokens.map(pt => ({ x: pt.x.toFixed(1), y: pt.y.toFixed(1), darkvision: pt.darkvision })),
      lightDetails: allLights.map(l => ({ x: l.x.toFixed(1), y: l.y.toFixed(1), bright: l.bright, dim: l.dim, attached: l.attachedToMarker }))
    });
    // Filter walls to only include those that block sight
    // Open doors/windows allow light through, windows/terrain always allow light
    const walls = (config.walls || []).filter((wall: any) => {
      const type = wall.type || 'wall';
      // Open doors (and open secret doors) allow light through
      if ((type === 'door' || type === 'secret') && wall.open) {
        return false;
      }
      // Windows are transparent - always allow light through (even when closed)
      if (type === 'window') {
        return false;
      }
      // Terrain doesn't block sight
      if (type === 'terrain') {
        return false;
      }
      return true;
    });
    
    // Create player NORMAL VISION mask - union of all player vision cones
    // Normal vision allows players to see lights from any distance (only blocked by walls)
    const playerVisionCanvas = document.createElement('canvas');
    playerVisionCanvas.width = w;
    playerVisionCanvas.height = h;
    const playerVisionCtx = playerVisionCanvas.getContext('2d');
    
    if (playerVisionCtx && playerTokens.length > 0) {
      playerVisionCtx.fillStyle = 'white';
      playerTokens.forEach((pt: any) => {
        // Normal vision extends very far (simulate infinite by using large radius)
        const normalVisionRadius = 10000; // px, effectively infinite
        const visPoly = this.computeVisibilityPolygon(pt.x, pt.y, normalVisionRadius, walls);
        if (visPoly.length >= 3) {
          playerVisionCtx.beginPath();
          const first = visPoly[0];
          if (first) {
            playerVisionCtx.moveTo(first.x, first.y);
            for (let i = 1; i < visPoly.length; i++) {
              const pt = visPoly[i];
              if (pt) playerVisionCtx.lineTo(pt.x, pt.y);
            }
            playerVisionCtx.closePath();
            playerVisionCtx.fill();
          }
        }
      });
    }
    
    // Create player DARKVISION mask (for grayscale overlay later)
    const playerDarkvisionCanvas = document.createElement('canvas');
    playerDarkvisionCanvas.width = w;
    playerDarkvisionCanvas.height = h;
    const playerDarkvisionCtx = playerDarkvisionCanvas.getContext('2d');
    
    if (playerDarkvisionCtx && playerTokens.length > 0) {
      playerDarkvisionCtx.fillStyle = 'white';
      playerTokens.forEach((pt: any) => {
        if (pt.darkvision > 0) {
          const radiusPx = pt.darkvision * pixelsPerFoot;
          const visPoly = this.computeVisibilityPolygon(pt.x, pt.y, radiusPx, walls);
          if (visPoly.length >= 3) {
            playerDarkvisionCtx.beginPath();
            const first = visPoly[0];
            if (first) {
              playerDarkvisionCtx.moveTo(first.x, first.y);
              for (let i = 1; i < visPoly.length; i++) {
                const pt = visPoly[i];
                if (pt) playerDarkvisionCtx.lineTo(pt.x, pt.y);
              }
              playerDarkvisionCtx.closePath();
              playerDarkvisionCtx.fill();
            }
          }
        }
      });
    }
    
    // Draw lights - intersect each light with player vision cones
    if (allLights.length > 0 && playerVisionCtx) {
      console.log('[PV] Drawing lights intersected with player vision:',{ lights: allLights.length, playerTokens: playerTokens.length });
      
      allLights.forEach((light: any, i: number) => {
        const brightRadiusPx = light.bright * pixelsPerFoot;
        const dimRadiusPx = light.dim * pixelsPerFoot;
        const totalRadiusPx = brightRadiusPx + dimRadiusPx;
        
        if (totalRadiusPx <= 0) {
          console.log(`[PV] Light ${i}: SKIPPING (no radius) - bright=${light.bright}, dim=${light.dim}`);
          return;
        }
        
        console.log(`[PV] Light ${i} at (${light.x.toFixed(1)}, ${light.y.toFixed(1)}): bright=${light.bright}ft (${brightRadiusPx.toFixed(1)}px), dim=${light.dim}ft (${dimRadiusPx.toFixed(1)}px) - DRAWING WITH PLAYER VISION CLIP`);
        
        // Create temp canvas for this light
        const lightCanvas = document.createElement('canvas');
        lightCanvas.width = w;
        lightCanvas.height = h;
        const lightCtx = lightCanvas.getContext('2d');
        
        if (lightCtx) {
          // Draw the light on transparent canvas (makes white areas)
          lightCtx.save();
          
          // Compute light visibility with wall occlusion
          const lightVisPoly = this.computeVisibilityPolygon(light.x, light.y, totalRadiusPx, walls);
          
          if (lightVisPoly.length >= 3) {
            // Clip to light visibility
            lightCtx.beginPath();
            const firstPt = lightVisPoly[0];
            if (firstPt) {
              lightCtx.moveTo(firstPt.x, firstPt.y);
              for (let j = 1; j < lightVisPoly.length; j++) {
                const pt = lightVisPoly[j];
                if (pt) lightCtx.lineTo(pt.x, pt.y);
              }
              lightCtx.closePath();
              lightCtx.clip();
            }
            
            // Draw light as white circles
            if (brightRadiusPx > 0) {
              lightCtx.fillStyle = 'rgba(255, 255, 255, 1.0)';
              lightCtx.beginPath();
              lightCtx.arc(light.x, light.y, brightRadiusPx, 0, Math.PI * 2);
              lightCtx.fill();
            }
            
            if (dimRadiusPx > 0) {
              lightCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
              lightCtx.beginPath();
              lightCtx.arc(light.x, light.y, totalRadiusPx, 0, Math.PI * 2);
              lightCtx.fill();
            }
          }
          
          lightCtx.restore();
          
          // Now intersect with player vision - only show where light rays AND player vision overlap
          lightCtx.globalCompositeOperation = 'destination-in';
          lightCtx.drawImage(playerVisionCanvas, 0, 0);
          
          // Apply to fog canvas (remove fog where light is)
          fogCtx.globalCompositeOperation = 'destination-out';
          fogCtx.drawImage(lightCanvas, 0, 0);
          fogCtx.globalCompositeOperation = 'source-over';
          
          console.log(`[PV] Light ${i}: Applied to fog (intersection of light rays + player vision)`);
        }
      });
    }
    
    // Darkvision reveals fog but shows grayscale
    // Collect markers with darkvision for fog reveal
    // Respects selectedVisionTokenId: single-token mode uses only the selected token (any type)
    // Default mode uses all player-type tokens
    const darkvisionMarkers: any[] = [];
    if (config.markers && config.markers.length > 0) {
      config.markers.forEach((marker: any) => {
        if (!marker.markerId || !marker.darkvision || marker.darkvision <= 0) return;
        
        // Skip tokens in tunnels - they don't reveal surface fog
        if (marker.tunnelState) {
          console.log('[PV] Skipping tunnel token from darkvision fog reveal:', { id: marker.id, tunnelId: marker.tunnelState.tunnelId });
          return;
        }
        
        const markerDef = this.plugin.markerLibrary.getMarker(marker.markerId);
        if (!markerDef) return;
        
        // Determine if this token should contribute to darkvision
        let includeToken = false;
        if (config.selectedVisionTokenId) {
          // Single-token mode: only include the selected token (any type)
          includeToken = (marker.id === config.selectedVisionTokenId);
        } else {
          // Default mode: include all player-type tokens and tokens marked visible to players
          includeToken = (markerDef.type === 'player' || !!marker.visibleToPlayers);
        }
        
        if (includeToken) {
          console.log('[PV] Adding darkvision marker:', { id: marker.id, x: marker.position.x.toFixed(1), y: marker.position.y.toFixed(1), range: marker.darkvision, type: markerDef.type });
          darkvisionMarkers.push({
            x: marker.position.x,
            y: marker.position.y,
            range: marker.darkvision
          });
        }
      });
    }
    
    console.log('[PV] Fog reveal summary:', {
      playerTokens: playerTokens.length,
      lightsTotal: allLights.length,
      darkvisionMarkers: darkvisionMarkers.length,
      message: darkvisionMarkers.length === 0 && allLights.length === 0 ? 'NO FOG WILL BE REVEALED (no lights or darkvision)' : 'Fog will be revealed'
    });
    
    // Create grayscale overlay canvas (for darkvision-only areas)
    const grayscaleCanvas = document.createElement('canvas');
    grayscaleCanvas.width = w;
    grayscaleCanvas.height = h;
    const grayCtx = grayscaleCanvas.getContext('2d');
    
    if (darkvisionMarkers.length > 0 && grayCtx) {
      console.log('[PV] Drawing darkvision fog reveal:', { count: darkvisionMarkers.length, markers: darkvisionMarkers.map(dv => ({ x: dv.x.toFixed(1), y: dv.y.toFixed(1), range: dv.range })) });
      
      // First, draw darkvision to reveal fog (cuts holes in fog canvas)
      darkvisionMarkers.forEach((dv: any, i: number) => {
        const radiusPx = dv.range * pixelsPerFoot;
        if (radiusPx > 0) {
          console.log(`[PV] Darkvision ${i}: Revealing ${dv.range}ft (${radiusPx.toFixed(1)}px) radius at (${dv.x.toFixed(1)}, ${dv.y.toFixed(1)})`);
          // Darkvision reveals fog with wall occlusion
          this.drawLightWithShadows(fogCtx, dv.x, dv.y, radiusPx, 0, walls);
        }
      });
      
      // Build grayscale overlay: areas where darkvision reveals but no actual light
      // Start with dark gray overlay
      grayCtx.fillStyle = 'rgba(60, 60, 80, 0.6)';
      grayCtx.fillRect(0, 0, w, h);
      
      // FIRST: Clip grayscale to ONLY darkvision areas (before cutting out lights)
      grayCtx.globalCompositeOperation = 'destination-in';
      if (playerDarkvisionCtx) {
        grayCtx.drawImage(playerDarkvisionCanvas, 0, 0);
      }
      
      // SECOND: Cut out areas where actual lights are visible to players - those should be full color
      grayCtx.globalCompositeOperation = 'destination-out';
      if (allLights.length > 0 && playerVisionCtx) {
        allLights.forEach((light: any) => {
          const brightRadiusPx = light.bright * pixelsPerFoot;
          const dimRadiusPx = light.dim * pixelsPerFoot;
          const totalRadiusPx = brightRadiusPx + dimRadiusPx;
          
          if (totalRadiusPx <= 0) return;
          
          // Create temp canvas for this light's illuminated area
          const lightCanvas = document.createElement('canvas');
          lightCanvas.width = w;
          lightCanvas.height = h;
          const lightCtx = lightCanvas.getContext('2d');
          
          if (lightCtx) {
            // Compute light visibility with wall occlusion
            const lightVisPoly = this.computeVisibilityPolygon(light.x, light.y, totalRadiusPx, walls);
            
            if (lightVisPoly.length >= 3) {
              lightCtx.save();
              
              // Clip to light visibility
              lightCtx.beginPath();
              const firstPt = lightVisPoly[0];
              if (firstPt) {
                lightCtx.moveTo(firstPt.x, firstPt.y);
                for (let j = 1; j < lightVisPoly.length; j++) {
                  const pt = lightVisPoly[j];
                  if (pt) lightCtx.lineTo(pt.x, pt.y);
                }
                lightCtx.closePath();
                lightCtx.clip();
              }
              
              // Draw light as white (where light IS present)
              if (brightRadiusPx > 0) {
                lightCtx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                lightCtx.beginPath();
                lightCtx.arc(light.x, light.y, brightRadiusPx, 0, Math.PI * 2);
                lightCtx.fill();
              }
              
              if (dimRadiusPx > 0) {
                lightCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                lightCtx.beginPath();
                lightCtx.arc(light.x, light.y, totalRadiusPx, 0, Math.PI * 2);
                lightCtx.fill();
              }
              
              lightCtx.restore();
              
              // Clip to player vision (only parts players can see)
              lightCtx.globalCompositeOperation = 'destination-in';
              lightCtx.drawImage(playerVisionCanvas, 0, 0);
              
              // Remove from grayscale (make these lit areas full color)
              grayCtx.drawImage(lightCanvas, 0, 0);
            }
          }
        });
      }
    }

    // Draw fully opaque fog for player view
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.drawImage(fogCanvas, 0, 0);
    ctx.restore();
    
    // Apply grayscale overlay on top (darkvision tint)
    if (darkvisionMarkers.length > 0 && grayCtx) {
      console.log('[PV] Applying grayscale overlay for darkvision areas');
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.globalCompositeOperation = 'source-over';
      ctx.drawImage(grayscaleCanvas, 0, 0);
      ctx.restore();
    } else {
      console.log('[PV] Not applying grayscale overlay:', { darkvisionMarkers: darkvisionMarkers.length, hasGrayCtx: !!grayCtx });
    }
  }

  /**
   * Draw light with wall occlusion using visibility polygon algorithm
   * Bright zone is fully revealed, dim zone is partially revealed (50% fog remains)
   */
  private drawLightWithShadows(
    fogCtx: CanvasRenderingContext2D,
    lightX: number,
    lightY: number,
    brightRadius: number,
    dimRadius: number,
    walls: any[]
  ) {
    const totalRadius = brightRadius + dimRadius;
    if (totalRadius <= 0) return;

    // Compute visibility polygon using ray casting
    const visibilityPoly = this.computeVisibilityPolygon(lightX, lightY, totalRadius, walls);
    
    if (visibilityPoly.length < 3) {
      // No walls or no valid polygon - just draw full circle
      fogCtx.save();
      fogCtx.globalCompositeOperation = 'destination-out';
      
      if (brightRadius > 0) {
        fogCtx.fillStyle = 'rgba(255, 255, 255, 1.0)';
        fogCtx.beginPath();
        fogCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2);
        fogCtx.fill();
      }
      
      if (dimRadius > 0) {
        fogCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        fogCtx.beginPath();
        fogCtx.arc(lightX, lightY, totalRadius, 0, Math.PI * 2);
        fogCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2, true);
        fogCtx.fill();
      }
      
      fogCtx.restore();
      return;
    }

    // Draw using visibility polygon as clip
    fogCtx.save();
    
    // Create clipping path from visibility polygon
    fogCtx.beginPath();
    const firstPt = visibilityPoly[0];
    if (!firstPt) return;
    fogCtx.moveTo(firstPt.x, firstPt.y);
    for (let i = 1; i < visibilityPoly.length; i++) {
      const pt = visibilityPoly[i];
      if (pt) fogCtx.lineTo(pt.x, pt.y);
    }
    fogCtx.closePath();
    fogCtx.clip();
    
    // Draw light within clipped area
    fogCtx.globalCompositeOperation = 'destination-out';
    
    if (brightRadius > 0) {
      fogCtx.fillStyle = 'rgba(255, 255, 255, 1.0)';
      fogCtx.beginPath();
      fogCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2);
      fogCtx.fill();
    }
    
    if (dimRadius > 0) {
      fogCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      fogCtx.beginPath();
      fogCtx.arc(lightX, lightY, totalRadius, 0, Math.PI * 2);
      fogCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2, true);
      fogCtx.fill();
    }
    
    fogCtx.restore();
  }

  /**
   * Compute visibility polygon from a point using ray casting
   * Returns array of points forming the visible area boundary
   */
  /**
   * Check if there is a clear line of sight between two points (not blocked by walls)
   */
  private hasLineOfSight(
    x1: number, y1: number,
    x2: number, y2: number,
    walls: any[]
  ): boolean {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) return true; // Same point
    
    const dirX = dx / distance;
    const dirY = dy / distance;
    
    // Check if ray from (x1,y1) to (x2,y2) intersects any wall
    for (const wall of walls) {
      if (!wall.start || !wall.end) continue;
      
      const t = this.raySegmentIntersection(
        x1, y1, dirX, dirY,
        wall.start.x, wall.start.y,
        wall.end.x, wall.end.y
      );
      
      // If intersection exists and is closer than target, line of sight is blocked
      if (t !== null && t > 0.1 && t < distance - 0.1) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Generate wall segments for a tunnel from its path
   * Creates parallel walls on both sides of the path
   */
  private generateTunnelWalls(
    path: Array<{x: number, y: number}>,
    tunnelWidth: number
  ): Array<{start: {x: number, y: number}, end: {x: number, y: number}}> {
    if (!path || path.length < 2) return [];
    
    const walls: Array<{start: {x: number, y: number}, end: {x: number, y: number}}> = [];
    const halfWidth = tunnelWidth / 2;
    
    // Generate parallel walls along each segment of the path
    for (let i = 0; i < path.length - 1; i++) {
      const p1 = path[i];
      const p2 = path[i + 1];
      if (!p1 || !p2) continue;
      
      // Calculate perpendicular vector for this segment
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      
      if (len === 0) continue;
      
      // Normalized perpendicular vector (rotated 90 degrees)
      const perpX = -dy / len;
      const perpY = dx / len;
      
      // Calculate wall endpoints for this segment
      const leftStart = { x: p1.x + perpX * halfWidth, y: p1.y + perpY * halfWidth };
      const leftEnd = { x: p2.x + perpX * halfWidth, y: p2.y + perpY * halfWidth };
      const rightStart = { x: p1.x - perpX * halfWidth, y: p1.y - perpY * halfWidth };
      const rightEnd = { x: p2.x - perpX * halfWidth, y: p2.y - perpY * halfWidth };
      
      // Add left wall segment
      walls.push({ start: leftStart, end: leftEnd });
      
      // Add right wall segment
      walls.push({ start: rightStart, end: rightEnd });
    }
    
    // Add end caps to close the tunnel at entrance and exit
    if (path.length >= 2) {
      // Entrance cap
      const firstSegment = path[1];
      const firstPoint = path[0];
      if (firstSegment && firstPoint) {
        const dx = firstSegment.x - firstPoint.x;
        const dy = firstSegment.y - firstPoint.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          const perpX = -dy / len;
          const perpY = dx / len;
          walls.push({
            start: { x: firstPoint.x + perpX * halfWidth, y: firstPoint.y + perpY * halfWidth },
            end: { x: firstPoint.x - perpX * halfWidth, y: firstPoint.y - perpY * halfWidth }
          });
        }
      }
      
      // Exit cap
      const lastIdx = path.length - 1;
      const lastPoint = path[lastIdx];
      const secondLastPoint = path[lastIdx - 1];
      if (lastPoint && secondLastPoint) {
        const dx = lastPoint.x - secondLastPoint.x;
        const dy = lastPoint.y - secondLastPoint.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          const perpX = -dy / len;
          const perpY = dx / len;
          walls.push({
            start: { x: lastPoint.x + perpX * halfWidth, y: lastPoint.y + perpY * halfWidth },
            end: { x: lastPoint.x - perpX * halfWidth, y: lastPoint.y - perpY * halfWidth }
          });
        }
      }
    }
    
    return walls;
  }

  private computeVisibilityPolygon(
    originX: number,
    originY: number,
    maxRadius: number,
    walls: any[]
  ): { x: number; y: number }[] {
    // Collect all wall segments within range
    const segments: { p1: { x: number; y: number }; p2: { x: number; y: number } }[] = [];
    
    // Add bounding circle as segments (approximated with many points)
    const circleSegments = 64;
    for (let i = 0; i < circleSegments; i++) {
      const angle1 = (i / circleSegments) * Math.PI * 2;
      const angle2 = ((i + 1) / circleSegments) * Math.PI * 2;
      segments.push({
        p1: { x: originX + Math.cos(angle1) * maxRadius, y: originY + Math.sin(angle1) * maxRadius },
        p2: { x: originX + Math.cos(angle2) * maxRadius, y: originY + Math.sin(angle2) * maxRadius }
      });
    }
    
    // Add wall segments
    walls.forEach((wall: any) => {
      if (!wall.start || !wall.end) return;
      
      // Only consider walls that might be within range
      const dx1 = wall.start.x - originX;
      const dy1 = wall.start.y - originY;
      const dx2 = wall.end.x - originX;
      const dy2 = wall.end.y - originY;
      const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      
      if (dist1 > maxRadius * 2 && dist2 > maxRadius * 2) return;
      
      segments.push({
        p1: { x: wall.start.x, y: wall.start.y },
        p2: { x: wall.end.x, y: wall.end.y }
      });
    });
    
    // Collect all unique angles to wall endpoints
    const angles: number[] = [];
    const epsilon = 0.00001;
    
    segments.forEach(seg => {
      const dx1 = seg.p1.x - originX;
      const dy1 = seg.p1.y - originY;
      const dx2 = seg.p2.x - originX;
      const dy2 = seg.p2.y - originY;
      
      const angle1 = Math.atan2(dy1, dx1);
      const angle2 = Math.atan2(dy2, dx2);
      
      // Cast 3 rays per endpoint: one to the point, one slightly before, one slightly after
      angles.push(angle1 - epsilon, angle1, angle1 + epsilon);
      angles.push(angle2 - epsilon, angle2, angle2 + epsilon);
    });
    
    // Sort angles
    angles.sort((a, b) => a - b);
    
    // Cast rays and find intersection points
    const points: { x: number; y: number; angle: number }[] = [];
    
    for (const angle of angles) {
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      
      // Find closest intersection
      let closestT = maxRadius;
      
      for (const seg of segments) {
        const t = this.raySegmentIntersection(
          originX, originY, dx, dy,
          seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y
        );
        
        if (t !== null && t > 0 && t < closestT) {
          closestT = t;
        }
      }
      
      points.push({
        x: originX + dx * closestT,
        y: originY + dy * closestT,
        angle: angle
      });
    }
    
    // Remove duplicate points (very close together)
    const uniquePoints: { x: number; y: number }[] = [];
    for (const pt of points) {
      if (uniquePoints.length === 0) {
        uniquePoints.push({ x: pt.x, y: pt.y });
      } else {
        const last = uniquePoints[uniquePoints.length - 1];
        if (last) {
          const dist = Math.sqrt((pt.x - last.x) ** 2 + (pt.y - last.y) ** 2);
          if (dist > 0.5) {
            uniquePoints.push({ x: pt.x, y: pt.y });
          }
        }
      }
    }
    
    return uniquePoints;
  }

  /**
   * Calculate intersection of ray with line segment
   * Returns distance t along ray, or null if no intersection
   */
  private raySegmentIntersection(
    rayX: number, rayY: number,
    rayDx: number, rayDy: number,
    segX1: number, segY1: number,
    segX2: number, segY2: number
  ): number | null {
    const segDx = segX2 - segX1;
    const segDy = segY2 - segY1;
    
    const denom = rayDx * segDy - rayDy * segDx;
    if (Math.abs(denom) < 0.00001) return null; // Parallel
    
    const t = ((segX1 - rayX) * segDy - (segY1 - rayY) * segDx) / denom;
    const u = ((segX1 - rayX) * rayDy - (segY1 - rayY) * rayDx) / denom;
    
    if (t > 0 && u >= 0 && u <= 1) {
      return t;
    }
    
    return null;
  }

  /**
   * Check if a point is inside a polygon using ray casting algorithm
   */
  private pointInPolygon(x: number, y: number, polygon: { x: number; y: number }[]): boolean {
    if (polygon.length < 3) return false;
    
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const pi = polygon[i];
      const pj = polygon[j];
      if (!pi || !pj) continue;
      
      const xi = pi.x, yi = pi.y;
      const xj = pj.x, yj = pj.y;
      
      if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
        inside = !inside;
      }
    }
    
    return inside;
  }

  /**
   * Draw light with wall occlusion, intersected with player visibility
   * Only reveals areas that both the light illuminates AND players can see
   */
  private drawLightWithPlayerVisibility(
    fogCtx: CanvasRenderingContext2D,
    lightX: number,
    lightY: number,
    brightRadius: number,
    dimRadius: number,
    walls: any[],
    playerVisCanvas: HTMLCanvasElement
  ) {
    const totalRadius = brightRadius + dimRadius;
    if (totalRadius <= 0) return;

    // Compute light's visibility polygon
    const lightVisPoly = this.computeVisibilityPolygon(lightX, lightY, totalRadius, walls);
    
    if (lightVisPoly.length < 3) {
      // No valid polygon - fallback
      return;
    }

    // Create a temporary canvas for the light
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = fogCtx.canvas.width;
    tempCanvas.height = fogCtx.canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    if (!tempCtx) return;

    // Draw the light's visibility polygon on temp canvas
    tempCtx.fillStyle = 'white';
    tempCtx.beginPath();
    const first = lightVisPoly[0];
    if (!first) return;
    tempCtx.moveTo(first.x, first.y);
    for (let i = 1; i < lightVisPoly.length; i++) {
      const pt = lightVisPoly[i];
      if (pt) tempCtx.lineTo(pt.x, pt.y);
    }
    tempCtx.closePath();
    tempCtx.fill();

    // Intersect with player visibility using destination-in
    tempCtx.globalCompositeOperation = 'destination-in';
    tempCtx.drawImage(playerVisCanvas, 0, 0);
    
    // Now tempCanvas contains only the intersection of light and player visibility
    // Use this as a clip mask to draw the light effect on fog
    fogCtx.save();
    
    // Create clip from the intersection
    fogCtx.globalCompositeOperation = 'destination-out';
    
    // Draw bright zone
    if (brightRadius > 0) {
      // Create another temp canvas for bright zone clipped by intersection
      const brightCanvas = document.createElement('canvas');
      brightCanvas.width = fogCtx.canvas.width;
      brightCanvas.height = fogCtx.canvas.height;
      const brightCtx = brightCanvas.getContext('2d');
      if (brightCtx) {
        // Draw bright circle
        brightCtx.fillStyle = 'white';
        brightCtx.beginPath();
        brightCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2);
        brightCtx.fill();
        
        // Intersect with light+player visibility
        brightCtx.globalCompositeOperation = 'destination-in';
        brightCtx.drawImage(tempCanvas, 0, 0);
        
        // Apply to fog with full opacity
        fogCtx.globalAlpha = 1.0;
        fogCtx.drawImage(brightCanvas, 0, 0);
      }
    }
    
    // Draw dim zone
    if (dimRadius > 0) {
      const dimCanvas = document.createElement('canvas');
      dimCanvas.width = fogCtx.canvas.width;
      dimCanvas.height = fogCtx.canvas.height;
      const dimCtx = dimCanvas.getContext('2d');
      if (dimCtx) {
        // Draw dim ring (total - bright)
        dimCtx.fillStyle = 'white';
        dimCtx.beginPath();
        dimCtx.arc(lightX, lightY, totalRadius, 0, Math.PI * 2);
        dimCtx.arc(lightX, lightY, brightRadius, 0, Math.PI * 2, true);
        dimCtx.fill();
        
        // Intersect with light+player visibility
        dimCtx.globalCompositeOperation = 'destination-in';
        dimCtx.drawImage(tempCanvas, 0, 0);
        
        // Apply to fog with partial opacity (dim light)
        fogCtx.globalAlpha = 0.7;
        fogCtx.drawImage(dimCanvas, 0, 0);
      }
    }
    
    fogCtx.restore();
  }
}
